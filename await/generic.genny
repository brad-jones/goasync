package await

import (
	"github.com/go-errors/errors"
	"github.com/brad-jones/goerr"
	"github.com/brad-jones/goasync/task"
	"github.com/brad-jones/goasync/stop"
	"github.com/cheekybits/genny/generic"
)

// Awaitable is a generic type parameter for use with https://github.com/cheekybits/genny
type Awaitable generic.Type

// AllAwaitables will wait for every given task to emit a result.
// The results (& errors) will be returned in a slice ordered the
// same as the input.
func AllAwaitables(awaitables ...*task.AwaitableTask) ([]Awaitable, error) {
	awaited := []Awaitable{}
	awaitedErrors := []error{}

	for _, awaitable := range awaitables {
		v, e := awaitable.Result()
		awaited = append(awaited, v)
		awaitedErrors = append(awaitedErrors, e)
	}

	if len(awaitedErrors) > 0 {
		return nil, errors.New(&ErrTaskFailed{
			Errors: awaitedErrors,
		})
	}

	return awaited, nil
}

// AllAwaitableSlices will wait for every given task to emit a result.
// The results (& errors) will be returned in a slice ordered the
// same as the input.
func AllAwaitableSlices(awaitables ...*task.AwaitableSliceTask) ([][]Awaitable, error) {
	awaited := [][]Awaitable{}
	awaitedErrors := []error{}

	for _, awaitable := range awaitables {
		v, e := awaitable.Result()
		awaited = append(awaited, v)
		awaitedErrors = append(awaitedErrors, e)
	}

	if len(awaitedErrors) > 0 {
		return nil, errors.New(&ErrTaskFailed{
			Errors: awaitedErrors,
		})
	}

	return awaited, nil
}

// AnyAwaitable will wait for the first task to emit a result (or an error)
// and return that, canceling all other tasks.
func AnyAwaitable(awaitables ...*task.AwaitableTask) (value Awaitable, err error) {
	v := make([]interface{}, len(awaitables))
	for i := range awaitables {
		v[i] = awaitables[i]
	}
	defer stop.All(stop.ToStopables(v...)...)

	type doneOnce struct {
		o  sync.Once
		ch chan struct{}
	}
	done := doneOnce{
		ch: make(chan struct{}, 1),
	}
	closeDone := func() {
		done.o.Do(func() {
			close(done.ch)
		})
	}

	for _, awaitable := range awaitables {
		go func() {
			defer closeDone()
			value, err = awaitable.Result()
		}()
	}

	<-done.ch
	return value, err
}


// FastAnyAwaitable does the same as AnyAwaitable but does not wait for all
// other tasks to stop. It does tell them to stop it just doesn't wait for
// them to stop.
func FastAnyAwaitable(awaitables ...*task.AwaitableTask) (value Awaitable, err error) {
	v := make([]interface{}, len(awaitables))
	for i := range awaitables {
		v[i] = awaitables[i]
	}
	defer stop.AllAsync(stop.ToStopables(v...)...)

	type doneOnce struct {
		o  sync.Once
		ch chan struct{}
	}
	done := doneOnce{
		ch: make(chan struct{}, 1),
	}
	closeDone := func() {
		done.o.Do(func() {
			close(done.ch)
		})
	}

	for _, awaitable := range awaitables {
		go func() {
			defer closeDone()
			value, err = awaitable.Result()
		}()
	}

	<-done.ch
	return value, err
}

// AnyAwaitableSlice will wait for the first task to emit a result (or an error)
// and return that, canceling all other tasks.
func AnyAwaitableSlice(awaitables ...*task.AwaitableSliceTask) (value []Awaitable, err error) {
	v := make([]interface{}, len(awaitables))
	for i := range awaitables {
		v[i] = awaitables[i]
	}
	defer stop.All(stop.ToStopables(v...)...)

	type doneOnce struct {
		o  sync.Once
		ch chan struct{}
	}
	done := doneOnce{
		ch: make(chan struct{}, 1),
	}
	closeDone := func() {
		done.o.Do(func() {
			close(done.ch)
		})
	}

	for _, awaitable := range awaitables {
		go func() {
			defer closeDone()
			value, err = awaitable.Result()
		}()
	}

	<-done.ch
	return value, err
}


// FastAnyAwaitableSlice does the same as AnyAwaitableSlice but does not wait
// for all other tasks to stop. It does tell them to stop it just doesn't wait
// for them to stop.
func FastAnyAwaitableSlice(awaitables ...*task.AwaitableSliceTask) (value []Awaitable, err error) {
	v := make([]interface{}, len(awaitables))
	for i := range awaitables {
		v[i] = awaitables[i]
	}
	defer stop.AllAsync(stop.ToStopables(v...)...)

	type doneOnce struct {
		o  sync.Once
		ch chan struct{}
	}
	done := doneOnce{
		ch: make(chan struct{}, 1),
	}
	closeDone := func() {
		done.o.Do(func() {
			close(done.ch)
		})
	}

	for _, awaitable := range awaitables {
		go func() {
			defer closeDone()
			value, err = awaitable.Result()
		}()
	}

	<-done.ch
	return value, err
}

// AllAwaitablesOrError will wait for every given task to emit a result or
// return as soon as an error is encountered, canceling all other tasks.
func AllAwaitablesOrError(awaitables ...*task.AwaitableTask) ([]Awaitable, error) {
	v := make([]interface{}, len(awaitables))
	for i := range awaitables {
		v[i] = awaitables[i]
	}
	defer stop.All(stop.ToStopables(v...)...)

	errCh := make(chan error, 1)
	valueCh := make(chan Awaitable, 1)

	for _, awaitable := range awaitables {
		go func() {
			v, err := awaitable.Result()
			if err != nil {
				errCh <- errors.Wrap(err, 0)
				return
			}
			valueCh <- v
		}()
	}

	values := []Awaitable{}
	for {
		select {
		case err := <-errCh:
			return nil, errors.Wrap(err, 0)
		case value := <-valueCh:
			values = append(values, value)
			if len(values) == len(awaitables) {
				return values, nil
			}
		}
	}
}

// FastAllAwaitablesOrError does the same as AllAwaitablesOrError but does not
// wait for all other tasks to stop. It does tell them to stop it just doesn't
// wait for them to stop.
func FastAllAwaitablesOrError(awaitables ...*task.AwaitableTask) ([]Awaitable, error) {
	v := make([]interface{}, len(awaitables))
	for i := range awaitables {
		v[i] = awaitables[i]
	}
	defer stop.AllAsync(stop.ToStopables(v...)...)

	errCh := make(chan error, 1)
	valueCh := make(chan Awaitable, 1)

	for _, awaitable := range awaitables {
		go func() {
			v, err := awaitable.Result()
			if err != nil {
				errCh <- errors.Wrap(err, 0)
				return
			}
			valueCh <- v
		}()
	}

	values := []Awaitable{}
	for {
		select {
		case err := <-errCh:
			return nil, errors.Wrap(err, 0)
		case value := <-valueCh:
			values = append(values, value)
			if len(values) == len(awaitables) {
				return values, nil
			}
		}
	}
}

// AllAwaitableSlicesOrError will wait for every given task to emit a result or
// return as soon as an error is encountered, canceling all other tasks.
func AllAwaitableSlicesOrError(awaitables ...*task.AwaitableSliceTask) ([][]Awaitable, error) {
	v := make([]interface{}, len(awaitables))
	for i := range awaitables {
		v[i] = awaitables[i]
	}
	defer stop.All(stop.ToStopables(v...)...)

	errCh := make(chan error, 1)
	valueCh := make(chan []Awaitable, 1)

	for _, awaitable := range awaitables {
		go func() {
			v, err := awaitable.Result()
			if err != nil {
				errCh <- errors.Wrap(err, 0)
				return
			}
			valueCh <- v
		}()
	}

	values := [][]Awaitable{}
	for {
		select {
		case err := <-errCh:
			return nil, errors.Wrap(err, 0)
		case value := <-valueCh:
			values = append(values, value)
			if len(values) == len(awaitables) {
				return values, nil
			}
		}
	}
}

// FastAllAwaitableSlicesOrError does the same as AllAwaitableSlicesOrError but
// does not wait for all other tasks to stop. It does tell them to stop it just
// doesn't wait for them to stop.
func FastAllAwaitableSlicesOrError(awaitables ...*task.AwaitableSliceTask) ([][]Awaitable, error) {
	v := make([]interface{}, len(awaitables))
	for i := range awaitables {
		v[i] = awaitables[i]
	}
	defer stop.AllAsync(stop.ToStopables(v...)...)

	errCh := make(chan error, 1)
	valueCh := make(chan []Awaitable, 1)

	for _, awaitable := range awaitables {
		go func() {
			v, err := awaitable.Result()
			if err != nil {
				errCh <- errors.Wrap(err, 0)
				return
			}
			valueCh <- v
		}()
	}

	values := [][]Awaitable{}
	for {
		select {
		case err := <-errCh:
			return nil, errors.Wrap(err, 0)
		case value := <-valueCh:
			values = append(values, value)
			if len(values) == len(awaitables) {
				return values, nil
			}
		}
	}
}