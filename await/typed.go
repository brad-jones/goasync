// This file was automatically generated by genny.
// Any changes will be lost if this file is regenerated.
// see https://github.com/cheekybits/genny

package await

import (
	"sync"

	"github.com/brad-jones/goasync/stop"
	"github.com/brad-jones/goasync/task"
	"github.com/go-errors/errors"
)

// AllBools will wait for every given task to emit a result.
// The results (& errors) will be returned in a slice ordered the
// same as the input.
func AllBools(awaitables ...*task.BoolTask) ([]bool, error) {
	awaited := []bool{}
	awaitedErrors := []error{}

	for _, awaitable := range awaitables {
		v, e := awaitable.Result()
		awaited = append(awaited, v)
		awaitedErrors = append(awaitedErrors, e)
	}

	if len(awaitedErrors) > 0 {
		return nil, errors.New(&ErrTaskFailed{
			Errors: awaitedErrors,
		})
	}

	return awaited, nil
}

// AllBoolSlices will wait for every given task to emit a result.
// The results (& errors) will be returned in a slice ordered the
// same as the input.
func AllBoolSlices(awaitables ...*task.BoolSliceTask) ([][]bool, error) {
	awaited := [][]bool{}
	awaitedErrors := []error{}

	for _, awaitable := range awaitables {
		v, e := awaitable.Result()
		awaited = append(awaited, v)
		awaitedErrors = append(awaitedErrors, e)
	}

	if len(awaitedErrors) > 0 {
		return nil, errors.New(&ErrTaskFailed{
			Errors: awaitedErrors,
		})
	}

	return awaited, nil
}

// AnyBool will wait for the first task to emit a result (or an error)
// and return that, canceling all other tasks.
func AnyBool(awaitables ...*task.BoolTask) (value bool, err error) {
	v := make([]interface{}, len(awaitables))
	for i := range awaitables {
		v[i] = awaitables[i]
	}
	defer stop.All(stop.ToStopables(v...)...)

	type doneOnce struct {
		o  sync.Once
		ch chan struct{}
	}
	done := doneOnce{
		ch: make(chan struct{}, 1),
	}
	closeDone := func() {
		done.o.Do(func() {
			close(done.ch)
		})
	}

	for _, awaitable := range awaitables {
		go func() {
			defer closeDone()
			value, err = awaitable.Result()
		}()
	}

	<-done.ch
	return value, err
}

// FastAnyBool does the same as AnyBool but does not wait for all
// other tasks to stop. It does tell them to stop it just doesn't wait for
// them to stop.
func FastAnyBool(awaitables ...*task.BoolTask) (value bool, err error) {
	v := make([]interface{}, len(awaitables))
	for i := range awaitables {
		v[i] = awaitables[i]
	}
	defer stop.AllAsync(stop.ToStopables(v...)...)

	type doneOnce struct {
		o  sync.Once
		ch chan struct{}
	}
	done := doneOnce{
		ch: make(chan struct{}, 1),
	}
	closeDone := func() {
		done.o.Do(func() {
			close(done.ch)
		})
	}

	for _, awaitable := range awaitables {
		go func() {
			defer closeDone()
			value, err = awaitable.Result()
		}()
	}

	<-done.ch
	return value, err
}

// AnyBoolSlice will wait for the first task to emit a result (or an error)
// and return that, canceling all other tasks.
func AnyBoolSlice(awaitables ...*task.BoolSliceTask) (value []bool, err error) {
	v := make([]interface{}, len(awaitables))
	for i := range awaitables {
		v[i] = awaitables[i]
	}
	defer stop.All(stop.ToStopables(v...)...)

	type doneOnce struct {
		o  sync.Once
		ch chan struct{}
	}
	done := doneOnce{
		ch: make(chan struct{}, 1),
	}
	closeDone := func() {
		done.o.Do(func() {
			close(done.ch)
		})
	}

	for _, awaitable := range awaitables {
		go func() {
			defer closeDone()
			value, err = awaitable.Result()
		}()
	}

	<-done.ch
	return value, err
}

// FastAnyBoolSlice does the same as AnyBoolSlice but does not wait
// for all other tasks to stop. It does tell them to stop it just doesn't wait
// for them to stop.
func FastAnyBoolSlice(awaitables ...*task.BoolSliceTask) (value []bool, err error) {
	v := make([]interface{}, len(awaitables))
	for i := range awaitables {
		v[i] = awaitables[i]
	}
	defer stop.AllAsync(stop.ToStopables(v...)...)

	type doneOnce struct {
		o  sync.Once
		ch chan struct{}
	}
	done := doneOnce{
		ch: make(chan struct{}, 1),
	}
	closeDone := func() {
		done.o.Do(func() {
			close(done.ch)
		})
	}

	for _, awaitable := range awaitables {
		go func() {
			defer closeDone()
			value, err = awaitable.Result()
		}()
	}

	<-done.ch
	return value, err
}

// AllBoolsOrError will wait for every given task to emit a result or
// return as soon as an error is encountered, canceling all other tasks.
func AllBoolsOrError(awaitables ...*task.BoolTask) ([]bool, error) {
	v := make([]interface{}, len(awaitables))
	for i := range awaitables {
		v[i] = awaitables[i]
	}
	defer stop.All(stop.ToStopables(v...)...)

	errCh := make(chan error, 1)
	valueCh := make(chan bool, 1)

	for _, awaitable := range awaitables {
		go func() {
			v, err := awaitable.Result()
			if err != nil {
				errCh <- errors.Wrap(err, 0)
				return
			}
			valueCh <- v
		}()
	}

	values := []bool{}
	for {
		select {
		case err := <-errCh:
			return nil, errors.Wrap(err, 0)
		case value := <-valueCh:
			values = append(values, value)
			if len(values) == len(awaitables) {
				return values, nil
			}
		}
	}
}

// FastAllBoolsOrError does the same as AllBoolsOrError but does not
// wait for all other tasks to stop. It does tell them to stop it just doesn't
// wait for them to stop.
func FastAllBoolsOrError(awaitables ...*task.BoolTask) ([]bool, error) {
	v := make([]interface{}, len(awaitables))
	for i := range awaitables {
		v[i] = awaitables[i]
	}
	defer stop.AllAsync(stop.ToStopables(v...)...)

	errCh := make(chan error, 1)
	valueCh := make(chan bool, 1)

	for _, awaitable := range awaitables {
		go func() {
			v, err := awaitable.Result()
			if err != nil {
				errCh <- errors.Wrap(err, 0)
				return
			}
			valueCh <- v
		}()
	}

	values := []bool{}
	for {
		select {
		case err := <-errCh:
			return nil, errors.Wrap(err, 0)
		case value := <-valueCh:
			values = append(values, value)
			if len(values) == len(awaitables) {
				return values, nil
			}
		}
	}
}

// AllBoolSlicesOrError will wait for every given task to emit a result or
// return as soon as an error is encountered, canceling all other tasks.
func AllBoolSlicesOrError(awaitables ...*task.BoolSliceTask) ([][]bool, error) {
	v := make([]interface{}, len(awaitables))
	for i := range awaitables {
		v[i] = awaitables[i]
	}
	defer stop.All(stop.ToStopables(v...)...)

	errCh := make(chan error, 1)
	valueCh := make(chan []bool, 1)

	for _, awaitable := range awaitables {
		go func() {
			v, err := awaitable.Result()
			if err != nil {
				errCh <- errors.Wrap(err, 0)
				return
			}
			valueCh <- v
		}()
	}

	values := [][]bool{}
	for {
		select {
		case err := <-errCh:
			return nil, errors.Wrap(err, 0)
		case value := <-valueCh:
			values = append(values, value)
			if len(values) == len(awaitables) {
				return values, nil
			}
		}
	}
}

// FastAllBoolSlicesOrError does the same as AllBoolSlicesOrError but
// does not wait for all other tasks to stop. It does tell them to stop it just
// doesn't wait for them to stop.
func FastAllBoolSlicesOrError(awaitables ...*task.BoolSliceTask) ([][]bool, error) {
	v := make([]interface{}, len(awaitables))
	for i := range awaitables {
		v[i] = awaitables[i]
	}
	defer stop.AllAsync(stop.ToStopables(v...)...)

	errCh := make(chan error, 1)
	valueCh := make(chan []bool, 1)

	for _, awaitable := range awaitables {
		go func() {
			v, err := awaitable.Result()
			if err != nil {
				errCh <- errors.Wrap(err, 0)
				return
			}
			valueCh <- v
		}()
	}

	values := [][]bool{}
	for {
		select {
		case err := <-errCh:
			return nil, errors.Wrap(err, 0)
		case value := <-valueCh:
			values = append(values, value)
			if len(values) == len(awaitables) {
				return values, nil
			}
		}
	}
}

// AllBytes will wait for every given task to emit a result.
// The results (& errors) will be returned in a slice ordered the
// same as the input.
func AllBytes(awaitables ...*task.ByteTask) ([]byte, error) {
	awaited := []byte{}
	awaitedErrors := []error{}

	for _, awaitable := range awaitables {
		v, e := awaitable.Result()
		awaited = append(awaited, v)
		awaitedErrors = append(awaitedErrors, e)
	}

	if len(awaitedErrors) > 0 {
		return nil, errors.New(&ErrTaskFailed{
			Errors: awaitedErrors,
		})
	}

	return awaited, nil
}

// AllByteSlices will wait for every given task to emit a result.
// The results (& errors) will be returned in a slice ordered the
// same as the input.
func AllByteSlices(awaitables ...*task.ByteSliceTask) ([][]byte, error) {
	awaited := [][]byte{}
	awaitedErrors := []error{}

	for _, awaitable := range awaitables {
		v, e := awaitable.Result()
		awaited = append(awaited, v)
		awaitedErrors = append(awaitedErrors, e)
	}

	if len(awaitedErrors) > 0 {
		return nil, errors.New(&ErrTaskFailed{
			Errors: awaitedErrors,
		})
	}

	return awaited, nil
}

// AnyByte will wait for the first task to emit a result (or an error)
// and return that, canceling all other tasks.
func AnyByte(awaitables ...*task.ByteTask) (value byte, err error) {
	v := make([]interface{}, len(awaitables))
	for i := range awaitables {
		v[i] = awaitables[i]
	}
	defer stop.All(stop.ToStopables(v...)...)

	type doneOnce struct {
		o  sync.Once
		ch chan struct{}
	}
	done := doneOnce{
		ch: make(chan struct{}, 1),
	}
	closeDone := func() {
		done.o.Do(func() {
			close(done.ch)
		})
	}

	for _, awaitable := range awaitables {
		go func() {
			defer closeDone()
			value, err = awaitable.Result()
		}()
	}

	<-done.ch
	return value, err
}

// FastAnyByte does the same as AnyByte but does not wait for all
// other tasks to stop. It does tell them to stop it just doesn't wait for
// them to stop.
func FastAnyByte(awaitables ...*task.ByteTask) (value byte, err error) {
	v := make([]interface{}, len(awaitables))
	for i := range awaitables {
		v[i] = awaitables[i]
	}
	defer stop.AllAsync(stop.ToStopables(v...)...)

	type doneOnce struct {
		o  sync.Once
		ch chan struct{}
	}
	done := doneOnce{
		ch: make(chan struct{}, 1),
	}
	closeDone := func() {
		done.o.Do(func() {
			close(done.ch)
		})
	}

	for _, awaitable := range awaitables {
		go func() {
			defer closeDone()
			value, err = awaitable.Result()
		}()
	}

	<-done.ch
	return value, err
}

// AnyByteSlice will wait for the first task to emit a result (or an error)
// and return that, canceling all other tasks.
func AnyByteSlice(awaitables ...*task.ByteSliceTask) (value []byte, err error) {
	v := make([]interface{}, len(awaitables))
	for i := range awaitables {
		v[i] = awaitables[i]
	}
	defer stop.All(stop.ToStopables(v...)...)

	type doneOnce struct {
		o  sync.Once
		ch chan struct{}
	}
	done := doneOnce{
		ch: make(chan struct{}, 1),
	}
	closeDone := func() {
		done.o.Do(func() {
			close(done.ch)
		})
	}

	for _, awaitable := range awaitables {
		go func() {
			defer closeDone()
			value, err = awaitable.Result()
		}()
	}

	<-done.ch
	return value, err
}

// FastAnyByteSlice does the same as AnyByteSlice but does not wait
// for all other tasks to stop. It does tell them to stop it just doesn't wait
// for them to stop.
func FastAnyByteSlice(awaitables ...*task.ByteSliceTask) (value []byte, err error) {
	v := make([]interface{}, len(awaitables))
	for i := range awaitables {
		v[i] = awaitables[i]
	}
	defer stop.AllAsync(stop.ToStopables(v...)...)

	type doneOnce struct {
		o  sync.Once
		ch chan struct{}
	}
	done := doneOnce{
		ch: make(chan struct{}, 1),
	}
	closeDone := func() {
		done.o.Do(func() {
			close(done.ch)
		})
	}

	for _, awaitable := range awaitables {
		go func() {
			defer closeDone()
			value, err = awaitable.Result()
		}()
	}

	<-done.ch
	return value, err
}

// AllBytesOrError will wait for every given task to emit a result or
// return as soon as an error is encountered, canceling all other tasks.
func AllBytesOrError(awaitables ...*task.ByteTask) ([]byte, error) {
	v := make([]interface{}, len(awaitables))
	for i := range awaitables {
		v[i] = awaitables[i]
	}
	defer stop.All(stop.ToStopables(v...)...)

	errCh := make(chan error, 1)
	valueCh := make(chan byte, 1)

	for _, awaitable := range awaitables {
		go func() {
			v, err := awaitable.Result()
			if err != nil {
				errCh <- errors.Wrap(err, 0)
				return
			}
			valueCh <- v
		}()
	}

	values := []byte{}
	for {
		select {
		case err := <-errCh:
			return nil, errors.Wrap(err, 0)
		case value := <-valueCh:
			values = append(values, value)
			if len(values) == len(awaitables) {
				return values, nil
			}
		}
	}
}

// FastAllBytesOrError does the same as AllBytesOrError but does not
// wait for all other tasks to stop. It does tell them to stop it just doesn't
// wait for them to stop.
func FastAllBytesOrError(awaitables ...*task.ByteTask) ([]byte, error) {
	v := make([]interface{}, len(awaitables))
	for i := range awaitables {
		v[i] = awaitables[i]
	}
	defer stop.AllAsync(stop.ToStopables(v...)...)

	errCh := make(chan error, 1)
	valueCh := make(chan byte, 1)

	for _, awaitable := range awaitables {
		go func() {
			v, err := awaitable.Result()
			if err != nil {
				errCh <- errors.Wrap(err, 0)
				return
			}
			valueCh <- v
		}()
	}

	values := []byte{}
	for {
		select {
		case err := <-errCh:
			return nil, errors.Wrap(err, 0)
		case value := <-valueCh:
			values = append(values, value)
			if len(values) == len(awaitables) {
				return values, nil
			}
		}
	}
}

// AllByteSlicesOrError will wait for every given task to emit a result or
// return as soon as an error is encountered, canceling all other tasks.
func AllByteSlicesOrError(awaitables ...*task.ByteSliceTask) ([][]byte, error) {
	v := make([]interface{}, len(awaitables))
	for i := range awaitables {
		v[i] = awaitables[i]
	}
	defer stop.All(stop.ToStopables(v...)...)

	errCh := make(chan error, 1)
	valueCh := make(chan []byte, 1)

	for _, awaitable := range awaitables {
		go func() {
			v, err := awaitable.Result()
			if err != nil {
				errCh <- errors.Wrap(err, 0)
				return
			}
			valueCh <- v
		}()
	}

	values := [][]byte{}
	for {
		select {
		case err := <-errCh:
			return nil, errors.Wrap(err, 0)
		case value := <-valueCh:
			values = append(values, value)
			if len(values) == len(awaitables) {
				return values, nil
			}
		}
	}
}

// FastAllByteSlicesOrError does the same as AllByteSlicesOrError but
// does not wait for all other tasks to stop. It does tell them to stop it just
// doesn't wait for them to stop.
func FastAllByteSlicesOrError(awaitables ...*task.ByteSliceTask) ([][]byte, error) {
	v := make([]interface{}, len(awaitables))
	for i := range awaitables {
		v[i] = awaitables[i]
	}
	defer stop.AllAsync(stop.ToStopables(v...)...)

	errCh := make(chan error, 1)
	valueCh := make(chan []byte, 1)

	for _, awaitable := range awaitables {
		go func() {
			v, err := awaitable.Result()
			if err != nil {
				errCh <- errors.Wrap(err, 0)
				return
			}
			valueCh <- v
		}()
	}

	values := [][]byte{}
	for {
		select {
		case err := <-errCh:
			return nil, errors.Wrap(err, 0)
		case value := <-valueCh:
			values = append(values, value)
			if len(values) == len(awaitables) {
				return values, nil
			}
		}
	}
}

// AllComplex128s will wait for every given task to emit a result.
// The results (& errors) will be returned in a slice ordered the
// same as the input.
func AllComplex128s(awaitables ...*task.Complex128Task) ([]complex128, error) {
	awaited := []complex128{}
	awaitedErrors := []error{}

	for _, awaitable := range awaitables {
		v, e := awaitable.Result()
		awaited = append(awaited, v)
		awaitedErrors = append(awaitedErrors, e)
	}

	if len(awaitedErrors) > 0 {
		return nil, errors.New(&ErrTaskFailed{
			Errors: awaitedErrors,
		})
	}

	return awaited, nil
}

// AllComplex128Slices will wait for every given task to emit a result.
// The results (& errors) will be returned in a slice ordered the
// same as the input.
func AllComplex128Slices(awaitables ...*task.Complex128SliceTask) ([][]complex128, error) {
	awaited := [][]complex128{}
	awaitedErrors := []error{}

	for _, awaitable := range awaitables {
		v, e := awaitable.Result()
		awaited = append(awaited, v)
		awaitedErrors = append(awaitedErrors, e)
	}

	if len(awaitedErrors) > 0 {
		return nil, errors.New(&ErrTaskFailed{
			Errors: awaitedErrors,
		})
	}

	return awaited, nil
}

// AnyComplex128 will wait for the first task to emit a result (or an error)
// and return that, canceling all other tasks.
func AnyComplex128(awaitables ...*task.Complex128Task) (value complex128, err error) {
	v := make([]interface{}, len(awaitables))
	for i := range awaitables {
		v[i] = awaitables[i]
	}
	defer stop.All(stop.ToStopables(v...)...)

	type doneOnce struct {
		o  sync.Once
		ch chan struct{}
	}
	done := doneOnce{
		ch: make(chan struct{}, 1),
	}
	closeDone := func() {
		done.o.Do(func() {
			close(done.ch)
		})
	}

	for _, awaitable := range awaitables {
		go func() {
			defer closeDone()
			value, err = awaitable.Result()
		}()
	}

	<-done.ch
	return value, err
}

// FastAnyComplex128 does the same as AnyComplex128 but does not wait for all
// other tasks to stop. It does tell them to stop it just doesn't wait for
// them to stop.
func FastAnyComplex128(awaitables ...*task.Complex128Task) (value complex128, err error) {
	v := make([]interface{}, len(awaitables))
	for i := range awaitables {
		v[i] = awaitables[i]
	}
	defer stop.AllAsync(stop.ToStopables(v...)...)

	type doneOnce struct {
		o  sync.Once
		ch chan struct{}
	}
	done := doneOnce{
		ch: make(chan struct{}, 1),
	}
	closeDone := func() {
		done.o.Do(func() {
			close(done.ch)
		})
	}

	for _, awaitable := range awaitables {
		go func() {
			defer closeDone()
			value, err = awaitable.Result()
		}()
	}

	<-done.ch
	return value, err
}

// AnyComplex128Slice will wait for the first task to emit a result (or an error)
// and return that, canceling all other tasks.
func AnyComplex128Slice(awaitables ...*task.Complex128SliceTask) (value []complex128, err error) {
	v := make([]interface{}, len(awaitables))
	for i := range awaitables {
		v[i] = awaitables[i]
	}
	defer stop.All(stop.ToStopables(v...)...)

	type doneOnce struct {
		o  sync.Once
		ch chan struct{}
	}
	done := doneOnce{
		ch: make(chan struct{}, 1),
	}
	closeDone := func() {
		done.o.Do(func() {
			close(done.ch)
		})
	}

	for _, awaitable := range awaitables {
		go func() {
			defer closeDone()
			value, err = awaitable.Result()
		}()
	}

	<-done.ch
	return value, err
}

// FastAnyComplex128Slice does the same as AnyComplex128Slice but does not wait
// for all other tasks to stop. It does tell them to stop it just doesn't wait
// for them to stop.
func FastAnyComplex128Slice(awaitables ...*task.Complex128SliceTask) (value []complex128, err error) {
	v := make([]interface{}, len(awaitables))
	for i := range awaitables {
		v[i] = awaitables[i]
	}
	defer stop.AllAsync(stop.ToStopables(v...)...)

	type doneOnce struct {
		o  sync.Once
		ch chan struct{}
	}
	done := doneOnce{
		ch: make(chan struct{}, 1),
	}
	closeDone := func() {
		done.o.Do(func() {
			close(done.ch)
		})
	}

	for _, awaitable := range awaitables {
		go func() {
			defer closeDone()
			value, err = awaitable.Result()
		}()
	}

	<-done.ch
	return value, err
}

// AllComplex128sOrError will wait for every given task to emit a result or
// return as soon as an error is encountered, canceling all other tasks.
func AllComplex128sOrError(awaitables ...*task.Complex128Task) ([]complex128, error) {
	v := make([]interface{}, len(awaitables))
	for i := range awaitables {
		v[i] = awaitables[i]
	}
	defer stop.All(stop.ToStopables(v...)...)

	errCh := make(chan error, 1)
	valueCh := make(chan complex128, 1)

	for _, awaitable := range awaitables {
		go func() {
			v, err := awaitable.Result()
			if err != nil {
				errCh <- errors.Wrap(err, 0)
				return
			}
			valueCh <- v
		}()
	}

	values := []complex128{}
	for {
		select {
		case err := <-errCh:
			return nil, errors.Wrap(err, 0)
		case value := <-valueCh:
			values = append(values, value)
			if len(values) == len(awaitables) {
				return values, nil
			}
		}
	}
}

// FastAllComplex128sOrError does the same as AllComplex128sOrError but does not
// wait for all other tasks to stop. It does tell them to stop it just doesn't
// wait for them to stop.
func FastAllComplex128sOrError(awaitables ...*task.Complex128Task) ([]complex128, error) {
	v := make([]interface{}, len(awaitables))
	for i := range awaitables {
		v[i] = awaitables[i]
	}
	defer stop.AllAsync(stop.ToStopables(v...)...)

	errCh := make(chan error, 1)
	valueCh := make(chan complex128, 1)

	for _, awaitable := range awaitables {
		go func() {
			v, err := awaitable.Result()
			if err != nil {
				errCh <- errors.Wrap(err, 0)
				return
			}
			valueCh <- v
		}()
	}

	values := []complex128{}
	for {
		select {
		case err := <-errCh:
			return nil, errors.Wrap(err, 0)
		case value := <-valueCh:
			values = append(values, value)
			if len(values) == len(awaitables) {
				return values, nil
			}
		}
	}
}

// AllComplex128SlicesOrError will wait for every given task to emit a result or
// return as soon as an error is encountered, canceling all other tasks.
func AllComplex128SlicesOrError(awaitables ...*task.Complex128SliceTask) ([][]complex128, error) {
	v := make([]interface{}, len(awaitables))
	for i := range awaitables {
		v[i] = awaitables[i]
	}
	defer stop.All(stop.ToStopables(v...)...)

	errCh := make(chan error, 1)
	valueCh := make(chan []complex128, 1)

	for _, awaitable := range awaitables {
		go func() {
			v, err := awaitable.Result()
			if err != nil {
				errCh <- errors.Wrap(err, 0)
				return
			}
			valueCh <- v
		}()
	}

	values := [][]complex128{}
	for {
		select {
		case err := <-errCh:
			return nil, errors.Wrap(err, 0)
		case value := <-valueCh:
			values = append(values, value)
			if len(values) == len(awaitables) {
				return values, nil
			}
		}
	}
}

// FastAllComplex128SlicesOrError does the same as AllComplex128SlicesOrError but
// does not wait for all other tasks to stop. It does tell them to stop it just
// doesn't wait for them to stop.
func FastAllComplex128SlicesOrError(awaitables ...*task.Complex128SliceTask) ([][]complex128, error) {
	v := make([]interface{}, len(awaitables))
	for i := range awaitables {
		v[i] = awaitables[i]
	}
	defer stop.AllAsync(stop.ToStopables(v...)...)

	errCh := make(chan error, 1)
	valueCh := make(chan []complex128, 1)

	for _, awaitable := range awaitables {
		go func() {
			v, err := awaitable.Result()
			if err != nil {
				errCh <- errors.Wrap(err, 0)
				return
			}
			valueCh <- v
		}()
	}

	values := [][]complex128{}
	for {
		select {
		case err := <-errCh:
			return nil, errors.Wrap(err, 0)
		case value := <-valueCh:
			values = append(values, value)
			if len(values) == len(awaitables) {
				return values, nil
			}
		}
	}
}

// AllComplex64s will wait for every given task to emit a result.
// The results (& errors) will be returned in a slice ordered the
// same as the input.
func AllComplex64s(awaitables ...*task.Complex64Task) ([]complex64, error) {
	awaited := []complex64{}
	awaitedErrors := []error{}

	for _, awaitable := range awaitables {
		v, e := awaitable.Result()
		awaited = append(awaited, v)
		awaitedErrors = append(awaitedErrors, e)
	}

	if len(awaitedErrors) > 0 {
		return nil, errors.New(&ErrTaskFailed{
			Errors: awaitedErrors,
		})
	}

	return awaited, nil
}

// AllComplex64Slices will wait for every given task to emit a result.
// The results (& errors) will be returned in a slice ordered the
// same as the input.
func AllComplex64Slices(awaitables ...*task.Complex64SliceTask) ([][]complex64, error) {
	awaited := [][]complex64{}
	awaitedErrors := []error{}

	for _, awaitable := range awaitables {
		v, e := awaitable.Result()
		awaited = append(awaited, v)
		awaitedErrors = append(awaitedErrors, e)
	}

	if len(awaitedErrors) > 0 {
		return nil, errors.New(&ErrTaskFailed{
			Errors: awaitedErrors,
		})
	}

	return awaited, nil
}

// AnyComplex64 will wait for the first task to emit a result (or an error)
// and return that, canceling all other tasks.
func AnyComplex64(awaitables ...*task.Complex64Task) (value complex64, err error) {
	v := make([]interface{}, len(awaitables))
	for i := range awaitables {
		v[i] = awaitables[i]
	}
	defer stop.All(stop.ToStopables(v...)...)

	type doneOnce struct {
		o  sync.Once
		ch chan struct{}
	}
	done := doneOnce{
		ch: make(chan struct{}, 1),
	}
	closeDone := func() {
		done.o.Do(func() {
			close(done.ch)
		})
	}

	for _, awaitable := range awaitables {
		go func() {
			defer closeDone()
			value, err = awaitable.Result()
		}()
	}

	<-done.ch
	return value, err
}

// FastAnyComplex64 does the same as AnyComplex64 but does not wait for all
// other tasks to stop. It does tell them to stop it just doesn't wait for
// them to stop.
func FastAnyComplex64(awaitables ...*task.Complex64Task) (value complex64, err error) {
	v := make([]interface{}, len(awaitables))
	for i := range awaitables {
		v[i] = awaitables[i]
	}
	defer stop.AllAsync(stop.ToStopables(v...)...)

	type doneOnce struct {
		o  sync.Once
		ch chan struct{}
	}
	done := doneOnce{
		ch: make(chan struct{}, 1),
	}
	closeDone := func() {
		done.o.Do(func() {
			close(done.ch)
		})
	}

	for _, awaitable := range awaitables {
		go func() {
			defer closeDone()
			value, err = awaitable.Result()
		}()
	}

	<-done.ch
	return value, err
}

// AnyComplex64Slice will wait for the first task to emit a result (or an error)
// and return that, canceling all other tasks.
func AnyComplex64Slice(awaitables ...*task.Complex64SliceTask) (value []complex64, err error) {
	v := make([]interface{}, len(awaitables))
	for i := range awaitables {
		v[i] = awaitables[i]
	}
	defer stop.All(stop.ToStopables(v...)...)

	type doneOnce struct {
		o  sync.Once
		ch chan struct{}
	}
	done := doneOnce{
		ch: make(chan struct{}, 1),
	}
	closeDone := func() {
		done.o.Do(func() {
			close(done.ch)
		})
	}

	for _, awaitable := range awaitables {
		go func() {
			defer closeDone()
			value, err = awaitable.Result()
		}()
	}

	<-done.ch
	return value, err
}

// FastAnyComplex64Slice does the same as AnyComplex64Slice but does not wait
// for all other tasks to stop. It does tell them to stop it just doesn't wait
// for them to stop.
func FastAnyComplex64Slice(awaitables ...*task.Complex64SliceTask) (value []complex64, err error) {
	v := make([]interface{}, len(awaitables))
	for i := range awaitables {
		v[i] = awaitables[i]
	}
	defer stop.AllAsync(stop.ToStopables(v...)...)

	type doneOnce struct {
		o  sync.Once
		ch chan struct{}
	}
	done := doneOnce{
		ch: make(chan struct{}, 1),
	}
	closeDone := func() {
		done.o.Do(func() {
			close(done.ch)
		})
	}

	for _, awaitable := range awaitables {
		go func() {
			defer closeDone()
			value, err = awaitable.Result()
		}()
	}

	<-done.ch
	return value, err
}

// AllComplex64sOrError will wait for every given task to emit a result or
// return as soon as an error is encountered, canceling all other tasks.
func AllComplex64sOrError(awaitables ...*task.Complex64Task) ([]complex64, error) {
	v := make([]interface{}, len(awaitables))
	for i := range awaitables {
		v[i] = awaitables[i]
	}
	defer stop.All(stop.ToStopables(v...)...)

	errCh := make(chan error, 1)
	valueCh := make(chan complex64, 1)

	for _, awaitable := range awaitables {
		go func() {
			v, err := awaitable.Result()
			if err != nil {
				errCh <- errors.Wrap(err, 0)
				return
			}
			valueCh <- v
		}()
	}

	values := []complex64{}
	for {
		select {
		case err := <-errCh:
			return nil, errors.Wrap(err, 0)
		case value := <-valueCh:
			values = append(values, value)
			if len(values) == len(awaitables) {
				return values, nil
			}
		}
	}
}

// FastAllComplex64sOrError does the same as AllComplex64sOrError but does not
// wait for all other tasks to stop. It does tell them to stop it just doesn't
// wait for them to stop.
func FastAllComplex64sOrError(awaitables ...*task.Complex64Task) ([]complex64, error) {
	v := make([]interface{}, len(awaitables))
	for i := range awaitables {
		v[i] = awaitables[i]
	}
	defer stop.AllAsync(stop.ToStopables(v...)...)

	errCh := make(chan error, 1)
	valueCh := make(chan complex64, 1)

	for _, awaitable := range awaitables {
		go func() {
			v, err := awaitable.Result()
			if err != nil {
				errCh <- errors.Wrap(err, 0)
				return
			}
			valueCh <- v
		}()
	}

	values := []complex64{}
	for {
		select {
		case err := <-errCh:
			return nil, errors.Wrap(err, 0)
		case value := <-valueCh:
			values = append(values, value)
			if len(values) == len(awaitables) {
				return values, nil
			}
		}
	}
}

// AllComplex64SlicesOrError will wait for every given task to emit a result or
// return as soon as an error is encountered, canceling all other tasks.
func AllComplex64SlicesOrError(awaitables ...*task.Complex64SliceTask) ([][]complex64, error) {
	v := make([]interface{}, len(awaitables))
	for i := range awaitables {
		v[i] = awaitables[i]
	}
	defer stop.All(stop.ToStopables(v...)...)

	errCh := make(chan error, 1)
	valueCh := make(chan []complex64, 1)

	for _, awaitable := range awaitables {
		go func() {
			v, err := awaitable.Result()
			if err != nil {
				errCh <- errors.Wrap(err, 0)
				return
			}
			valueCh <- v
		}()
	}

	values := [][]complex64{}
	for {
		select {
		case err := <-errCh:
			return nil, errors.Wrap(err, 0)
		case value := <-valueCh:
			values = append(values, value)
			if len(values) == len(awaitables) {
				return values, nil
			}
		}
	}
}

// FastAllComplex64SlicesOrError does the same as AllComplex64SlicesOrError but
// does not wait for all other tasks to stop. It does tell them to stop it just
// doesn't wait for them to stop.
func FastAllComplex64SlicesOrError(awaitables ...*task.Complex64SliceTask) ([][]complex64, error) {
	v := make([]interface{}, len(awaitables))
	for i := range awaitables {
		v[i] = awaitables[i]
	}
	defer stop.AllAsync(stop.ToStopables(v...)...)

	errCh := make(chan error, 1)
	valueCh := make(chan []complex64, 1)

	for _, awaitable := range awaitables {
		go func() {
			v, err := awaitable.Result()
			if err != nil {
				errCh <- errors.Wrap(err, 0)
				return
			}
			valueCh <- v
		}()
	}

	values := [][]complex64{}
	for {
		select {
		case err := <-errCh:
			return nil, errors.Wrap(err, 0)
		case value := <-valueCh:
			values = append(values, value)
			if len(values) == len(awaitables) {
				return values, nil
			}
		}
	}
}

// AllErrors will wait for every given task to emit a result.
// The results (& errors) will be returned in a slice ordered the
// same as the input.
func AllErrors(awaitables ...*task.ErrorTask) ([]error, error) {
	awaited := []error{}
	awaitedErrors := []error{}

	for _, awaitable := range awaitables {
		v, e := awaitable.Result()
		awaited = append(awaited, v)
		awaitedErrors = append(awaitedErrors, e)
	}

	if len(awaitedErrors) > 0 {
		return nil, errors.New(&ErrTaskFailed{
			Errors: awaitedErrors,
		})
	}

	return awaited, nil
}

// AllErrorSlices will wait for every given task to emit a result.
// The results (& errors) will be returned in a slice ordered the
// same as the input.
func AllErrorSlices(awaitables ...*task.ErrorSliceTask) ([][]error, error) {
	awaited := [][]error{}
	awaitedErrors := []error{}

	for _, awaitable := range awaitables {
		v, e := awaitable.Result()
		awaited = append(awaited, v)
		awaitedErrors = append(awaitedErrors, e)
	}

	if len(awaitedErrors) > 0 {
		return nil, errors.New(&ErrTaskFailed{
			Errors: awaitedErrors,
		})
	}

	return awaited, nil
}

// AnyError will wait for the first task to emit a result (or an error)
// and return that, canceling all other tasks.
func AnyError(awaitables ...*task.ErrorTask) (value error, err error) {
	v := make([]interface{}, len(awaitables))
	for i := range awaitables {
		v[i] = awaitables[i]
	}
	defer stop.All(stop.ToStopables(v...)...)

	type doneOnce struct {
		o  sync.Once
		ch chan struct{}
	}
	done := doneOnce{
		ch: make(chan struct{}, 1),
	}
	closeDone := func() {
		done.o.Do(func() {
			close(done.ch)
		})
	}

	for _, awaitable := range awaitables {
		go func() {
			defer closeDone()
			value, err = awaitable.Result()
		}()
	}

	<-done.ch
	return value, err
}

// FastAnyError does the same as AnyError but does not wait for all
// other tasks to stop. It does tell them to stop it just doesn't wait for
// them to stop.
func FastAnyError(awaitables ...*task.ErrorTask) (value error, err error) {
	v := make([]interface{}, len(awaitables))
	for i := range awaitables {
		v[i] = awaitables[i]
	}
	defer stop.AllAsync(stop.ToStopables(v...)...)

	type doneOnce struct {
		o  sync.Once
		ch chan struct{}
	}
	done := doneOnce{
		ch: make(chan struct{}, 1),
	}
	closeDone := func() {
		done.o.Do(func() {
			close(done.ch)
		})
	}

	for _, awaitable := range awaitables {
		go func() {
			defer closeDone()
			value, err = awaitable.Result()
		}()
	}

	<-done.ch
	return value, err
}

// AnyErrorSlice will wait for the first task to emit a result (or an error)
// and return that, canceling all other tasks.
func AnyErrorSlice(awaitables ...*task.ErrorSliceTask) (value []error, err error) {
	v := make([]interface{}, len(awaitables))
	for i := range awaitables {
		v[i] = awaitables[i]
	}
	defer stop.All(stop.ToStopables(v...)...)

	type doneOnce struct {
		o  sync.Once
		ch chan struct{}
	}
	done := doneOnce{
		ch: make(chan struct{}, 1),
	}
	closeDone := func() {
		done.o.Do(func() {
			close(done.ch)
		})
	}

	for _, awaitable := range awaitables {
		go func() {
			defer closeDone()
			value, err = awaitable.Result()
		}()
	}

	<-done.ch
	return value, err
}

// FastAnyErrorSlice does the same as AnyErrorSlice but does not wait
// for all other tasks to stop. It does tell them to stop it just doesn't wait
// for them to stop.
func FastAnyErrorSlice(awaitables ...*task.ErrorSliceTask) (value []error, err error) {
	v := make([]interface{}, len(awaitables))
	for i := range awaitables {
		v[i] = awaitables[i]
	}
	defer stop.AllAsync(stop.ToStopables(v...)...)

	type doneOnce struct {
		o  sync.Once
		ch chan struct{}
	}
	done := doneOnce{
		ch: make(chan struct{}, 1),
	}
	closeDone := func() {
		done.o.Do(func() {
			close(done.ch)
		})
	}

	for _, awaitable := range awaitables {
		go func() {
			defer closeDone()
			value, err = awaitable.Result()
		}()
	}

	<-done.ch
	return value, err
}

// AllErrorsOrError will wait for every given task to emit a result or
// return as soon as an error is encountered, canceling all other tasks.
func AllErrorsOrError(awaitables ...*task.ErrorTask) ([]error, error) {
	v := make([]interface{}, len(awaitables))
	for i := range awaitables {
		v[i] = awaitables[i]
	}
	defer stop.All(stop.ToStopables(v...)...)

	errCh := make(chan error, 1)
	valueCh := make(chan error, 1)

	for _, awaitable := range awaitables {
		go func() {
			v, err := awaitable.Result()
			if err != nil {
				errCh <- errors.Wrap(err, 0)
				return
			}
			valueCh <- v
		}()
	}

	values := []error{}
	for {
		select {
		case err := <-errCh:
			return nil, errors.Wrap(err, 0)
		case value := <-valueCh:
			values = append(values, value)
			if len(values) == len(awaitables) {
				return values, nil
			}
		}
	}
}

// FastAllErrorsOrError does the same as AllErrorsOrError but does not
// wait for all other tasks to stop. It does tell them to stop it just doesn't
// wait for them to stop.
func FastAllErrorsOrError(awaitables ...*task.ErrorTask) ([]error, error) {
	v := make([]interface{}, len(awaitables))
	for i := range awaitables {
		v[i] = awaitables[i]
	}
	defer stop.AllAsync(stop.ToStopables(v...)...)

	errCh := make(chan error, 1)
	valueCh := make(chan error, 1)

	for _, awaitable := range awaitables {
		go func() {
			v, err := awaitable.Result()
			if err != nil {
				errCh <- errors.Wrap(err, 0)
				return
			}
			valueCh <- v
		}()
	}

	values := []error{}
	for {
		select {
		case err := <-errCh:
			return nil, errors.Wrap(err, 0)
		case value := <-valueCh:
			values = append(values, value)
			if len(values) == len(awaitables) {
				return values, nil
			}
		}
	}
}

// AllErrorSlicesOrError will wait for every given task to emit a result or
// return as soon as an error is encountered, canceling all other tasks.
func AllErrorSlicesOrError(awaitables ...*task.ErrorSliceTask) ([][]error, error) {
	v := make([]interface{}, len(awaitables))
	for i := range awaitables {
		v[i] = awaitables[i]
	}
	defer stop.All(stop.ToStopables(v...)...)

	errCh := make(chan error, 1)
	valueCh := make(chan []error, 1)

	for _, awaitable := range awaitables {
		go func() {
			v, err := awaitable.Result()
			if err != nil {
				errCh <- errors.Wrap(err, 0)
				return
			}
			valueCh <- v
		}()
	}

	values := [][]error{}
	for {
		select {
		case err := <-errCh:
			return nil, errors.Wrap(err, 0)
		case value := <-valueCh:
			values = append(values, value)
			if len(values) == len(awaitables) {
				return values, nil
			}
		}
	}
}

// FastAllErrorSlicesOrError does the same as AllErrorSlicesOrError but
// does not wait for all other tasks to stop. It does tell them to stop it just
// doesn't wait for them to stop.
func FastAllErrorSlicesOrError(awaitables ...*task.ErrorSliceTask) ([][]error, error) {
	v := make([]interface{}, len(awaitables))
	for i := range awaitables {
		v[i] = awaitables[i]
	}
	defer stop.AllAsync(stop.ToStopables(v...)...)

	errCh := make(chan error, 1)
	valueCh := make(chan []error, 1)

	for _, awaitable := range awaitables {
		go func() {
			v, err := awaitable.Result()
			if err != nil {
				errCh <- errors.Wrap(err, 0)
				return
			}
			valueCh <- v
		}()
	}

	values := [][]error{}
	for {
		select {
		case err := <-errCh:
			return nil, errors.Wrap(err, 0)
		case value := <-valueCh:
			values = append(values, value)
			if len(values) == len(awaitables) {
				return values, nil
			}
		}
	}
}

// AllFloat32s will wait for every given task to emit a result.
// The results (& errors) will be returned in a slice ordered the
// same as the input.
func AllFloat32s(awaitables ...*task.Float32Task) ([]float32, error) {
	awaited := []float32{}
	awaitedErrors := []error{}

	for _, awaitable := range awaitables {
		v, e := awaitable.Result()
		awaited = append(awaited, v)
		awaitedErrors = append(awaitedErrors, e)
	}

	if len(awaitedErrors) > 0 {
		return nil, errors.New(&ErrTaskFailed{
			Errors: awaitedErrors,
		})
	}

	return awaited, nil
}

// AllFloat32Slices will wait for every given task to emit a result.
// The results (& errors) will be returned in a slice ordered the
// same as the input.
func AllFloat32Slices(awaitables ...*task.Float32SliceTask) ([][]float32, error) {
	awaited := [][]float32{}
	awaitedErrors := []error{}

	for _, awaitable := range awaitables {
		v, e := awaitable.Result()
		awaited = append(awaited, v)
		awaitedErrors = append(awaitedErrors, e)
	}

	if len(awaitedErrors) > 0 {
		return nil, errors.New(&ErrTaskFailed{
			Errors: awaitedErrors,
		})
	}

	return awaited, nil
}

// AnyFloat32 will wait for the first task to emit a result (or an error)
// and return that, canceling all other tasks.
func AnyFloat32(awaitables ...*task.Float32Task) (value float32, err error) {
	v := make([]interface{}, len(awaitables))
	for i := range awaitables {
		v[i] = awaitables[i]
	}
	defer stop.All(stop.ToStopables(v...)...)

	type doneOnce struct {
		o  sync.Once
		ch chan struct{}
	}
	done := doneOnce{
		ch: make(chan struct{}, 1),
	}
	closeDone := func() {
		done.o.Do(func() {
			close(done.ch)
		})
	}

	for _, awaitable := range awaitables {
		go func() {
			defer closeDone()
			value, err = awaitable.Result()
		}()
	}

	<-done.ch
	return value, err
}

// FastAnyFloat32 does the same as AnyFloat32 but does not wait for all
// other tasks to stop. It does tell them to stop it just doesn't wait for
// them to stop.
func FastAnyFloat32(awaitables ...*task.Float32Task) (value float32, err error) {
	v := make([]interface{}, len(awaitables))
	for i := range awaitables {
		v[i] = awaitables[i]
	}
	defer stop.AllAsync(stop.ToStopables(v...)...)

	type doneOnce struct {
		o  sync.Once
		ch chan struct{}
	}
	done := doneOnce{
		ch: make(chan struct{}, 1),
	}
	closeDone := func() {
		done.o.Do(func() {
			close(done.ch)
		})
	}

	for _, awaitable := range awaitables {
		go func() {
			defer closeDone()
			value, err = awaitable.Result()
		}()
	}

	<-done.ch
	return value, err
}

// AnyFloat32Slice will wait for the first task to emit a result (or an error)
// and return that, canceling all other tasks.
func AnyFloat32Slice(awaitables ...*task.Float32SliceTask) (value []float32, err error) {
	v := make([]interface{}, len(awaitables))
	for i := range awaitables {
		v[i] = awaitables[i]
	}
	defer stop.All(stop.ToStopables(v...)...)

	type doneOnce struct {
		o  sync.Once
		ch chan struct{}
	}
	done := doneOnce{
		ch: make(chan struct{}, 1),
	}
	closeDone := func() {
		done.o.Do(func() {
			close(done.ch)
		})
	}

	for _, awaitable := range awaitables {
		go func() {
			defer closeDone()
			value, err = awaitable.Result()
		}()
	}

	<-done.ch
	return value, err
}

// FastAnyFloat32Slice does the same as AnyFloat32Slice but does not wait
// for all other tasks to stop. It does tell them to stop it just doesn't wait
// for them to stop.
func FastAnyFloat32Slice(awaitables ...*task.Float32SliceTask) (value []float32, err error) {
	v := make([]interface{}, len(awaitables))
	for i := range awaitables {
		v[i] = awaitables[i]
	}
	defer stop.AllAsync(stop.ToStopables(v...)...)

	type doneOnce struct {
		o  sync.Once
		ch chan struct{}
	}
	done := doneOnce{
		ch: make(chan struct{}, 1),
	}
	closeDone := func() {
		done.o.Do(func() {
			close(done.ch)
		})
	}

	for _, awaitable := range awaitables {
		go func() {
			defer closeDone()
			value, err = awaitable.Result()
		}()
	}

	<-done.ch
	return value, err
}

// AllFloat32sOrError will wait for every given task to emit a result or
// return as soon as an error is encountered, canceling all other tasks.
func AllFloat32sOrError(awaitables ...*task.Float32Task) ([]float32, error) {
	v := make([]interface{}, len(awaitables))
	for i := range awaitables {
		v[i] = awaitables[i]
	}
	defer stop.All(stop.ToStopables(v...)...)

	errCh := make(chan error, 1)
	valueCh := make(chan float32, 1)

	for _, awaitable := range awaitables {
		go func() {
			v, err := awaitable.Result()
			if err != nil {
				errCh <- errors.Wrap(err, 0)
				return
			}
			valueCh <- v
		}()
	}

	values := []float32{}
	for {
		select {
		case err := <-errCh:
			return nil, errors.Wrap(err, 0)
		case value := <-valueCh:
			values = append(values, value)
			if len(values) == len(awaitables) {
				return values, nil
			}
		}
	}
}

// FastAllFloat32sOrError does the same as AllFloat32sOrError but does not
// wait for all other tasks to stop. It does tell them to stop it just doesn't
// wait for them to stop.
func FastAllFloat32sOrError(awaitables ...*task.Float32Task) ([]float32, error) {
	v := make([]interface{}, len(awaitables))
	for i := range awaitables {
		v[i] = awaitables[i]
	}
	defer stop.AllAsync(stop.ToStopables(v...)...)

	errCh := make(chan error, 1)
	valueCh := make(chan float32, 1)

	for _, awaitable := range awaitables {
		go func() {
			v, err := awaitable.Result()
			if err != nil {
				errCh <- errors.Wrap(err, 0)
				return
			}
			valueCh <- v
		}()
	}

	values := []float32{}
	for {
		select {
		case err := <-errCh:
			return nil, errors.Wrap(err, 0)
		case value := <-valueCh:
			values = append(values, value)
			if len(values) == len(awaitables) {
				return values, nil
			}
		}
	}
}

// AllFloat32SlicesOrError will wait for every given task to emit a result or
// return as soon as an error is encountered, canceling all other tasks.
func AllFloat32SlicesOrError(awaitables ...*task.Float32SliceTask) ([][]float32, error) {
	v := make([]interface{}, len(awaitables))
	for i := range awaitables {
		v[i] = awaitables[i]
	}
	defer stop.All(stop.ToStopables(v...)...)

	errCh := make(chan error, 1)
	valueCh := make(chan []float32, 1)

	for _, awaitable := range awaitables {
		go func() {
			v, err := awaitable.Result()
			if err != nil {
				errCh <- errors.Wrap(err, 0)
				return
			}
			valueCh <- v
		}()
	}

	values := [][]float32{}
	for {
		select {
		case err := <-errCh:
			return nil, errors.Wrap(err, 0)
		case value := <-valueCh:
			values = append(values, value)
			if len(values) == len(awaitables) {
				return values, nil
			}
		}
	}
}

// FastAllFloat32SlicesOrError does the same as AllFloat32SlicesOrError but
// does not wait for all other tasks to stop. It does tell them to stop it just
// doesn't wait for them to stop.
func FastAllFloat32SlicesOrError(awaitables ...*task.Float32SliceTask) ([][]float32, error) {
	v := make([]interface{}, len(awaitables))
	for i := range awaitables {
		v[i] = awaitables[i]
	}
	defer stop.AllAsync(stop.ToStopables(v...)...)

	errCh := make(chan error, 1)
	valueCh := make(chan []float32, 1)

	for _, awaitable := range awaitables {
		go func() {
			v, err := awaitable.Result()
			if err != nil {
				errCh <- errors.Wrap(err, 0)
				return
			}
			valueCh <- v
		}()
	}

	values := [][]float32{}
	for {
		select {
		case err := <-errCh:
			return nil, errors.Wrap(err, 0)
		case value := <-valueCh:
			values = append(values, value)
			if len(values) == len(awaitables) {
				return values, nil
			}
		}
	}
}

// AllFloat64s will wait for every given task to emit a result.
// The results (& errors) will be returned in a slice ordered the
// same as the input.
func AllFloat64s(awaitables ...*task.Float64Task) ([]float64, error) {
	awaited := []float64{}
	awaitedErrors := []error{}

	for _, awaitable := range awaitables {
		v, e := awaitable.Result()
		awaited = append(awaited, v)
		awaitedErrors = append(awaitedErrors, e)
	}

	if len(awaitedErrors) > 0 {
		return nil, errors.New(&ErrTaskFailed{
			Errors: awaitedErrors,
		})
	}

	return awaited, nil
}

// AllFloat64Slices will wait for every given task to emit a result.
// The results (& errors) will be returned in a slice ordered the
// same as the input.
func AllFloat64Slices(awaitables ...*task.Float64SliceTask) ([][]float64, error) {
	awaited := [][]float64{}
	awaitedErrors := []error{}

	for _, awaitable := range awaitables {
		v, e := awaitable.Result()
		awaited = append(awaited, v)
		awaitedErrors = append(awaitedErrors, e)
	}

	if len(awaitedErrors) > 0 {
		return nil, errors.New(&ErrTaskFailed{
			Errors: awaitedErrors,
		})
	}

	return awaited, nil
}

// AnyFloat64 will wait for the first task to emit a result (or an error)
// and return that, canceling all other tasks.
func AnyFloat64(awaitables ...*task.Float64Task) (value float64, err error) {
	v := make([]interface{}, len(awaitables))
	for i := range awaitables {
		v[i] = awaitables[i]
	}
	defer stop.All(stop.ToStopables(v...)...)

	type doneOnce struct {
		o  sync.Once
		ch chan struct{}
	}
	done := doneOnce{
		ch: make(chan struct{}, 1),
	}
	closeDone := func() {
		done.o.Do(func() {
			close(done.ch)
		})
	}

	for _, awaitable := range awaitables {
		go func() {
			defer closeDone()
			value, err = awaitable.Result()
		}()
	}

	<-done.ch
	return value, err
}

// FastAnyFloat64 does the same as AnyFloat64 but does not wait for all
// other tasks to stop. It does tell them to stop it just doesn't wait for
// them to stop.
func FastAnyFloat64(awaitables ...*task.Float64Task) (value float64, err error) {
	v := make([]interface{}, len(awaitables))
	for i := range awaitables {
		v[i] = awaitables[i]
	}
	defer stop.AllAsync(stop.ToStopables(v...)...)

	type doneOnce struct {
		o  sync.Once
		ch chan struct{}
	}
	done := doneOnce{
		ch: make(chan struct{}, 1),
	}
	closeDone := func() {
		done.o.Do(func() {
			close(done.ch)
		})
	}

	for _, awaitable := range awaitables {
		go func() {
			defer closeDone()
			value, err = awaitable.Result()
		}()
	}

	<-done.ch
	return value, err
}

// AnyFloat64Slice will wait for the first task to emit a result (or an error)
// and return that, canceling all other tasks.
func AnyFloat64Slice(awaitables ...*task.Float64SliceTask) (value []float64, err error) {
	v := make([]interface{}, len(awaitables))
	for i := range awaitables {
		v[i] = awaitables[i]
	}
	defer stop.All(stop.ToStopables(v...)...)

	type doneOnce struct {
		o  sync.Once
		ch chan struct{}
	}
	done := doneOnce{
		ch: make(chan struct{}, 1),
	}
	closeDone := func() {
		done.o.Do(func() {
			close(done.ch)
		})
	}

	for _, awaitable := range awaitables {
		go func() {
			defer closeDone()
			value, err = awaitable.Result()
		}()
	}

	<-done.ch
	return value, err
}

// FastAnyFloat64Slice does the same as AnyFloat64Slice but does not wait
// for all other tasks to stop. It does tell them to stop it just doesn't wait
// for them to stop.
func FastAnyFloat64Slice(awaitables ...*task.Float64SliceTask) (value []float64, err error) {
	v := make([]interface{}, len(awaitables))
	for i := range awaitables {
		v[i] = awaitables[i]
	}
	defer stop.AllAsync(stop.ToStopables(v...)...)

	type doneOnce struct {
		o  sync.Once
		ch chan struct{}
	}
	done := doneOnce{
		ch: make(chan struct{}, 1),
	}
	closeDone := func() {
		done.o.Do(func() {
			close(done.ch)
		})
	}

	for _, awaitable := range awaitables {
		go func() {
			defer closeDone()
			value, err = awaitable.Result()
		}()
	}

	<-done.ch
	return value, err
}

// AllFloat64sOrError will wait for every given task to emit a result or
// return as soon as an error is encountered, canceling all other tasks.
func AllFloat64sOrError(awaitables ...*task.Float64Task) ([]float64, error) {
	v := make([]interface{}, len(awaitables))
	for i := range awaitables {
		v[i] = awaitables[i]
	}
	defer stop.All(stop.ToStopables(v...)...)

	errCh := make(chan error, 1)
	valueCh := make(chan float64, 1)

	for _, awaitable := range awaitables {
		go func() {
			v, err := awaitable.Result()
			if err != nil {
				errCh <- errors.Wrap(err, 0)
				return
			}
			valueCh <- v
		}()
	}

	values := []float64{}
	for {
		select {
		case err := <-errCh:
			return nil, errors.Wrap(err, 0)
		case value := <-valueCh:
			values = append(values, value)
			if len(values) == len(awaitables) {
				return values, nil
			}
		}
	}
}

// FastAllFloat64sOrError does the same as AllFloat64sOrError but does not
// wait for all other tasks to stop. It does tell them to stop it just doesn't
// wait for them to stop.
func FastAllFloat64sOrError(awaitables ...*task.Float64Task) ([]float64, error) {
	v := make([]interface{}, len(awaitables))
	for i := range awaitables {
		v[i] = awaitables[i]
	}
	defer stop.AllAsync(stop.ToStopables(v...)...)

	errCh := make(chan error, 1)
	valueCh := make(chan float64, 1)

	for _, awaitable := range awaitables {
		go func() {
			v, err := awaitable.Result()
			if err != nil {
				errCh <- errors.Wrap(err, 0)
				return
			}
			valueCh <- v
		}()
	}

	values := []float64{}
	for {
		select {
		case err := <-errCh:
			return nil, errors.Wrap(err, 0)
		case value := <-valueCh:
			values = append(values, value)
			if len(values) == len(awaitables) {
				return values, nil
			}
		}
	}
}

// AllFloat64SlicesOrError will wait for every given task to emit a result or
// return as soon as an error is encountered, canceling all other tasks.
func AllFloat64SlicesOrError(awaitables ...*task.Float64SliceTask) ([][]float64, error) {
	v := make([]interface{}, len(awaitables))
	for i := range awaitables {
		v[i] = awaitables[i]
	}
	defer stop.All(stop.ToStopables(v...)...)

	errCh := make(chan error, 1)
	valueCh := make(chan []float64, 1)

	for _, awaitable := range awaitables {
		go func() {
			v, err := awaitable.Result()
			if err != nil {
				errCh <- errors.Wrap(err, 0)
				return
			}
			valueCh <- v
		}()
	}

	values := [][]float64{}
	for {
		select {
		case err := <-errCh:
			return nil, errors.Wrap(err, 0)
		case value := <-valueCh:
			values = append(values, value)
			if len(values) == len(awaitables) {
				return values, nil
			}
		}
	}
}

// FastAllFloat64SlicesOrError does the same as AllFloat64SlicesOrError but
// does not wait for all other tasks to stop. It does tell them to stop it just
// doesn't wait for them to stop.
func FastAllFloat64SlicesOrError(awaitables ...*task.Float64SliceTask) ([][]float64, error) {
	v := make([]interface{}, len(awaitables))
	for i := range awaitables {
		v[i] = awaitables[i]
	}
	defer stop.AllAsync(stop.ToStopables(v...)...)

	errCh := make(chan error, 1)
	valueCh := make(chan []float64, 1)

	for _, awaitable := range awaitables {
		go func() {
			v, err := awaitable.Result()
			if err != nil {
				errCh <- errors.Wrap(err, 0)
				return
			}
			valueCh <- v
		}()
	}

	values := [][]float64{}
	for {
		select {
		case err := <-errCh:
			return nil, errors.Wrap(err, 0)
		case value := <-valueCh:
			values = append(values, value)
			if len(values) == len(awaitables) {
				return values, nil
			}
		}
	}
}

// AllInts will wait for every given task to emit a result.
// The results (& errors) will be returned in a slice ordered the
// same as the input.
func AllInts(awaitables ...*task.IntTask) ([]int, error) {
	awaited := []int{}
	awaitedErrors := []error{}

	for _, awaitable := range awaitables {
		v, e := awaitable.Result()
		awaited = append(awaited, v)
		awaitedErrors = append(awaitedErrors, e)
	}

	if len(awaitedErrors) > 0 {
		return nil, errors.New(&ErrTaskFailed{
			Errors: awaitedErrors,
		})
	}

	return awaited, nil
}

// AllIntSlices will wait for every given task to emit a result.
// The results (& errors) will be returned in a slice ordered the
// same as the input.
func AllIntSlices(awaitables ...*task.IntSliceTask) ([][]int, error) {
	awaited := [][]int{}
	awaitedErrors := []error{}

	for _, awaitable := range awaitables {
		v, e := awaitable.Result()
		awaited = append(awaited, v)
		awaitedErrors = append(awaitedErrors, e)
	}

	if len(awaitedErrors) > 0 {
		return nil, errors.New(&ErrTaskFailed{
			Errors: awaitedErrors,
		})
	}

	return awaited, nil
}

// AnyInt will wait for the first task to emit a result (or an error)
// and return that, canceling all other tasks.
func AnyInt(awaitables ...*task.IntTask) (value int, err error) {
	v := make([]interface{}, len(awaitables))
	for i := range awaitables {
		v[i] = awaitables[i]
	}
	defer stop.All(stop.ToStopables(v...)...)

	type doneOnce struct {
		o  sync.Once
		ch chan struct{}
	}
	done := doneOnce{
		ch: make(chan struct{}, 1),
	}
	closeDone := func() {
		done.o.Do(func() {
			close(done.ch)
		})
	}

	for _, awaitable := range awaitables {
		go func() {
			defer closeDone()
			value, err = awaitable.Result()
		}()
	}

	<-done.ch
	return value, err
}

// FastAnyInt does the same as AnyInt but does not wait for all
// other tasks to stop. It does tell them to stop it just doesn't wait for
// them to stop.
func FastAnyInt(awaitables ...*task.IntTask) (value int, err error) {
	v := make([]interface{}, len(awaitables))
	for i := range awaitables {
		v[i] = awaitables[i]
	}
	defer stop.AllAsync(stop.ToStopables(v...)...)

	type doneOnce struct {
		o  sync.Once
		ch chan struct{}
	}
	done := doneOnce{
		ch: make(chan struct{}, 1),
	}
	closeDone := func() {
		done.o.Do(func() {
			close(done.ch)
		})
	}

	for _, awaitable := range awaitables {
		go func() {
			defer closeDone()
			value, err = awaitable.Result()
		}()
	}

	<-done.ch
	return value, err
}

// AnyIntSlice will wait for the first task to emit a result (or an error)
// and return that, canceling all other tasks.
func AnyIntSlice(awaitables ...*task.IntSliceTask) (value []int, err error) {
	v := make([]interface{}, len(awaitables))
	for i := range awaitables {
		v[i] = awaitables[i]
	}
	defer stop.All(stop.ToStopables(v...)...)

	type doneOnce struct {
		o  sync.Once
		ch chan struct{}
	}
	done := doneOnce{
		ch: make(chan struct{}, 1),
	}
	closeDone := func() {
		done.o.Do(func() {
			close(done.ch)
		})
	}

	for _, awaitable := range awaitables {
		go func() {
			defer closeDone()
			value, err = awaitable.Result()
		}()
	}

	<-done.ch
	return value, err
}

// FastAnyIntSlice does the same as AnyIntSlice but does not wait
// for all other tasks to stop. It does tell them to stop it just doesn't wait
// for them to stop.
func FastAnyIntSlice(awaitables ...*task.IntSliceTask) (value []int, err error) {
	v := make([]interface{}, len(awaitables))
	for i := range awaitables {
		v[i] = awaitables[i]
	}
	defer stop.AllAsync(stop.ToStopables(v...)...)

	type doneOnce struct {
		o  sync.Once
		ch chan struct{}
	}
	done := doneOnce{
		ch: make(chan struct{}, 1),
	}
	closeDone := func() {
		done.o.Do(func() {
			close(done.ch)
		})
	}

	for _, awaitable := range awaitables {
		go func() {
			defer closeDone()
			value, err = awaitable.Result()
		}()
	}

	<-done.ch
	return value, err
}

// AllIntsOrError will wait for every given task to emit a result or
// return as soon as an error is encountered, canceling all other tasks.
func AllIntsOrError(awaitables ...*task.IntTask) ([]int, error) {
	v := make([]interface{}, len(awaitables))
	for i := range awaitables {
		v[i] = awaitables[i]
	}
	defer stop.All(stop.ToStopables(v...)...)

	errCh := make(chan error, 1)
	valueCh := make(chan int, 1)

	for _, awaitable := range awaitables {
		go func() {
			v, err := awaitable.Result()
			if err != nil {
				errCh <- errors.Wrap(err, 0)
				return
			}
			valueCh <- v
		}()
	}

	values := []int{}
	for {
		select {
		case err := <-errCh:
			return nil, errors.Wrap(err, 0)
		case value := <-valueCh:
			values = append(values, value)
			if len(values) == len(awaitables) {
				return values, nil
			}
		}
	}
}

// FastAllIntsOrError does the same as AllIntsOrError but does not
// wait for all other tasks to stop. It does tell them to stop it just doesn't
// wait for them to stop.
func FastAllIntsOrError(awaitables ...*task.IntTask) ([]int, error) {
	v := make([]interface{}, len(awaitables))
	for i := range awaitables {
		v[i] = awaitables[i]
	}
	defer stop.AllAsync(stop.ToStopables(v...)...)

	errCh := make(chan error, 1)
	valueCh := make(chan int, 1)

	for _, awaitable := range awaitables {
		go func() {
			v, err := awaitable.Result()
			if err != nil {
				errCh <- errors.Wrap(err, 0)
				return
			}
			valueCh <- v
		}()
	}

	values := []int{}
	for {
		select {
		case err := <-errCh:
			return nil, errors.Wrap(err, 0)
		case value := <-valueCh:
			values = append(values, value)
			if len(values) == len(awaitables) {
				return values, nil
			}
		}
	}
}

// AllIntSlicesOrError will wait for every given task to emit a result or
// return as soon as an error is encountered, canceling all other tasks.
func AllIntSlicesOrError(awaitables ...*task.IntSliceTask) ([][]int, error) {
	v := make([]interface{}, len(awaitables))
	for i := range awaitables {
		v[i] = awaitables[i]
	}
	defer stop.All(stop.ToStopables(v...)...)

	errCh := make(chan error, 1)
	valueCh := make(chan []int, 1)

	for _, awaitable := range awaitables {
		go func() {
			v, err := awaitable.Result()
			if err != nil {
				errCh <- errors.Wrap(err, 0)
				return
			}
			valueCh <- v
		}()
	}

	values := [][]int{}
	for {
		select {
		case err := <-errCh:
			return nil, errors.Wrap(err, 0)
		case value := <-valueCh:
			values = append(values, value)
			if len(values) == len(awaitables) {
				return values, nil
			}
		}
	}
}

// FastAllIntSlicesOrError does the same as AllIntSlicesOrError but
// does not wait for all other tasks to stop. It does tell them to stop it just
// doesn't wait for them to stop.
func FastAllIntSlicesOrError(awaitables ...*task.IntSliceTask) ([][]int, error) {
	v := make([]interface{}, len(awaitables))
	for i := range awaitables {
		v[i] = awaitables[i]
	}
	defer stop.AllAsync(stop.ToStopables(v...)...)

	errCh := make(chan error, 1)
	valueCh := make(chan []int, 1)

	for _, awaitable := range awaitables {
		go func() {
			v, err := awaitable.Result()
			if err != nil {
				errCh <- errors.Wrap(err, 0)
				return
			}
			valueCh <- v
		}()
	}

	values := [][]int{}
	for {
		select {
		case err := <-errCh:
			return nil, errors.Wrap(err, 0)
		case value := <-valueCh:
			values = append(values, value)
			if len(values) == len(awaitables) {
				return values, nil
			}
		}
	}
}

// AllInt16s will wait for every given task to emit a result.
// The results (& errors) will be returned in a slice ordered the
// same as the input.
func AllInt16s(awaitables ...*task.Int16Task) ([]int16, error) {
	awaited := []int16{}
	awaitedErrors := []error{}

	for _, awaitable := range awaitables {
		v, e := awaitable.Result()
		awaited = append(awaited, v)
		awaitedErrors = append(awaitedErrors, e)
	}

	if len(awaitedErrors) > 0 {
		return nil, errors.New(&ErrTaskFailed{
			Errors: awaitedErrors,
		})
	}

	return awaited, nil
}

// AllInt16Slices will wait for every given task to emit a result.
// The results (& errors) will be returned in a slice ordered the
// same as the input.
func AllInt16Slices(awaitables ...*task.Int16SliceTask) ([][]int16, error) {
	awaited := [][]int16{}
	awaitedErrors := []error{}

	for _, awaitable := range awaitables {
		v, e := awaitable.Result()
		awaited = append(awaited, v)
		awaitedErrors = append(awaitedErrors, e)
	}

	if len(awaitedErrors) > 0 {
		return nil, errors.New(&ErrTaskFailed{
			Errors: awaitedErrors,
		})
	}

	return awaited, nil
}

// AnyInt16 will wait for the first task to emit a result (or an error)
// and return that, canceling all other tasks.
func AnyInt16(awaitables ...*task.Int16Task) (value int16, err error) {
	v := make([]interface{}, len(awaitables))
	for i := range awaitables {
		v[i] = awaitables[i]
	}
	defer stop.All(stop.ToStopables(v...)...)

	type doneOnce struct {
		o  sync.Once
		ch chan struct{}
	}
	done := doneOnce{
		ch: make(chan struct{}, 1),
	}
	closeDone := func() {
		done.o.Do(func() {
			close(done.ch)
		})
	}

	for _, awaitable := range awaitables {
		go func() {
			defer closeDone()
			value, err = awaitable.Result()
		}()
	}

	<-done.ch
	return value, err
}

// FastAnyInt16 does the same as AnyInt16 but does not wait for all
// other tasks to stop. It does tell them to stop it just doesn't wait for
// them to stop.
func FastAnyInt16(awaitables ...*task.Int16Task) (value int16, err error) {
	v := make([]interface{}, len(awaitables))
	for i := range awaitables {
		v[i] = awaitables[i]
	}
	defer stop.AllAsync(stop.ToStopables(v...)...)

	type doneOnce struct {
		o  sync.Once
		ch chan struct{}
	}
	done := doneOnce{
		ch: make(chan struct{}, 1),
	}
	closeDone := func() {
		done.o.Do(func() {
			close(done.ch)
		})
	}

	for _, awaitable := range awaitables {
		go func() {
			defer closeDone()
			value, err = awaitable.Result()
		}()
	}

	<-done.ch
	return value, err
}

// AnyInt16Slice will wait for the first task to emit a result (or an error)
// and return that, canceling all other tasks.
func AnyInt16Slice(awaitables ...*task.Int16SliceTask) (value []int16, err error) {
	v := make([]interface{}, len(awaitables))
	for i := range awaitables {
		v[i] = awaitables[i]
	}
	defer stop.All(stop.ToStopables(v...)...)

	type doneOnce struct {
		o  sync.Once
		ch chan struct{}
	}
	done := doneOnce{
		ch: make(chan struct{}, 1),
	}
	closeDone := func() {
		done.o.Do(func() {
			close(done.ch)
		})
	}

	for _, awaitable := range awaitables {
		go func() {
			defer closeDone()
			value, err = awaitable.Result()
		}()
	}

	<-done.ch
	return value, err
}

// FastAnyInt16Slice does the same as AnyInt16Slice but does not wait
// for all other tasks to stop. It does tell them to stop it just doesn't wait
// for them to stop.
func FastAnyInt16Slice(awaitables ...*task.Int16SliceTask) (value []int16, err error) {
	v := make([]interface{}, len(awaitables))
	for i := range awaitables {
		v[i] = awaitables[i]
	}
	defer stop.AllAsync(stop.ToStopables(v...)...)

	type doneOnce struct {
		o  sync.Once
		ch chan struct{}
	}
	done := doneOnce{
		ch: make(chan struct{}, 1),
	}
	closeDone := func() {
		done.o.Do(func() {
			close(done.ch)
		})
	}

	for _, awaitable := range awaitables {
		go func() {
			defer closeDone()
			value, err = awaitable.Result()
		}()
	}

	<-done.ch
	return value, err
}

// AllInt16sOrError will wait for every given task to emit a result or
// return as soon as an error is encountered, canceling all other tasks.
func AllInt16sOrError(awaitables ...*task.Int16Task) ([]int16, error) {
	v := make([]interface{}, len(awaitables))
	for i := range awaitables {
		v[i] = awaitables[i]
	}
	defer stop.All(stop.ToStopables(v...)...)

	errCh := make(chan error, 1)
	valueCh := make(chan int16, 1)

	for _, awaitable := range awaitables {
		go func() {
			v, err := awaitable.Result()
			if err != nil {
				errCh <- errors.Wrap(err, 0)
				return
			}
			valueCh <- v
		}()
	}

	values := []int16{}
	for {
		select {
		case err := <-errCh:
			return nil, errors.Wrap(err, 0)
		case value := <-valueCh:
			values = append(values, value)
			if len(values) == len(awaitables) {
				return values, nil
			}
		}
	}
}

// FastAllInt16sOrError does the same as AllInt16sOrError but does not
// wait for all other tasks to stop. It does tell them to stop it just doesn't
// wait for them to stop.
func FastAllInt16sOrError(awaitables ...*task.Int16Task) ([]int16, error) {
	v := make([]interface{}, len(awaitables))
	for i := range awaitables {
		v[i] = awaitables[i]
	}
	defer stop.AllAsync(stop.ToStopables(v...)...)

	errCh := make(chan error, 1)
	valueCh := make(chan int16, 1)

	for _, awaitable := range awaitables {
		go func() {
			v, err := awaitable.Result()
			if err != nil {
				errCh <- errors.Wrap(err, 0)
				return
			}
			valueCh <- v
		}()
	}

	values := []int16{}
	for {
		select {
		case err := <-errCh:
			return nil, errors.Wrap(err, 0)
		case value := <-valueCh:
			values = append(values, value)
			if len(values) == len(awaitables) {
				return values, nil
			}
		}
	}
}

// AllInt16SlicesOrError will wait for every given task to emit a result or
// return as soon as an error is encountered, canceling all other tasks.
func AllInt16SlicesOrError(awaitables ...*task.Int16SliceTask) ([][]int16, error) {
	v := make([]interface{}, len(awaitables))
	for i := range awaitables {
		v[i] = awaitables[i]
	}
	defer stop.All(stop.ToStopables(v...)...)

	errCh := make(chan error, 1)
	valueCh := make(chan []int16, 1)

	for _, awaitable := range awaitables {
		go func() {
			v, err := awaitable.Result()
			if err != nil {
				errCh <- errors.Wrap(err, 0)
				return
			}
			valueCh <- v
		}()
	}

	values := [][]int16{}
	for {
		select {
		case err := <-errCh:
			return nil, errors.Wrap(err, 0)
		case value := <-valueCh:
			values = append(values, value)
			if len(values) == len(awaitables) {
				return values, nil
			}
		}
	}
}

// FastAllInt16SlicesOrError does the same as AllInt16SlicesOrError but
// does not wait for all other tasks to stop. It does tell them to stop it just
// doesn't wait for them to stop.
func FastAllInt16SlicesOrError(awaitables ...*task.Int16SliceTask) ([][]int16, error) {
	v := make([]interface{}, len(awaitables))
	for i := range awaitables {
		v[i] = awaitables[i]
	}
	defer stop.AllAsync(stop.ToStopables(v...)...)

	errCh := make(chan error, 1)
	valueCh := make(chan []int16, 1)

	for _, awaitable := range awaitables {
		go func() {
			v, err := awaitable.Result()
			if err != nil {
				errCh <- errors.Wrap(err, 0)
				return
			}
			valueCh <- v
		}()
	}

	values := [][]int16{}
	for {
		select {
		case err := <-errCh:
			return nil, errors.Wrap(err, 0)
		case value := <-valueCh:
			values = append(values, value)
			if len(values) == len(awaitables) {
				return values, nil
			}
		}
	}
}

// AllInt32s will wait for every given task to emit a result.
// The results (& errors) will be returned in a slice ordered the
// same as the input.
func AllInt32s(awaitables ...*task.Int32Task) ([]int32, error) {
	awaited := []int32{}
	awaitedErrors := []error{}

	for _, awaitable := range awaitables {
		v, e := awaitable.Result()
		awaited = append(awaited, v)
		awaitedErrors = append(awaitedErrors, e)
	}

	if len(awaitedErrors) > 0 {
		return nil, errors.New(&ErrTaskFailed{
			Errors: awaitedErrors,
		})
	}

	return awaited, nil
}

// AllInt32Slices will wait for every given task to emit a result.
// The results (& errors) will be returned in a slice ordered the
// same as the input.
func AllInt32Slices(awaitables ...*task.Int32SliceTask) ([][]int32, error) {
	awaited := [][]int32{}
	awaitedErrors := []error{}

	for _, awaitable := range awaitables {
		v, e := awaitable.Result()
		awaited = append(awaited, v)
		awaitedErrors = append(awaitedErrors, e)
	}

	if len(awaitedErrors) > 0 {
		return nil, errors.New(&ErrTaskFailed{
			Errors: awaitedErrors,
		})
	}

	return awaited, nil
}

// AnyInt32 will wait for the first task to emit a result (or an error)
// and return that, canceling all other tasks.
func AnyInt32(awaitables ...*task.Int32Task) (value int32, err error) {
	v := make([]interface{}, len(awaitables))
	for i := range awaitables {
		v[i] = awaitables[i]
	}
	defer stop.All(stop.ToStopables(v...)...)

	type doneOnce struct {
		o  sync.Once
		ch chan struct{}
	}
	done := doneOnce{
		ch: make(chan struct{}, 1),
	}
	closeDone := func() {
		done.o.Do(func() {
			close(done.ch)
		})
	}

	for _, awaitable := range awaitables {
		go func() {
			defer closeDone()
			value, err = awaitable.Result()
		}()
	}

	<-done.ch
	return value, err
}

// FastAnyInt32 does the same as AnyInt32 but does not wait for all
// other tasks to stop. It does tell them to stop it just doesn't wait for
// them to stop.
func FastAnyInt32(awaitables ...*task.Int32Task) (value int32, err error) {
	v := make([]interface{}, len(awaitables))
	for i := range awaitables {
		v[i] = awaitables[i]
	}
	defer stop.AllAsync(stop.ToStopables(v...)...)

	type doneOnce struct {
		o  sync.Once
		ch chan struct{}
	}
	done := doneOnce{
		ch: make(chan struct{}, 1),
	}
	closeDone := func() {
		done.o.Do(func() {
			close(done.ch)
		})
	}

	for _, awaitable := range awaitables {
		go func() {
			defer closeDone()
			value, err = awaitable.Result()
		}()
	}

	<-done.ch
	return value, err
}

// AnyInt32Slice will wait for the first task to emit a result (or an error)
// and return that, canceling all other tasks.
func AnyInt32Slice(awaitables ...*task.Int32SliceTask) (value []int32, err error) {
	v := make([]interface{}, len(awaitables))
	for i := range awaitables {
		v[i] = awaitables[i]
	}
	defer stop.All(stop.ToStopables(v...)...)

	type doneOnce struct {
		o  sync.Once
		ch chan struct{}
	}
	done := doneOnce{
		ch: make(chan struct{}, 1),
	}
	closeDone := func() {
		done.o.Do(func() {
			close(done.ch)
		})
	}

	for _, awaitable := range awaitables {
		go func() {
			defer closeDone()
			value, err = awaitable.Result()
		}()
	}

	<-done.ch
	return value, err
}

// FastAnyInt32Slice does the same as AnyInt32Slice but does not wait
// for all other tasks to stop. It does tell them to stop it just doesn't wait
// for them to stop.
func FastAnyInt32Slice(awaitables ...*task.Int32SliceTask) (value []int32, err error) {
	v := make([]interface{}, len(awaitables))
	for i := range awaitables {
		v[i] = awaitables[i]
	}
	defer stop.AllAsync(stop.ToStopables(v...)...)

	type doneOnce struct {
		o  sync.Once
		ch chan struct{}
	}
	done := doneOnce{
		ch: make(chan struct{}, 1),
	}
	closeDone := func() {
		done.o.Do(func() {
			close(done.ch)
		})
	}

	for _, awaitable := range awaitables {
		go func() {
			defer closeDone()
			value, err = awaitable.Result()
		}()
	}

	<-done.ch
	return value, err
}

// AllInt32sOrError will wait for every given task to emit a result or
// return as soon as an error is encountered, canceling all other tasks.
func AllInt32sOrError(awaitables ...*task.Int32Task) ([]int32, error) {
	v := make([]interface{}, len(awaitables))
	for i := range awaitables {
		v[i] = awaitables[i]
	}
	defer stop.All(stop.ToStopables(v...)...)

	errCh := make(chan error, 1)
	valueCh := make(chan int32, 1)

	for _, awaitable := range awaitables {
		go func() {
			v, err := awaitable.Result()
			if err != nil {
				errCh <- errors.Wrap(err, 0)
				return
			}
			valueCh <- v
		}()
	}

	values := []int32{}
	for {
		select {
		case err := <-errCh:
			return nil, errors.Wrap(err, 0)
		case value := <-valueCh:
			values = append(values, value)
			if len(values) == len(awaitables) {
				return values, nil
			}
		}
	}
}

// FastAllInt32sOrError does the same as AllInt32sOrError but does not
// wait for all other tasks to stop. It does tell them to stop it just doesn't
// wait for them to stop.
func FastAllInt32sOrError(awaitables ...*task.Int32Task) ([]int32, error) {
	v := make([]interface{}, len(awaitables))
	for i := range awaitables {
		v[i] = awaitables[i]
	}
	defer stop.AllAsync(stop.ToStopables(v...)...)

	errCh := make(chan error, 1)
	valueCh := make(chan int32, 1)

	for _, awaitable := range awaitables {
		go func() {
			v, err := awaitable.Result()
			if err != nil {
				errCh <- errors.Wrap(err, 0)
				return
			}
			valueCh <- v
		}()
	}

	values := []int32{}
	for {
		select {
		case err := <-errCh:
			return nil, errors.Wrap(err, 0)
		case value := <-valueCh:
			values = append(values, value)
			if len(values) == len(awaitables) {
				return values, nil
			}
		}
	}
}

// AllInt32SlicesOrError will wait for every given task to emit a result or
// return as soon as an error is encountered, canceling all other tasks.
func AllInt32SlicesOrError(awaitables ...*task.Int32SliceTask) ([][]int32, error) {
	v := make([]interface{}, len(awaitables))
	for i := range awaitables {
		v[i] = awaitables[i]
	}
	defer stop.All(stop.ToStopables(v...)...)

	errCh := make(chan error, 1)
	valueCh := make(chan []int32, 1)

	for _, awaitable := range awaitables {
		go func() {
			v, err := awaitable.Result()
			if err != nil {
				errCh <- errors.Wrap(err, 0)
				return
			}
			valueCh <- v
		}()
	}

	values := [][]int32{}
	for {
		select {
		case err := <-errCh:
			return nil, errors.Wrap(err, 0)
		case value := <-valueCh:
			values = append(values, value)
			if len(values) == len(awaitables) {
				return values, nil
			}
		}
	}
}

// FastAllInt32SlicesOrError does the same as AllInt32SlicesOrError but
// does not wait for all other tasks to stop. It does tell them to stop it just
// doesn't wait for them to stop.
func FastAllInt32SlicesOrError(awaitables ...*task.Int32SliceTask) ([][]int32, error) {
	v := make([]interface{}, len(awaitables))
	for i := range awaitables {
		v[i] = awaitables[i]
	}
	defer stop.AllAsync(stop.ToStopables(v...)...)

	errCh := make(chan error, 1)
	valueCh := make(chan []int32, 1)

	for _, awaitable := range awaitables {
		go func() {
			v, err := awaitable.Result()
			if err != nil {
				errCh <- errors.Wrap(err, 0)
				return
			}
			valueCh <- v
		}()
	}

	values := [][]int32{}
	for {
		select {
		case err := <-errCh:
			return nil, errors.Wrap(err, 0)
		case value := <-valueCh:
			values = append(values, value)
			if len(values) == len(awaitables) {
				return values, nil
			}
		}
	}
}

// AllInt64s will wait for every given task to emit a result.
// The results (& errors) will be returned in a slice ordered the
// same as the input.
func AllInt64s(awaitables ...*task.Int64Task) ([]int64, error) {
	awaited := []int64{}
	awaitedErrors := []error{}

	for _, awaitable := range awaitables {
		v, e := awaitable.Result()
		awaited = append(awaited, v)
		awaitedErrors = append(awaitedErrors, e)
	}

	if len(awaitedErrors) > 0 {
		return nil, errors.New(&ErrTaskFailed{
			Errors: awaitedErrors,
		})
	}

	return awaited, nil
}

// AllInt64Slices will wait for every given task to emit a result.
// The results (& errors) will be returned in a slice ordered the
// same as the input.
func AllInt64Slices(awaitables ...*task.Int64SliceTask) ([][]int64, error) {
	awaited := [][]int64{}
	awaitedErrors := []error{}

	for _, awaitable := range awaitables {
		v, e := awaitable.Result()
		awaited = append(awaited, v)
		awaitedErrors = append(awaitedErrors, e)
	}

	if len(awaitedErrors) > 0 {
		return nil, errors.New(&ErrTaskFailed{
			Errors: awaitedErrors,
		})
	}

	return awaited, nil
}

// AnyInt64 will wait for the first task to emit a result (or an error)
// and return that, canceling all other tasks.
func AnyInt64(awaitables ...*task.Int64Task) (value int64, err error) {
	v := make([]interface{}, len(awaitables))
	for i := range awaitables {
		v[i] = awaitables[i]
	}
	defer stop.All(stop.ToStopables(v...)...)

	type doneOnce struct {
		o  sync.Once
		ch chan struct{}
	}
	done := doneOnce{
		ch: make(chan struct{}, 1),
	}
	closeDone := func() {
		done.o.Do(func() {
			close(done.ch)
		})
	}

	for _, awaitable := range awaitables {
		go func() {
			defer closeDone()
			value, err = awaitable.Result()
		}()
	}

	<-done.ch
	return value, err
}

// FastAnyInt64 does the same as AnyInt64 but does not wait for all
// other tasks to stop. It does tell them to stop it just doesn't wait for
// them to stop.
func FastAnyInt64(awaitables ...*task.Int64Task) (value int64, err error) {
	v := make([]interface{}, len(awaitables))
	for i := range awaitables {
		v[i] = awaitables[i]
	}
	defer stop.AllAsync(stop.ToStopables(v...)...)

	type doneOnce struct {
		o  sync.Once
		ch chan struct{}
	}
	done := doneOnce{
		ch: make(chan struct{}, 1),
	}
	closeDone := func() {
		done.o.Do(func() {
			close(done.ch)
		})
	}

	for _, awaitable := range awaitables {
		go func() {
			defer closeDone()
			value, err = awaitable.Result()
		}()
	}

	<-done.ch
	return value, err
}

// AnyInt64Slice will wait for the first task to emit a result (or an error)
// and return that, canceling all other tasks.
func AnyInt64Slice(awaitables ...*task.Int64SliceTask) (value []int64, err error) {
	v := make([]interface{}, len(awaitables))
	for i := range awaitables {
		v[i] = awaitables[i]
	}
	defer stop.All(stop.ToStopables(v...)...)

	type doneOnce struct {
		o  sync.Once
		ch chan struct{}
	}
	done := doneOnce{
		ch: make(chan struct{}, 1),
	}
	closeDone := func() {
		done.o.Do(func() {
			close(done.ch)
		})
	}

	for _, awaitable := range awaitables {
		go func() {
			defer closeDone()
			value, err = awaitable.Result()
		}()
	}

	<-done.ch
	return value, err
}

// FastAnyInt64Slice does the same as AnyInt64Slice but does not wait
// for all other tasks to stop. It does tell them to stop it just doesn't wait
// for them to stop.
func FastAnyInt64Slice(awaitables ...*task.Int64SliceTask) (value []int64, err error) {
	v := make([]interface{}, len(awaitables))
	for i := range awaitables {
		v[i] = awaitables[i]
	}
	defer stop.AllAsync(stop.ToStopables(v...)...)

	type doneOnce struct {
		o  sync.Once
		ch chan struct{}
	}
	done := doneOnce{
		ch: make(chan struct{}, 1),
	}
	closeDone := func() {
		done.o.Do(func() {
			close(done.ch)
		})
	}

	for _, awaitable := range awaitables {
		go func() {
			defer closeDone()
			value, err = awaitable.Result()
		}()
	}

	<-done.ch
	return value, err
}

// AllInt64sOrError will wait for every given task to emit a result or
// return as soon as an error is encountered, canceling all other tasks.
func AllInt64sOrError(awaitables ...*task.Int64Task) ([]int64, error) {
	v := make([]interface{}, len(awaitables))
	for i := range awaitables {
		v[i] = awaitables[i]
	}
	defer stop.All(stop.ToStopables(v...)...)

	errCh := make(chan error, 1)
	valueCh := make(chan int64, 1)

	for _, awaitable := range awaitables {
		go func() {
			v, err := awaitable.Result()
			if err != nil {
				errCh <- errors.Wrap(err, 0)
				return
			}
			valueCh <- v
		}()
	}

	values := []int64{}
	for {
		select {
		case err := <-errCh:
			return nil, errors.Wrap(err, 0)
		case value := <-valueCh:
			values = append(values, value)
			if len(values) == len(awaitables) {
				return values, nil
			}
		}
	}
}

// FastAllInt64sOrError does the same as AllInt64sOrError but does not
// wait for all other tasks to stop. It does tell them to stop it just doesn't
// wait for them to stop.
func FastAllInt64sOrError(awaitables ...*task.Int64Task) ([]int64, error) {
	v := make([]interface{}, len(awaitables))
	for i := range awaitables {
		v[i] = awaitables[i]
	}
	defer stop.AllAsync(stop.ToStopables(v...)...)

	errCh := make(chan error, 1)
	valueCh := make(chan int64, 1)

	for _, awaitable := range awaitables {
		go func() {
			v, err := awaitable.Result()
			if err != nil {
				errCh <- errors.Wrap(err, 0)
				return
			}
			valueCh <- v
		}()
	}

	values := []int64{}
	for {
		select {
		case err := <-errCh:
			return nil, errors.Wrap(err, 0)
		case value := <-valueCh:
			values = append(values, value)
			if len(values) == len(awaitables) {
				return values, nil
			}
		}
	}
}

// AllInt64SlicesOrError will wait for every given task to emit a result or
// return as soon as an error is encountered, canceling all other tasks.
func AllInt64SlicesOrError(awaitables ...*task.Int64SliceTask) ([][]int64, error) {
	v := make([]interface{}, len(awaitables))
	for i := range awaitables {
		v[i] = awaitables[i]
	}
	defer stop.All(stop.ToStopables(v...)...)

	errCh := make(chan error, 1)
	valueCh := make(chan []int64, 1)

	for _, awaitable := range awaitables {
		go func() {
			v, err := awaitable.Result()
			if err != nil {
				errCh <- errors.Wrap(err, 0)
				return
			}
			valueCh <- v
		}()
	}

	values := [][]int64{}
	for {
		select {
		case err := <-errCh:
			return nil, errors.Wrap(err, 0)
		case value := <-valueCh:
			values = append(values, value)
			if len(values) == len(awaitables) {
				return values, nil
			}
		}
	}
}

// FastAllInt64SlicesOrError does the same as AllInt64SlicesOrError but
// does not wait for all other tasks to stop. It does tell them to stop it just
// doesn't wait for them to stop.
func FastAllInt64SlicesOrError(awaitables ...*task.Int64SliceTask) ([][]int64, error) {
	v := make([]interface{}, len(awaitables))
	for i := range awaitables {
		v[i] = awaitables[i]
	}
	defer stop.AllAsync(stop.ToStopables(v...)...)

	errCh := make(chan error, 1)
	valueCh := make(chan []int64, 1)

	for _, awaitable := range awaitables {
		go func() {
			v, err := awaitable.Result()
			if err != nil {
				errCh <- errors.Wrap(err, 0)
				return
			}
			valueCh <- v
		}()
	}

	values := [][]int64{}
	for {
		select {
		case err := <-errCh:
			return nil, errors.Wrap(err, 0)
		case value := <-valueCh:
			values = append(values, value)
			if len(values) == len(awaitables) {
				return values, nil
			}
		}
	}
}

// AllInt8s will wait for every given task to emit a result.
// The results (& errors) will be returned in a slice ordered the
// same as the input.
func AllInt8s(awaitables ...*task.Int8Task) ([]int8, error) {
	awaited := []int8{}
	awaitedErrors := []error{}

	for _, awaitable := range awaitables {
		v, e := awaitable.Result()
		awaited = append(awaited, v)
		awaitedErrors = append(awaitedErrors, e)
	}

	if len(awaitedErrors) > 0 {
		return nil, errors.New(&ErrTaskFailed{
			Errors: awaitedErrors,
		})
	}

	return awaited, nil
}

// AllInt8Slices will wait for every given task to emit a result.
// The results (& errors) will be returned in a slice ordered the
// same as the input.
func AllInt8Slices(awaitables ...*task.Int8SliceTask) ([][]int8, error) {
	awaited := [][]int8{}
	awaitedErrors := []error{}

	for _, awaitable := range awaitables {
		v, e := awaitable.Result()
		awaited = append(awaited, v)
		awaitedErrors = append(awaitedErrors, e)
	}

	if len(awaitedErrors) > 0 {
		return nil, errors.New(&ErrTaskFailed{
			Errors: awaitedErrors,
		})
	}

	return awaited, nil
}

// AnyInt8 will wait for the first task to emit a result (or an error)
// and return that, canceling all other tasks.
func AnyInt8(awaitables ...*task.Int8Task) (value int8, err error) {
	v := make([]interface{}, len(awaitables))
	for i := range awaitables {
		v[i] = awaitables[i]
	}
	defer stop.All(stop.ToStopables(v...)...)

	type doneOnce struct {
		o  sync.Once
		ch chan struct{}
	}
	done := doneOnce{
		ch: make(chan struct{}, 1),
	}
	closeDone := func() {
		done.o.Do(func() {
			close(done.ch)
		})
	}

	for _, awaitable := range awaitables {
		go func() {
			defer closeDone()
			value, err = awaitable.Result()
		}()
	}

	<-done.ch
	return value, err
}

// FastAnyInt8 does the same as AnyInt8 but does not wait for all
// other tasks to stop. It does tell them to stop it just doesn't wait for
// them to stop.
func FastAnyInt8(awaitables ...*task.Int8Task) (value int8, err error) {
	v := make([]interface{}, len(awaitables))
	for i := range awaitables {
		v[i] = awaitables[i]
	}
	defer stop.AllAsync(stop.ToStopables(v...)...)

	type doneOnce struct {
		o  sync.Once
		ch chan struct{}
	}
	done := doneOnce{
		ch: make(chan struct{}, 1),
	}
	closeDone := func() {
		done.o.Do(func() {
			close(done.ch)
		})
	}

	for _, awaitable := range awaitables {
		go func() {
			defer closeDone()
			value, err = awaitable.Result()
		}()
	}

	<-done.ch
	return value, err
}

// AnyInt8Slice will wait for the first task to emit a result (or an error)
// and return that, canceling all other tasks.
func AnyInt8Slice(awaitables ...*task.Int8SliceTask) (value []int8, err error) {
	v := make([]interface{}, len(awaitables))
	for i := range awaitables {
		v[i] = awaitables[i]
	}
	defer stop.All(stop.ToStopables(v...)...)

	type doneOnce struct {
		o  sync.Once
		ch chan struct{}
	}
	done := doneOnce{
		ch: make(chan struct{}, 1),
	}
	closeDone := func() {
		done.o.Do(func() {
			close(done.ch)
		})
	}

	for _, awaitable := range awaitables {
		go func() {
			defer closeDone()
			value, err = awaitable.Result()
		}()
	}

	<-done.ch
	return value, err
}

// FastAnyInt8Slice does the same as AnyInt8Slice but does not wait
// for all other tasks to stop. It does tell them to stop it just doesn't wait
// for them to stop.
func FastAnyInt8Slice(awaitables ...*task.Int8SliceTask) (value []int8, err error) {
	v := make([]interface{}, len(awaitables))
	for i := range awaitables {
		v[i] = awaitables[i]
	}
	defer stop.AllAsync(stop.ToStopables(v...)...)

	type doneOnce struct {
		o  sync.Once
		ch chan struct{}
	}
	done := doneOnce{
		ch: make(chan struct{}, 1),
	}
	closeDone := func() {
		done.o.Do(func() {
			close(done.ch)
		})
	}

	for _, awaitable := range awaitables {
		go func() {
			defer closeDone()
			value, err = awaitable.Result()
		}()
	}

	<-done.ch
	return value, err
}

// AllInt8sOrError will wait for every given task to emit a result or
// return as soon as an error is encountered, canceling all other tasks.
func AllInt8sOrError(awaitables ...*task.Int8Task) ([]int8, error) {
	v := make([]interface{}, len(awaitables))
	for i := range awaitables {
		v[i] = awaitables[i]
	}
	defer stop.All(stop.ToStopables(v...)...)

	errCh := make(chan error, 1)
	valueCh := make(chan int8, 1)

	for _, awaitable := range awaitables {
		go func() {
			v, err := awaitable.Result()
			if err != nil {
				errCh <- errors.Wrap(err, 0)
				return
			}
			valueCh <- v
		}()
	}

	values := []int8{}
	for {
		select {
		case err := <-errCh:
			return nil, errors.Wrap(err, 0)
		case value := <-valueCh:
			values = append(values, value)
			if len(values) == len(awaitables) {
				return values, nil
			}
		}
	}
}

// FastAllInt8sOrError does the same as AllInt8sOrError but does not
// wait for all other tasks to stop. It does tell them to stop it just doesn't
// wait for them to stop.
func FastAllInt8sOrError(awaitables ...*task.Int8Task) ([]int8, error) {
	v := make([]interface{}, len(awaitables))
	for i := range awaitables {
		v[i] = awaitables[i]
	}
	defer stop.AllAsync(stop.ToStopables(v...)...)

	errCh := make(chan error, 1)
	valueCh := make(chan int8, 1)

	for _, awaitable := range awaitables {
		go func() {
			v, err := awaitable.Result()
			if err != nil {
				errCh <- errors.Wrap(err, 0)
				return
			}
			valueCh <- v
		}()
	}

	values := []int8{}
	for {
		select {
		case err := <-errCh:
			return nil, errors.Wrap(err, 0)
		case value := <-valueCh:
			values = append(values, value)
			if len(values) == len(awaitables) {
				return values, nil
			}
		}
	}
}

// AllInt8SlicesOrError will wait for every given task to emit a result or
// return as soon as an error is encountered, canceling all other tasks.
func AllInt8SlicesOrError(awaitables ...*task.Int8SliceTask) ([][]int8, error) {
	v := make([]interface{}, len(awaitables))
	for i := range awaitables {
		v[i] = awaitables[i]
	}
	defer stop.All(stop.ToStopables(v...)...)

	errCh := make(chan error, 1)
	valueCh := make(chan []int8, 1)

	for _, awaitable := range awaitables {
		go func() {
			v, err := awaitable.Result()
			if err != nil {
				errCh <- errors.Wrap(err, 0)
				return
			}
			valueCh <- v
		}()
	}

	values := [][]int8{}
	for {
		select {
		case err := <-errCh:
			return nil, errors.Wrap(err, 0)
		case value := <-valueCh:
			values = append(values, value)
			if len(values) == len(awaitables) {
				return values, nil
			}
		}
	}
}

// FastAllInt8SlicesOrError does the same as AllInt8SlicesOrError but
// does not wait for all other tasks to stop. It does tell them to stop it just
// doesn't wait for them to stop.
func FastAllInt8SlicesOrError(awaitables ...*task.Int8SliceTask) ([][]int8, error) {
	v := make([]interface{}, len(awaitables))
	for i := range awaitables {
		v[i] = awaitables[i]
	}
	defer stop.AllAsync(stop.ToStopables(v...)...)

	errCh := make(chan error, 1)
	valueCh := make(chan []int8, 1)

	for _, awaitable := range awaitables {
		go func() {
			v, err := awaitable.Result()
			if err != nil {
				errCh <- errors.Wrap(err, 0)
				return
			}
			valueCh <- v
		}()
	}

	values := [][]int8{}
	for {
		select {
		case err := <-errCh:
			return nil, errors.Wrap(err, 0)
		case value := <-valueCh:
			values = append(values, value)
			if len(values) == len(awaitables) {
				return values, nil
			}
		}
	}
}

// AllRunes will wait for every given task to emit a result.
// The results (& errors) will be returned in a slice ordered the
// same as the input.
func AllRunes(awaitables ...*task.RuneTask) ([]rune, error) {
	awaited := []rune{}
	awaitedErrors := []error{}

	for _, awaitable := range awaitables {
		v, e := awaitable.Result()
		awaited = append(awaited, v)
		awaitedErrors = append(awaitedErrors, e)
	}

	if len(awaitedErrors) > 0 {
		return nil, errors.New(&ErrTaskFailed{
			Errors: awaitedErrors,
		})
	}

	return awaited, nil
}

// AllRuneSlices will wait for every given task to emit a result.
// The results (& errors) will be returned in a slice ordered the
// same as the input.
func AllRuneSlices(awaitables ...*task.RuneSliceTask) ([][]rune, error) {
	awaited := [][]rune{}
	awaitedErrors := []error{}

	for _, awaitable := range awaitables {
		v, e := awaitable.Result()
		awaited = append(awaited, v)
		awaitedErrors = append(awaitedErrors, e)
	}

	if len(awaitedErrors) > 0 {
		return nil, errors.New(&ErrTaskFailed{
			Errors: awaitedErrors,
		})
	}

	return awaited, nil
}

// AnyRune will wait for the first task to emit a result (or an error)
// and return that, canceling all other tasks.
func AnyRune(awaitables ...*task.RuneTask) (value rune, err error) {
	v := make([]interface{}, len(awaitables))
	for i := range awaitables {
		v[i] = awaitables[i]
	}
	defer stop.All(stop.ToStopables(v...)...)

	type doneOnce struct {
		o  sync.Once
		ch chan struct{}
	}
	done := doneOnce{
		ch: make(chan struct{}, 1),
	}
	closeDone := func() {
		done.o.Do(func() {
			close(done.ch)
		})
	}

	for _, awaitable := range awaitables {
		go func() {
			defer closeDone()
			value, err = awaitable.Result()
		}()
	}

	<-done.ch
	return value, err
}

// FastAnyRune does the same as AnyRune but does not wait for all
// other tasks to stop. It does tell them to stop it just doesn't wait for
// them to stop.
func FastAnyRune(awaitables ...*task.RuneTask) (value rune, err error) {
	v := make([]interface{}, len(awaitables))
	for i := range awaitables {
		v[i] = awaitables[i]
	}
	defer stop.AllAsync(stop.ToStopables(v...)...)

	type doneOnce struct {
		o  sync.Once
		ch chan struct{}
	}
	done := doneOnce{
		ch: make(chan struct{}, 1),
	}
	closeDone := func() {
		done.o.Do(func() {
			close(done.ch)
		})
	}

	for _, awaitable := range awaitables {
		go func() {
			defer closeDone()
			value, err = awaitable.Result()
		}()
	}

	<-done.ch
	return value, err
}

// AnyRuneSlice will wait for the first task to emit a result (or an error)
// and return that, canceling all other tasks.
func AnyRuneSlice(awaitables ...*task.RuneSliceTask) (value []rune, err error) {
	v := make([]interface{}, len(awaitables))
	for i := range awaitables {
		v[i] = awaitables[i]
	}
	defer stop.All(stop.ToStopables(v...)...)

	type doneOnce struct {
		o  sync.Once
		ch chan struct{}
	}
	done := doneOnce{
		ch: make(chan struct{}, 1),
	}
	closeDone := func() {
		done.o.Do(func() {
			close(done.ch)
		})
	}

	for _, awaitable := range awaitables {
		go func() {
			defer closeDone()
			value, err = awaitable.Result()
		}()
	}

	<-done.ch
	return value, err
}

// FastAnyRuneSlice does the same as AnyRuneSlice but does not wait
// for all other tasks to stop. It does tell them to stop it just doesn't wait
// for them to stop.
func FastAnyRuneSlice(awaitables ...*task.RuneSliceTask) (value []rune, err error) {
	v := make([]interface{}, len(awaitables))
	for i := range awaitables {
		v[i] = awaitables[i]
	}
	defer stop.AllAsync(stop.ToStopables(v...)...)

	type doneOnce struct {
		o  sync.Once
		ch chan struct{}
	}
	done := doneOnce{
		ch: make(chan struct{}, 1),
	}
	closeDone := func() {
		done.o.Do(func() {
			close(done.ch)
		})
	}

	for _, awaitable := range awaitables {
		go func() {
			defer closeDone()
			value, err = awaitable.Result()
		}()
	}

	<-done.ch
	return value, err
}

// AllRunesOrError will wait for every given task to emit a result or
// return as soon as an error is encountered, canceling all other tasks.
func AllRunesOrError(awaitables ...*task.RuneTask) ([]rune, error) {
	v := make([]interface{}, len(awaitables))
	for i := range awaitables {
		v[i] = awaitables[i]
	}
	defer stop.All(stop.ToStopables(v...)...)

	errCh := make(chan error, 1)
	valueCh := make(chan rune, 1)

	for _, awaitable := range awaitables {
		go func() {
			v, err := awaitable.Result()
			if err != nil {
				errCh <- errors.Wrap(err, 0)
				return
			}
			valueCh <- v
		}()
	}

	values := []rune{}
	for {
		select {
		case err := <-errCh:
			return nil, errors.Wrap(err, 0)
		case value := <-valueCh:
			values = append(values, value)
			if len(values) == len(awaitables) {
				return values, nil
			}
		}
	}
}

// FastAllRunesOrError does the same as AllRunesOrError but does not
// wait for all other tasks to stop. It does tell them to stop it just doesn't
// wait for them to stop.
func FastAllRunesOrError(awaitables ...*task.RuneTask) ([]rune, error) {
	v := make([]interface{}, len(awaitables))
	for i := range awaitables {
		v[i] = awaitables[i]
	}
	defer stop.AllAsync(stop.ToStopables(v...)...)

	errCh := make(chan error, 1)
	valueCh := make(chan rune, 1)

	for _, awaitable := range awaitables {
		go func() {
			v, err := awaitable.Result()
			if err != nil {
				errCh <- errors.Wrap(err, 0)
				return
			}
			valueCh <- v
		}()
	}

	values := []rune{}
	for {
		select {
		case err := <-errCh:
			return nil, errors.Wrap(err, 0)
		case value := <-valueCh:
			values = append(values, value)
			if len(values) == len(awaitables) {
				return values, nil
			}
		}
	}
}

// AllRuneSlicesOrError will wait for every given task to emit a result or
// return as soon as an error is encountered, canceling all other tasks.
func AllRuneSlicesOrError(awaitables ...*task.RuneSliceTask) ([][]rune, error) {
	v := make([]interface{}, len(awaitables))
	for i := range awaitables {
		v[i] = awaitables[i]
	}
	defer stop.All(stop.ToStopables(v...)...)

	errCh := make(chan error, 1)
	valueCh := make(chan []rune, 1)

	for _, awaitable := range awaitables {
		go func() {
			v, err := awaitable.Result()
			if err != nil {
				errCh <- errors.Wrap(err, 0)
				return
			}
			valueCh <- v
		}()
	}

	values := [][]rune{}
	for {
		select {
		case err := <-errCh:
			return nil, errors.Wrap(err, 0)
		case value := <-valueCh:
			values = append(values, value)
			if len(values) == len(awaitables) {
				return values, nil
			}
		}
	}
}

// FastAllRuneSlicesOrError does the same as AllRuneSlicesOrError but
// does not wait for all other tasks to stop. It does tell them to stop it just
// doesn't wait for them to stop.
func FastAllRuneSlicesOrError(awaitables ...*task.RuneSliceTask) ([][]rune, error) {
	v := make([]interface{}, len(awaitables))
	for i := range awaitables {
		v[i] = awaitables[i]
	}
	defer stop.AllAsync(stop.ToStopables(v...)...)

	errCh := make(chan error, 1)
	valueCh := make(chan []rune, 1)

	for _, awaitable := range awaitables {
		go func() {
			v, err := awaitable.Result()
			if err != nil {
				errCh <- errors.Wrap(err, 0)
				return
			}
			valueCh <- v
		}()
	}

	values := [][]rune{}
	for {
		select {
		case err := <-errCh:
			return nil, errors.Wrap(err, 0)
		case value := <-valueCh:
			values = append(values, value)
			if len(values) == len(awaitables) {
				return values, nil
			}
		}
	}
}

// AllStrings will wait for every given task to emit a result.
// The results (& errors) will be returned in a slice ordered the
// same as the input.
func AllStrings(awaitables ...*task.StringTask) ([]string, error) {
	awaited := []string{}
	awaitedErrors := []error{}

	for _, awaitable := range awaitables {
		v, e := awaitable.Result()
		awaited = append(awaited, v)
		awaitedErrors = append(awaitedErrors, e)
	}

	if len(awaitedErrors) > 0 {
		return nil, errors.New(&ErrTaskFailed{
			Errors: awaitedErrors,
		})
	}

	return awaited, nil
}

// AllStringSlices will wait for every given task to emit a result.
// The results (& errors) will be returned in a slice ordered the
// same as the input.
func AllStringSlices(awaitables ...*task.StringSliceTask) ([][]string, error) {
	awaited := [][]string{}
	awaitedErrors := []error{}

	for _, awaitable := range awaitables {
		v, e := awaitable.Result()
		awaited = append(awaited, v)
		awaitedErrors = append(awaitedErrors, e)
	}

	if len(awaitedErrors) > 0 {
		return nil, errors.New(&ErrTaskFailed{
			Errors: awaitedErrors,
		})
	}

	return awaited, nil
}

// AnyString will wait for the first task to emit a result (or an error)
// and return that, canceling all other tasks.
func AnyString(awaitables ...*task.StringTask) (value string, err error) {
	v := make([]interface{}, len(awaitables))
	for i := range awaitables {
		v[i] = awaitables[i]
	}
	defer stop.All(stop.ToStopables(v...)...)

	type doneOnce struct {
		o  sync.Once
		ch chan struct{}
	}
	done := doneOnce{
		ch: make(chan struct{}, 1),
	}
	closeDone := func() {
		done.o.Do(func() {
			close(done.ch)
		})
	}

	for _, awaitable := range awaitables {
		go func() {
			defer closeDone()
			value, err = awaitable.Result()
		}()
	}

	<-done.ch
	return value, err
}

// FastAnyString does the same as AnyString but does not wait for all
// other tasks to stop. It does tell them to stop it just doesn't wait for
// them to stop.
func FastAnyString(awaitables ...*task.StringTask) (value string, err error) {
	v := make([]interface{}, len(awaitables))
	for i := range awaitables {
		v[i] = awaitables[i]
	}
	defer stop.AllAsync(stop.ToStopables(v...)...)

	type doneOnce struct {
		o  sync.Once
		ch chan struct{}
	}
	done := doneOnce{
		ch: make(chan struct{}, 1),
	}
	closeDone := func() {
		done.o.Do(func() {
			close(done.ch)
		})
	}

	for _, awaitable := range awaitables {
		go func() {
			defer closeDone()
			value, err = awaitable.Result()
		}()
	}

	<-done.ch
	return value, err
}

// AnyStringSlice will wait for the first task to emit a result (or an error)
// and return that, canceling all other tasks.
func AnyStringSlice(awaitables ...*task.StringSliceTask) (value []string, err error) {
	v := make([]interface{}, len(awaitables))
	for i := range awaitables {
		v[i] = awaitables[i]
	}
	defer stop.All(stop.ToStopables(v...)...)

	type doneOnce struct {
		o  sync.Once
		ch chan struct{}
	}
	done := doneOnce{
		ch: make(chan struct{}, 1),
	}
	closeDone := func() {
		done.o.Do(func() {
			close(done.ch)
		})
	}

	for _, awaitable := range awaitables {
		go func() {
			defer closeDone()
			value, err = awaitable.Result()
		}()
	}

	<-done.ch
	return value, err
}

// FastAnyStringSlice does the same as AnyStringSlice but does not wait
// for all other tasks to stop. It does tell them to stop it just doesn't wait
// for them to stop.
func FastAnyStringSlice(awaitables ...*task.StringSliceTask) (value []string, err error) {
	v := make([]interface{}, len(awaitables))
	for i := range awaitables {
		v[i] = awaitables[i]
	}
	defer stop.AllAsync(stop.ToStopables(v...)...)

	type doneOnce struct {
		o  sync.Once
		ch chan struct{}
	}
	done := doneOnce{
		ch: make(chan struct{}, 1),
	}
	closeDone := func() {
		done.o.Do(func() {
			close(done.ch)
		})
	}

	for _, awaitable := range awaitables {
		go func() {
			defer closeDone()
			value, err = awaitable.Result()
		}()
	}

	<-done.ch
	return value, err
}

// AllStringsOrError will wait for every given task to emit a result or
// return as soon as an error is encountered, canceling all other tasks.
func AllStringsOrError(awaitables ...*task.StringTask) ([]string, error) {
	v := make([]interface{}, len(awaitables))
	for i := range awaitables {
		v[i] = awaitables[i]
	}
	defer stop.All(stop.ToStopables(v...)...)

	errCh := make(chan error, 1)
	valueCh := make(chan string, 1)

	for _, awaitable := range awaitables {
		go func() {
			v, err := awaitable.Result()
			if err != nil {
				errCh <- errors.Wrap(err, 0)
				return
			}
			valueCh <- v
		}()
	}

	values := []string{}
	for {
		select {
		case err := <-errCh:
			return nil, errors.Wrap(err, 0)
		case value := <-valueCh:
			values = append(values, value)
			if len(values) == len(awaitables) {
				return values, nil
			}
		}
	}
}

// FastAllStringsOrError does the same as AllStringsOrError but does not
// wait for all other tasks to stop. It does tell them to stop it just doesn't
// wait for them to stop.
func FastAllStringsOrError(awaitables ...*task.StringTask) ([]string, error) {
	v := make([]interface{}, len(awaitables))
	for i := range awaitables {
		v[i] = awaitables[i]
	}
	defer stop.AllAsync(stop.ToStopables(v...)...)

	errCh := make(chan error, 1)
	valueCh := make(chan string, 1)

	for _, awaitable := range awaitables {
		go func() {
			v, err := awaitable.Result()
			if err != nil {
				errCh <- errors.Wrap(err, 0)
				return
			}
			valueCh <- v
		}()
	}

	values := []string{}
	for {
		select {
		case err := <-errCh:
			return nil, errors.Wrap(err, 0)
		case value := <-valueCh:
			values = append(values, value)
			if len(values) == len(awaitables) {
				return values, nil
			}
		}
	}
}

// AllStringSlicesOrError will wait for every given task to emit a result or
// return as soon as an error is encountered, canceling all other tasks.
func AllStringSlicesOrError(awaitables ...*task.StringSliceTask) ([][]string, error) {
	v := make([]interface{}, len(awaitables))
	for i := range awaitables {
		v[i] = awaitables[i]
	}
	defer stop.All(stop.ToStopables(v...)...)

	errCh := make(chan error, 1)
	valueCh := make(chan []string, 1)

	for _, awaitable := range awaitables {
		go func() {
			v, err := awaitable.Result()
			if err != nil {
				errCh <- errors.Wrap(err, 0)
				return
			}
			valueCh <- v
		}()
	}

	values := [][]string{}
	for {
		select {
		case err := <-errCh:
			return nil, errors.Wrap(err, 0)
		case value := <-valueCh:
			values = append(values, value)
			if len(values) == len(awaitables) {
				return values, nil
			}
		}
	}
}

// FastAllStringSlicesOrError does the same as AllStringSlicesOrError but
// does not wait for all other tasks to stop. It does tell them to stop it just
// doesn't wait for them to stop.
func FastAllStringSlicesOrError(awaitables ...*task.StringSliceTask) ([][]string, error) {
	v := make([]interface{}, len(awaitables))
	for i := range awaitables {
		v[i] = awaitables[i]
	}
	defer stop.AllAsync(stop.ToStopables(v...)...)

	errCh := make(chan error, 1)
	valueCh := make(chan []string, 1)

	for _, awaitable := range awaitables {
		go func() {
			v, err := awaitable.Result()
			if err != nil {
				errCh <- errors.Wrap(err, 0)
				return
			}
			valueCh <- v
		}()
	}

	values := [][]string{}
	for {
		select {
		case err := <-errCh:
			return nil, errors.Wrap(err, 0)
		case value := <-valueCh:
			values = append(values, value)
			if len(values) == len(awaitables) {
				return values, nil
			}
		}
	}
}

// AllUints will wait for every given task to emit a result.
// The results (& errors) will be returned in a slice ordered the
// same as the input.
func AllUints(awaitables ...*task.UintTask) ([]uint, error) {
	awaited := []uint{}
	awaitedErrors := []error{}

	for _, awaitable := range awaitables {
		v, e := awaitable.Result()
		awaited = append(awaited, v)
		awaitedErrors = append(awaitedErrors, e)
	}

	if len(awaitedErrors) > 0 {
		return nil, errors.New(&ErrTaskFailed{
			Errors: awaitedErrors,
		})
	}

	return awaited, nil
}

// AllUintSlices will wait for every given task to emit a result.
// The results (& errors) will be returned in a slice ordered the
// same as the input.
func AllUintSlices(awaitables ...*task.UintSliceTask) ([][]uint, error) {
	awaited := [][]uint{}
	awaitedErrors := []error{}

	for _, awaitable := range awaitables {
		v, e := awaitable.Result()
		awaited = append(awaited, v)
		awaitedErrors = append(awaitedErrors, e)
	}

	if len(awaitedErrors) > 0 {
		return nil, errors.New(&ErrTaskFailed{
			Errors: awaitedErrors,
		})
	}

	return awaited, nil
}

// AnyUint will wait for the first task to emit a result (or an error)
// and return that, canceling all other tasks.
func AnyUint(awaitables ...*task.UintTask) (value uint, err error) {
	v := make([]interface{}, len(awaitables))
	for i := range awaitables {
		v[i] = awaitables[i]
	}
	defer stop.All(stop.ToStopables(v...)...)

	type doneOnce struct {
		o  sync.Once
		ch chan struct{}
	}
	done := doneOnce{
		ch: make(chan struct{}, 1),
	}
	closeDone := func() {
		done.o.Do(func() {
			close(done.ch)
		})
	}

	for _, awaitable := range awaitables {
		go func() {
			defer closeDone()
			value, err = awaitable.Result()
		}()
	}

	<-done.ch
	return value, err
}

// FastAnyUint does the same as AnyUint but does not wait for all
// other tasks to stop. It does tell them to stop it just doesn't wait for
// them to stop.
func FastAnyUint(awaitables ...*task.UintTask) (value uint, err error) {
	v := make([]interface{}, len(awaitables))
	for i := range awaitables {
		v[i] = awaitables[i]
	}
	defer stop.AllAsync(stop.ToStopables(v...)...)

	type doneOnce struct {
		o  sync.Once
		ch chan struct{}
	}
	done := doneOnce{
		ch: make(chan struct{}, 1),
	}
	closeDone := func() {
		done.o.Do(func() {
			close(done.ch)
		})
	}

	for _, awaitable := range awaitables {
		go func() {
			defer closeDone()
			value, err = awaitable.Result()
		}()
	}

	<-done.ch
	return value, err
}

// AnyUintSlice will wait for the first task to emit a result (or an error)
// and return that, canceling all other tasks.
func AnyUintSlice(awaitables ...*task.UintSliceTask) (value []uint, err error) {
	v := make([]interface{}, len(awaitables))
	for i := range awaitables {
		v[i] = awaitables[i]
	}
	defer stop.All(stop.ToStopables(v...)...)

	type doneOnce struct {
		o  sync.Once
		ch chan struct{}
	}
	done := doneOnce{
		ch: make(chan struct{}, 1),
	}
	closeDone := func() {
		done.o.Do(func() {
			close(done.ch)
		})
	}

	for _, awaitable := range awaitables {
		go func() {
			defer closeDone()
			value, err = awaitable.Result()
		}()
	}

	<-done.ch
	return value, err
}

// FastAnyUintSlice does the same as AnyUintSlice but does not wait
// for all other tasks to stop. It does tell them to stop it just doesn't wait
// for them to stop.
func FastAnyUintSlice(awaitables ...*task.UintSliceTask) (value []uint, err error) {
	v := make([]interface{}, len(awaitables))
	for i := range awaitables {
		v[i] = awaitables[i]
	}
	defer stop.AllAsync(stop.ToStopables(v...)...)

	type doneOnce struct {
		o  sync.Once
		ch chan struct{}
	}
	done := doneOnce{
		ch: make(chan struct{}, 1),
	}
	closeDone := func() {
		done.o.Do(func() {
			close(done.ch)
		})
	}

	for _, awaitable := range awaitables {
		go func() {
			defer closeDone()
			value, err = awaitable.Result()
		}()
	}

	<-done.ch
	return value, err
}

// AllUintsOrError will wait for every given task to emit a result or
// return as soon as an error is encountered, canceling all other tasks.
func AllUintsOrError(awaitables ...*task.UintTask) ([]uint, error) {
	v := make([]interface{}, len(awaitables))
	for i := range awaitables {
		v[i] = awaitables[i]
	}
	defer stop.All(stop.ToStopables(v...)...)

	errCh := make(chan error, 1)
	valueCh := make(chan uint, 1)

	for _, awaitable := range awaitables {
		go func() {
			v, err := awaitable.Result()
			if err != nil {
				errCh <- errors.Wrap(err, 0)
				return
			}
			valueCh <- v
		}()
	}

	values := []uint{}
	for {
		select {
		case err := <-errCh:
			return nil, errors.Wrap(err, 0)
		case value := <-valueCh:
			values = append(values, value)
			if len(values) == len(awaitables) {
				return values, nil
			}
		}
	}
}

// FastAllUintsOrError does the same as AllUintsOrError but does not
// wait for all other tasks to stop. It does tell them to stop it just doesn't
// wait for them to stop.
func FastAllUintsOrError(awaitables ...*task.UintTask) ([]uint, error) {
	v := make([]interface{}, len(awaitables))
	for i := range awaitables {
		v[i] = awaitables[i]
	}
	defer stop.AllAsync(stop.ToStopables(v...)...)

	errCh := make(chan error, 1)
	valueCh := make(chan uint, 1)

	for _, awaitable := range awaitables {
		go func() {
			v, err := awaitable.Result()
			if err != nil {
				errCh <- errors.Wrap(err, 0)
				return
			}
			valueCh <- v
		}()
	}

	values := []uint{}
	for {
		select {
		case err := <-errCh:
			return nil, errors.Wrap(err, 0)
		case value := <-valueCh:
			values = append(values, value)
			if len(values) == len(awaitables) {
				return values, nil
			}
		}
	}
}

// AllUintSlicesOrError will wait for every given task to emit a result or
// return as soon as an error is encountered, canceling all other tasks.
func AllUintSlicesOrError(awaitables ...*task.UintSliceTask) ([][]uint, error) {
	v := make([]interface{}, len(awaitables))
	for i := range awaitables {
		v[i] = awaitables[i]
	}
	defer stop.All(stop.ToStopables(v...)...)

	errCh := make(chan error, 1)
	valueCh := make(chan []uint, 1)

	for _, awaitable := range awaitables {
		go func() {
			v, err := awaitable.Result()
			if err != nil {
				errCh <- errors.Wrap(err, 0)
				return
			}
			valueCh <- v
		}()
	}

	values := [][]uint{}
	for {
		select {
		case err := <-errCh:
			return nil, errors.Wrap(err, 0)
		case value := <-valueCh:
			values = append(values, value)
			if len(values) == len(awaitables) {
				return values, nil
			}
		}
	}
}

// FastAllUintSlicesOrError does the same as AllUintSlicesOrError but
// does not wait for all other tasks to stop. It does tell them to stop it just
// doesn't wait for them to stop.
func FastAllUintSlicesOrError(awaitables ...*task.UintSliceTask) ([][]uint, error) {
	v := make([]interface{}, len(awaitables))
	for i := range awaitables {
		v[i] = awaitables[i]
	}
	defer stop.AllAsync(stop.ToStopables(v...)...)

	errCh := make(chan error, 1)
	valueCh := make(chan []uint, 1)

	for _, awaitable := range awaitables {
		go func() {
			v, err := awaitable.Result()
			if err != nil {
				errCh <- errors.Wrap(err, 0)
				return
			}
			valueCh <- v
		}()
	}

	values := [][]uint{}
	for {
		select {
		case err := <-errCh:
			return nil, errors.Wrap(err, 0)
		case value := <-valueCh:
			values = append(values, value)
			if len(values) == len(awaitables) {
				return values, nil
			}
		}
	}
}

// AllUint16s will wait for every given task to emit a result.
// The results (& errors) will be returned in a slice ordered the
// same as the input.
func AllUint16s(awaitables ...*task.Uint16Task) ([]uint16, error) {
	awaited := []uint16{}
	awaitedErrors := []error{}

	for _, awaitable := range awaitables {
		v, e := awaitable.Result()
		awaited = append(awaited, v)
		awaitedErrors = append(awaitedErrors, e)
	}

	if len(awaitedErrors) > 0 {
		return nil, errors.New(&ErrTaskFailed{
			Errors: awaitedErrors,
		})
	}

	return awaited, nil
}

// AllUint16Slices will wait for every given task to emit a result.
// The results (& errors) will be returned in a slice ordered the
// same as the input.
func AllUint16Slices(awaitables ...*task.Uint16SliceTask) ([][]uint16, error) {
	awaited := [][]uint16{}
	awaitedErrors := []error{}

	for _, awaitable := range awaitables {
		v, e := awaitable.Result()
		awaited = append(awaited, v)
		awaitedErrors = append(awaitedErrors, e)
	}

	if len(awaitedErrors) > 0 {
		return nil, errors.New(&ErrTaskFailed{
			Errors: awaitedErrors,
		})
	}

	return awaited, nil
}

// AnyUint16 will wait for the first task to emit a result (or an error)
// and return that, canceling all other tasks.
func AnyUint16(awaitables ...*task.Uint16Task) (value uint16, err error) {
	v := make([]interface{}, len(awaitables))
	for i := range awaitables {
		v[i] = awaitables[i]
	}
	defer stop.All(stop.ToStopables(v...)...)

	type doneOnce struct {
		o  sync.Once
		ch chan struct{}
	}
	done := doneOnce{
		ch: make(chan struct{}, 1),
	}
	closeDone := func() {
		done.o.Do(func() {
			close(done.ch)
		})
	}

	for _, awaitable := range awaitables {
		go func() {
			defer closeDone()
			value, err = awaitable.Result()
		}()
	}

	<-done.ch
	return value, err
}

// FastAnyUint16 does the same as AnyUint16 but does not wait for all
// other tasks to stop. It does tell them to stop it just doesn't wait for
// them to stop.
func FastAnyUint16(awaitables ...*task.Uint16Task) (value uint16, err error) {
	v := make([]interface{}, len(awaitables))
	for i := range awaitables {
		v[i] = awaitables[i]
	}
	defer stop.AllAsync(stop.ToStopables(v...)...)

	type doneOnce struct {
		o  sync.Once
		ch chan struct{}
	}
	done := doneOnce{
		ch: make(chan struct{}, 1),
	}
	closeDone := func() {
		done.o.Do(func() {
			close(done.ch)
		})
	}

	for _, awaitable := range awaitables {
		go func() {
			defer closeDone()
			value, err = awaitable.Result()
		}()
	}

	<-done.ch
	return value, err
}

// AnyUint16Slice will wait for the first task to emit a result (or an error)
// and return that, canceling all other tasks.
func AnyUint16Slice(awaitables ...*task.Uint16SliceTask) (value []uint16, err error) {
	v := make([]interface{}, len(awaitables))
	for i := range awaitables {
		v[i] = awaitables[i]
	}
	defer stop.All(stop.ToStopables(v...)...)

	type doneOnce struct {
		o  sync.Once
		ch chan struct{}
	}
	done := doneOnce{
		ch: make(chan struct{}, 1),
	}
	closeDone := func() {
		done.o.Do(func() {
			close(done.ch)
		})
	}

	for _, awaitable := range awaitables {
		go func() {
			defer closeDone()
			value, err = awaitable.Result()
		}()
	}

	<-done.ch
	return value, err
}

// FastAnyUint16Slice does the same as AnyUint16Slice but does not wait
// for all other tasks to stop. It does tell them to stop it just doesn't wait
// for them to stop.
func FastAnyUint16Slice(awaitables ...*task.Uint16SliceTask) (value []uint16, err error) {
	v := make([]interface{}, len(awaitables))
	for i := range awaitables {
		v[i] = awaitables[i]
	}
	defer stop.AllAsync(stop.ToStopables(v...)...)

	type doneOnce struct {
		o  sync.Once
		ch chan struct{}
	}
	done := doneOnce{
		ch: make(chan struct{}, 1),
	}
	closeDone := func() {
		done.o.Do(func() {
			close(done.ch)
		})
	}

	for _, awaitable := range awaitables {
		go func() {
			defer closeDone()
			value, err = awaitable.Result()
		}()
	}

	<-done.ch
	return value, err
}

// AllUint16sOrError will wait for every given task to emit a result or
// return as soon as an error is encountered, canceling all other tasks.
func AllUint16sOrError(awaitables ...*task.Uint16Task) ([]uint16, error) {
	v := make([]interface{}, len(awaitables))
	for i := range awaitables {
		v[i] = awaitables[i]
	}
	defer stop.All(stop.ToStopables(v...)...)

	errCh := make(chan error, 1)
	valueCh := make(chan uint16, 1)

	for _, awaitable := range awaitables {
		go func() {
			v, err := awaitable.Result()
			if err != nil {
				errCh <- errors.Wrap(err, 0)
				return
			}
			valueCh <- v
		}()
	}

	values := []uint16{}
	for {
		select {
		case err := <-errCh:
			return nil, errors.Wrap(err, 0)
		case value := <-valueCh:
			values = append(values, value)
			if len(values) == len(awaitables) {
				return values, nil
			}
		}
	}
}

// FastAllUint16sOrError does the same as AllUint16sOrError but does not
// wait for all other tasks to stop. It does tell them to stop it just doesn't
// wait for them to stop.
func FastAllUint16sOrError(awaitables ...*task.Uint16Task) ([]uint16, error) {
	v := make([]interface{}, len(awaitables))
	for i := range awaitables {
		v[i] = awaitables[i]
	}
	defer stop.AllAsync(stop.ToStopables(v...)...)

	errCh := make(chan error, 1)
	valueCh := make(chan uint16, 1)

	for _, awaitable := range awaitables {
		go func() {
			v, err := awaitable.Result()
			if err != nil {
				errCh <- errors.Wrap(err, 0)
				return
			}
			valueCh <- v
		}()
	}

	values := []uint16{}
	for {
		select {
		case err := <-errCh:
			return nil, errors.Wrap(err, 0)
		case value := <-valueCh:
			values = append(values, value)
			if len(values) == len(awaitables) {
				return values, nil
			}
		}
	}
}

// AllUint16SlicesOrError will wait for every given task to emit a result or
// return as soon as an error is encountered, canceling all other tasks.
func AllUint16SlicesOrError(awaitables ...*task.Uint16SliceTask) ([][]uint16, error) {
	v := make([]interface{}, len(awaitables))
	for i := range awaitables {
		v[i] = awaitables[i]
	}
	defer stop.All(stop.ToStopables(v...)...)

	errCh := make(chan error, 1)
	valueCh := make(chan []uint16, 1)

	for _, awaitable := range awaitables {
		go func() {
			v, err := awaitable.Result()
			if err != nil {
				errCh <- errors.Wrap(err, 0)
				return
			}
			valueCh <- v
		}()
	}

	values := [][]uint16{}
	for {
		select {
		case err := <-errCh:
			return nil, errors.Wrap(err, 0)
		case value := <-valueCh:
			values = append(values, value)
			if len(values) == len(awaitables) {
				return values, nil
			}
		}
	}
}

// FastAllUint16SlicesOrError does the same as AllUint16SlicesOrError but
// does not wait for all other tasks to stop. It does tell them to stop it just
// doesn't wait for them to stop.
func FastAllUint16SlicesOrError(awaitables ...*task.Uint16SliceTask) ([][]uint16, error) {
	v := make([]interface{}, len(awaitables))
	for i := range awaitables {
		v[i] = awaitables[i]
	}
	defer stop.AllAsync(stop.ToStopables(v...)...)

	errCh := make(chan error, 1)
	valueCh := make(chan []uint16, 1)

	for _, awaitable := range awaitables {
		go func() {
			v, err := awaitable.Result()
			if err != nil {
				errCh <- errors.Wrap(err, 0)
				return
			}
			valueCh <- v
		}()
	}

	values := [][]uint16{}
	for {
		select {
		case err := <-errCh:
			return nil, errors.Wrap(err, 0)
		case value := <-valueCh:
			values = append(values, value)
			if len(values) == len(awaitables) {
				return values, nil
			}
		}
	}
}

// AllUint32s will wait for every given task to emit a result.
// The results (& errors) will be returned in a slice ordered the
// same as the input.
func AllUint32s(awaitables ...*task.Uint32Task) ([]uint32, error) {
	awaited := []uint32{}
	awaitedErrors := []error{}

	for _, awaitable := range awaitables {
		v, e := awaitable.Result()
		awaited = append(awaited, v)
		awaitedErrors = append(awaitedErrors, e)
	}

	if len(awaitedErrors) > 0 {
		return nil, errors.New(&ErrTaskFailed{
			Errors: awaitedErrors,
		})
	}

	return awaited, nil
}

// AllUint32Slices will wait for every given task to emit a result.
// The results (& errors) will be returned in a slice ordered the
// same as the input.
func AllUint32Slices(awaitables ...*task.Uint32SliceTask) ([][]uint32, error) {
	awaited := [][]uint32{}
	awaitedErrors := []error{}

	for _, awaitable := range awaitables {
		v, e := awaitable.Result()
		awaited = append(awaited, v)
		awaitedErrors = append(awaitedErrors, e)
	}

	if len(awaitedErrors) > 0 {
		return nil, errors.New(&ErrTaskFailed{
			Errors: awaitedErrors,
		})
	}

	return awaited, nil
}

// AnyUint32 will wait for the first task to emit a result (or an error)
// and return that, canceling all other tasks.
func AnyUint32(awaitables ...*task.Uint32Task) (value uint32, err error) {
	v := make([]interface{}, len(awaitables))
	for i := range awaitables {
		v[i] = awaitables[i]
	}
	defer stop.All(stop.ToStopables(v...)...)

	type doneOnce struct {
		o  sync.Once
		ch chan struct{}
	}
	done := doneOnce{
		ch: make(chan struct{}, 1),
	}
	closeDone := func() {
		done.o.Do(func() {
			close(done.ch)
		})
	}

	for _, awaitable := range awaitables {
		go func() {
			defer closeDone()
			value, err = awaitable.Result()
		}()
	}

	<-done.ch
	return value, err
}

// FastAnyUint32 does the same as AnyUint32 but does not wait for all
// other tasks to stop. It does tell them to stop it just doesn't wait for
// them to stop.
func FastAnyUint32(awaitables ...*task.Uint32Task) (value uint32, err error) {
	v := make([]interface{}, len(awaitables))
	for i := range awaitables {
		v[i] = awaitables[i]
	}
	defer stop.AllAsync(stop.ToStopables(v...)...)

	type doneOnce struct {
		o  sync.Once
		ch chan struct{}
	}
	done := doneOnce{
		ch: make(chan struct{}, 1),
	}
	closeDone := func() {
		done.o.Do(func() {
			close(done.ch)
		})
	}

	for _, awaitable := range awaitables {
		go func() {
			defer closeDone()
			value, err = awaitable.Result()
		}()
	}

	<-done.ch
	return value, err
}

// AnyUint32Slice will wait for the first task to emit a result (or an error)
// and return that, canceling all other tasks.
func AnyUint32Slice(awaitables ...*task.Uint32SliceTask) (value []uint32, err error) {
	v := make([]interface{}, len(awaitables))
	for i := range awaitables {
		v[i] = awaitables[i]
	}
	defer stop.All(stop.ToStopables(v...)...)

	type doneOnce struct {
		o  sync.Once
		ch chan struct{}
	}
	done := doneOnce{
		ch: make(chan struct{}, 1),
	}
	closeDone := func() {
		done.o.Do(func() {
			close(done.ch)
		})
	}

	for _, awaitable := range awaitables {
		go func() {
			defer closeDone()
			value, err = awaitable.Result()
		}()
	}

	<-done.ch
	return value, err
}

// FastAnyUint32Slice does the same as AnyUint32Slice but does not wait
// for all other tasks to stop. It does tell them to stop it just doesn't wait
// for them to stop.
func FastAnyUint32Slice(awaitables ...*task.Uint32SliceTask) (value []uint32, err error) {
	v := make([]interface{}, len(awaitables))
	for i := range awaitables {
		v[i] = awaitables[i]
	}
	defer stop.AllAsync(stop.ToStopables(v...)...)

	type doneOnce struct {
		o  sync.Once
		ch chan struct{}
	}
	done := doneOnce{
		ch: make(chan struct{}, 1),
	}
	closeDone := func() {
		done.o.Do(func() {
			close(done.ch)
		})
	}

	for _, awaitable := range awaitables {
		go func() {
			defer closeDone()
			value, err = awaitable.Result()
		}()
	}

	<-done.ch
	return value, err
}

// AllUint32sOrError will wait for every given task to emit a result or
// return as soon as an error is encountered, canceling all other tasks.
func AllUint32sOrError(awaitables ...*task.Uint32Task) ([]uint32, error) {
	v := make([]interface{}, len(awaitables))
	for i := range awaitables {
		v[i] = awaitables[i]
	}
	defer stop.All(stop.ToStopables(v...)...)

	errCh := make(chan error, 1)
	valueCh := make(chan uint32, 1)

	for _, awaitable := range awaitables {
		go func() {
			v, err := awaitable.Result()
			if err != nil {
				errCh <- errors.Wrap(err, 0)
				return
			}
			valueCh <- v
		}()
	}

	values := []uint32{}
	for {
		select {
		case err := <-errCh:
			return nil, errors.Wrap(err, 0)
		case value := <-valueCh:
			values = append(values, value)
			if len(values) == len(awaitables) {
				return values, nil
			}
		}
	}
}

// FastAllUint32sOrError does the same as AllUint32sOrError but does not
// wait for all other tasks to stop. It does tell them to stop it just doesn't
// wait for them to stop.
func FastAllUint32sOrError(awaitables ...*task.Uint32Task) ([]uint32, error) {
	v := make([]interface{}, len(awaitables))
	for i := range awaitables {
		v[i] = awaitables[i]
	}
	defer stop.AllAsync(stop.ToStopables(v...)...)

	errCh := make(chan error, 1)
	valueCh := make(chan uint32, 1)

	for _, awaitable := range awaitables {
		go func() {
			v, err := awaitable.Result()
			if err != nil {
				errCh <- errors.Wrap(err, 0)
				return
			}
			valueCh <- v
		}()
	}

	values := []uint32{}
	for {
		select {
		case err := <-errCh:
			return nil, errors.Wrap(err, 0)
		case value := <-valueCh:
			values = append(values, value)
			if len(values) == len(awaitables) {
				return values, nil
			}
		}
	}
}

// AllUint32SlicesOrError will wait for every given task to emit a result or
// return as soon as an error is encountered, canceling all other tasks.
func AllUint32SlicesOrError(awaitables ...*task.Uint32SliceTask) ([][]uint32, error) {
	v := make([]interface{}, len(awaitables))
	for i := range awaitables {
		v[i] = awaitables[i]
	}
	defer stop.All(stop.ToStopables(v...)...)

	errCh := make(chan error, 1)
	valueCh := make(chan []uint32, 1)

	for _, awaitable := range awaitables {
		go func() {
			v, err := awaitable.Result()
			if err != nil {
				errCh <- errors.Wrap(err, 0)
				return
			}
			valueCh <- v
		}()
	}

	values := [][]uint32{}
	for {
		select {
		case err := <-errCh:
			return nil, errors.Wrap(err, 0)
		case value := <-valueCh:
			values = append(values, value)
			if len(values) == len(awaitables) {
				return values, nil
			}
		}
	}
}

// FastAllUint32SlicesOrError does the same as AllUint32SlicesOrError but
// does not wait for all other tasks to stop. It does tell them to stop it just
// doesn't wait for them to stop.
func FastAllUint32SlicesOrError(awaitables ...*task.Uint32SliceTask) ([][]uint32, error) {
	v := make([]interface{}, len(awaitables))
	for i := range awaitables {
		v[i] = awaitables[i]
	}
	defer stop.AllAsync(stop.ToStopables(v...)...)

	errCh := make(chan error, 1)
	valueCh := make(chan []uint32, 1)

	for _, awaitable := range awaitables {
		go func() {
			v, err := awaitable.Result()
			if err != nil {
				errCh <- errors.Wrap(err, 0)
				return
			}
			valueCh <- v
		}()
	}

	values := [][]uint32{}
	for {
		select {
		case err := <-errCh:
			return nil, errors.Wrap(err, 0)
		case value := <-valueCh:
			values = append(values, value)
			if len(values) == len(awaitables) {
				return values, nil
			}
		}
	}
}

// AllUint64s will wait for every given task to emit a result.
// The results (& errors) will be returned in a slice ordered the
// same as the input.
func AllUint64s(awaitables ...*task.Uint64Task) ([]uint64, error) {
	awaited := []uint64{}
	awaitedErrors := []error{}

	for _, awaitable := range awaitables {
		v, e := awaitable.Result()
		awaited = append(awaited, v)
		awaitedErrors = append(awaitedErrors, e)
	}

	if len(awaitedErrors) > 0 {
		return nil, errors.New(&ErrTaskFailed{
			Errors: awaitedErrors,
		})
	}

	return awaited, nil
}

// AllUint64Slices will wait for every given task to emit a result.
// The results (& errors) will be returned in a slice ordered the
// same as the input.
func AllUint64Slices(awaitables ...*task.Uint64SliceTask) ([][]uint64, error) {
	awaited := [][]uint64{}
	awaitedErrors := []error{}

	for _, awaitable := range awaitables {
		v, e := awaitable.Result()
		awaited = append(awaited, v)
		awaitedErrors = append(awaitedErrors, e)
	}

	if len(awaitedErrors) > 0 {
		return nil, errors.New(&ErrTaskFailed{
			Errors: awaitedErrors,
		})
	}

	return awaited, nil
}

// AnyUint64 will wait for the first task to emit a result (or an error)
// and return that, canceling all other tasks.
func AnyUint64(awaitables ...*task.Uint64Task) (value uint64, err error) {
	v := make([]interface{}, len(awaitables))
	for i := range awaitables {
		v[i] = awaitables[i]
	}
	defer stop.All(stop.ToStopables(v...)...)

	type doneOnce struct {
		o  sync.Once
		ch chan struct{}
	}
	done := doneOnce{
		ch: make(chan struct{}, 1),
	}
	closeDone := func() {
		done.o.Do(func() {
			close(done.ch)
		})
	}

	for _, awaitable := range awaitables {
		go func() {
			defer closeDone()
			value, err = awaitable.Result()
		}()
	}

	<-done.ch
	return value, err
}

// FastAnyUint64 does the same as AnyUint64 but does not wait for all
// other tasks to stop. It does tell them to stop it just doesn't wait for
// them to stop.
func FastAnyUint64(awaitables ...*task.Uint64Task) (value uint64, err error) {
	v := make([]interface{}, len(awaitables))
	for i := range awaitables {
		v[i] = awaitables[i]
	}
	defer stop.AllAsync(stop.ToStopables(v...)...)

	type doneOnce struct {
		o  sync.Once
		ch chan struct{}
	}
	done := doneOnce{
		ch: make(chan struct{}, 1),
	}
	closeDone := func() {
		done.o.Do(func() {
			close(done.ch)
		})
	}

	for _, awaitable := range awaitables {
		go func() {
			defer closeDone()
			value, err = awaitable.Result()
		}()
	}

	<-done.ch
	return value, err
}

// AnyUint64Slice will wait for the first task to emit a result (or an error)
// and return that, canceling all other tasks.
func AnyUint64Slice(awaitables ...*task.Uint64SliceTask) (value []uint64, err error) {
	v := make([]interface{}, len(awaitables))
	for i := range awaitables {
		v[i] = awaitables[i]
	}
	defer stop.All(stop.ToStopables(v...)...)

	type doneOnce struct {
		o  sync.Once
		ch chan struct{}
	}
	done := doneOnce{
		ch: make(chan struct{}, 1),
	}
	closeDone := func() {
		done.o.Do(func() {
			close(done.ch)
		})
	}

	for _, awaitable := range awaitables {
		go func() {
			defer closeDone()
			value, err = awaitable.Result()
		}()
	}

	<-done.ch
	return value, err
}

// FastAnyUint64Slice does the same as AnyUint64Slice but does not wait
// for all other tasks to stop. It does tell them to stop it just doesn't wait
// for them to stop.
func FastAnyUint64Slice(awaitables ...*task.Uint64SliceTask) (value []uint64, err error) {
	v := make([]interface{}, len(awaitables))
	for i := range awaitables {
		v[i] = awaitables[i]
	}
	defer stop.AllAsync(stop.ToStopables(v...)...)

	type doneOnce struct {
		o  sync.Once
		ch chan struct{}
	}
	done := doneOnce{
		ch: make(chan struct{}, 1),
	}
	closeDone := func() {
		done.o.Do(func() {
			close(done.ch)
		})
	}

	for _, awaitable := range awaitables {
		go func() {
			defer closeDone()
			value, err = awaitable.Result()
		}()
	}

	<-done.ch
	return value, err
}

// AllUint64sOrError will wait for every given task to emit a result or
// return as soon as an error is encountered, canceling all other tasks.
func AllUint64sOrError(awaitables ...*task.Uint64Task) ([]uint64, error) {
	v := make([]interface{}, len(awaitables))
	for i := range awaitables {
		v[i] = awaitables[i]
	}
	defer stop.All(stop.ToStopables(v...)...)

	errCh := make(chan error, 1)
	valueCh := make(chan uint64, 1)

	for _, awaitable := range awaitables {
		go func() {
			v, err := awaitable.Result()
			if err != nil {
				errCh <- errors.Wrap(err, 0)
				return
			}
			valueCh <- v
		}()
	}

	values := []uint64{}
	for {
		select {
		case err := <-errCh:
			return nil, errors.Wrap(err, 0)
		case value := <-valueCh:
			values = append(values, value)
			if len(values) == len(awaitables) {
				return values, nil
			}
		}
	}
}

// FastAllUint64sOrError does the same as AllUint64sOrError but does not
// wait for all other tasks to stop. It does tell them to stop it just doesn't
// wait for them to stop.
func FastAllUint64sOrError(awaitables ...*task.Uint64Task) ([]uint64, error) {
	v := make([]interface{}, len(awaitables))
	for i := range awaitables {
		v[i] = awaitables[i]
	}
	defer stop.AllAsync(stop.ToStopables(v...)...)

	errCh := make(chan error, 1)
	valueCh := make(chan uint64, 1)

	for _, awaitable := range awaitables {
		go func() {
			v, err := awaitable.Result()
			if err != nil {
				errCh <- errors.Wrap(err, 0)
				return
			}
			valueCh <- v
		}()
	}

	values := []uint64{}
	for {
		select {
		case err := <-errCh:
			return nil, errors.Wrap(err, 0)
		case value := <-valueCh:
			values = append(values, value)
			if len(values) == len(awaitables) {
				return values, nil
			}
		}
	}
}

// AllUint64SlicesOrError will wait for every given task to emit a result or
// return as soon as an error is encountered, canceling all other tasks.
func AllUint64SlicesOrError(awaitables ...*task.Uint64SliceTask) ([][]uint64, error) {
	v := make([]interface{}, len(awaitables))
	for i := range awaitables {
		v[i] = awaitables[i]
	}
	defer stop.All(stop.ToStopables(v...)...)

	errCh := make(chan error, 1)
	valueCh := make(chan []uint64, 1)

	for _, awaitable := range awaitables {
		go func() {
			v, err := awaitable.Result()
			if err != nil {
				errCh <- errors.Wrap(err, 0)
				return
			}
			valueCh <- v
		}()
	}

	values := [][]uint64{}
	for {
		select {
		case err := <-errCh:
			return nil, errors.Wrap(err, 0)
		case value := <-valueCh:
			values = append(values, value)
			if len(values) == len(awaitables) {
				return values, nil
			}
		}
	}
}

// FastAllUint64SlicesOrError does the same as AllUint64SlicesOrError but
// does not wait for all other tasks to stop. It does tell them to stop it just
// doesn't wait for them to stop.
func FastAllUint64SlicesOrError(awaitables ...*task.Uint64SliceTask) ([][]uint64, error) {
	v := make([]interface{}, len(awaitables))
	for i := range awaitables {
		v[i] = awaitables[i]
	}
	defer stop.AllAsync(stop.ToStopables(v...)...)

	errCh := make(chan error, 1)
	valueCh := make(chan []uint64, 1)

	for _, awaitable := range awaitables {
		go func() {
			v, err := awaitable.Result()
			if err != nil {
				errCh <- errors.Wrap(err, 0)
				return
			}
			valueCh <- v
		}()
	}

	values := [][]uint64{}
	for {
		select {
		case err := <-errCh:
			return nil, errors.Wrap(err, 0)
		case value := <-valueCh:
			values = append(values, value)
			if len(values) == len(awaitables) {
				return values, nil
			}
		}
	}
}

// AllUint8s will wait for every given task to emit a result.
// The results (& errors) will be returned in a slice ordered the
// same as the input.
func AllUint8s(awaitables ...*task.Uint8Task) ([]uint8, error) {
	awaited := []uint8{}
	awaitedErrors := []error{}

	for _, awaitable := range awaitables {
		v, e := awaitable.Result()
		awaited = append(awaited, v)
		awaitedErrors = append(awaitedErrors, e)
	}

	if len(awaitedErrors) > 0 {
		return nil, errors.New(&ErrTaskFailed{
			Errors: awaitedErrors,
		})
	}

	return awaited, nil
}

// AllUint8Slices will wait for every given task to emit a result.
// The results (& errors) will be returned in a slice ordered the
// same as the input.
func AllUint8Slices(awaitables ...*task.Uint8SliceTask) ([][]uint8, error) {
	awaited := [][]uint8{}
	awaitedErrors := []error{}

	for _, awaitable := range awaitables {
		v, e := awaitable.Result()
		awaited = append(awaited, v)
		awaitedErrors = append(awaitedErrors, e)
	}

	if len(awaitedErrors) > 0 {
		return nil, errors.New(&ErrTaskFailed{
			Errors: awaitedErrors,
		})
	}

	return awaited, nil
}

// AnyUint8 will wait for the first task to emit a result (or an error)
// and return that, canceling all other tasks.
func AnyUint8(awaitables ...*task.Uint8Task) (value uint8, err error) {
	v := make([]interface{}, len(awaitables))
	for i := range awaitables {
		v[i] = awaitables[i]
	}
	defer stop.All(stop.ToStopables(v...)...)

	type doneOnce struct {
		o  sync.Once
		ch chan struct{}
	}
	done := doneOnce{
		ch: make(chan struct{}, 1),
	}
	closeDone := func() {
		done.o.Do(func() {
			close(done.ch)
		})
	}

	for _, awaitable := range awaitables {
		go func() {
			defer closeDone()
			value, err = awaitable.Result()
		}()
	}

	<-done.ch
	return value, err
}

// FastAnyUint8 does the same as AnyUint8 but does not wait for all
// other tasks to stop. It does tell them to stop it just doesn't wait for
// them to stop.
func FastAnyUint8(awaitables ...*task.Uint8Task) (value uint8, err error) {
	v := make([]interface{}, len(awaitables))
	for i := range awaitables {
		v[i] = awaitables[i]
	}
	defer stop.AllAsync(stop.ToStopables(v...)...)

	type doneOnce struct {
		o  sync.Once
		ch chan struct{}
	}
	done := doneOnce{
		ch: make(chan struct{}, 1),
	}
	closeDone := func() {
		done.o.Do(func() {
			close(done.ch)
		})
	}

	for _, awaitable := range awaitables {
		go func() {
			defer closeDone()
			value, err = awaitable.Result()
		}()
	}

	<-done.ch
	return value, err
}

// AnyUint8Slice will wait for the first task to emit a result (or an error)
// and return that, canceling all other tasks.
func AnyUint8Slice(awaitables ...*task.Uint8SliceTask) (value []uint8, err error) {
	v := make([]interface{}, len(awaitables))
	for i := range awaitables {
		v[i] = awaitables[i]
	}
	defer stop.All(stop.ToStopables(v...)...)

	type doneOnce struct {
		o  sync.Once
		ch chan struct{}
	}
	done := doneOnce{
		ch: make(chan struct{}, 1),
	}
	closeDone := func() {
		done.o.Do(func() {
			close(done.ch)
		})
	}

	for _, awaitable := range awaitables {
		go func() {
			defer closeDone()
			value, err = awaitable.Result()
		}()
	}

	<-done.ch
	return value, err
}

// FastAnyUint8Slice does the same as AnyUint8Slice but does not wait
// for all other tasks to stop. It does tell them to stop it just doesn't wait
// for them to stop.
func FastAnyUint8Slice(awaitables ...*task.Uint8SliceTask) (value []uint8, err error) {
	v := make([]interface{}, len(awaitables))
	for i := range awaitables {
		v[i] = awaitables[i]
	}
	defer stop.AllAsync(stop.ToStopables(v...)...)

	type doneOnce struct {
		o  sync.Once
		ch chan struct{}
	}
	done := doneOnce{
		ch: make(chan struct{}, 1),
	}
	closeDone := func() {
		done.o.Do(func() {
			close(done.ch)
		})
	}

	for _, awaitable := range awaitables {
		go func() {
			defer closeDone()
			value, err = awaitable.Result()
		}()
	}

	<-done.ch
	return value, err
}

// AllUint8sOrError will wait for every given task to emit a result or
// return as soon as an error is encountered, canceling all other tasks.
func AllUint8sOrError(awaitables ...*task.Uint8Task) ([]uint8, error) {
	v := make([]interface{}, len(awaitables))
	for i := range awaitables {
		v[i] = awaitables[i]
	}
	defer stop.All(stop.ToStopables(v...)...)

	errCh := make(chan error, 1)
	valueCh := make(chan uint8, 1)

	for _, awaitable := range awaitables {
		go func() {
			v, err := awaitable.Result()
			if err != nil {
				errCh <- errors.Wrap(err, 0)
				return
			}
			valueCh <- v
		}()
	}

	values := []uint8{}
	for {
		select {
		case err := <-errCh:
			return nil, errors.Wrap(err, 0)
		case value := <-valueCh:
			values = append(values, value)
			if len(values) == len(awaitables) {
				return values, nil
			}
		}
	}
}

// FastAllUint8sOrError does the same as AllUint8sOrError but does not
// wait for all other tasks to stop. It does tell them to stop it just doesn't
// wait for them to stop.
func FastAllUint8sOrError(awaitables ...*task.Uint8Task) ([]uint8, error) {
	v := make([]interface{}, len(awaitables))
	for i := range awaitables {
		v[i] = awaitables[i]
	}
	defer stop.AllAsync(stop.ToStopables(v...)...)

	errCh := make(chan error, 1)
	valueCh := make(chan uint8, 1)

	for _, awaitable := range awaitables {
		go func() {
			v, err := awaitable.Result()
			if err != nil {
				errCh <- errors.Wrap(err, 0)
				return
			}
			valueCh <- v
		}()
	}

	values := []uint8{}
	for {
		select {
		case err := <-errCh:
			return nil, errors.Wrap(err, 0)
		case value := <-valueCh:
			values = append(values, value)
			if len(values) == len(awaitables) {
				return values, nil
			}
		}
	}
}

// AllUint8SlicesOrError will wait for every given task to emit a result or
// return as soon as an error is encountered, canceling all other tasks.
func AllUint8SlicesOrError(awaitables ...*task.Uint8SliceTask) ([][]uint8, error) {
	v := make([]interface{}, len(awaitables))
	for i := range awaitables {
		v[i] = awaitables[i]
	}
	defer stop.All(stop.ToStopables(v...)...)

	errCh := make(chan error, 1)
	valueCh := make(chan []uint8, 1)

	for _, awaitable := range awaitables {
		go func() {
			v, err := awaitable.Result()
			if err != nil {
				errCh <- errors.Wrap(err, 0)
				return
			}
			valueCh <- v
		}()
	}

	values := [][]uint8{}
	for {
		select {
		case err := <-errCh:
			return nil, errors.Wrap(err, 0)
		case value := <-valueCh:
			values = append(values, value)
			if len(values) == len(awaitables) {
				return values, nil
			}
		}
	}
}

// FastAllUint8SlicesOrError does the same as AllUint8SlicesOrError but
// does not wait for all other tasks to stop. It does tell them to stop it just
// doesn't wait for them to stop.
func FastAllUint8SlicesOrError(awaitables ...*task.Uint8SliceTask) ([][]uint8, error) {
	v := make([]interface{}, len(awaitables))
	for i := range awaitables {
		v[i] = awaitables[i]
	}
	defer stop.AllAsync(stop.ToStopables(v...)...)

	errCh := make(chan error, 1)
	valueCh := make(chan []uint8, 1)

	for _, awaitable := range awaitables {
		go func() {
			v, err := awaitable.Result()
			if err != nil {
				errCh <- errors.Wrap(err, 0)
				return
			}
			valueCh <- v
		}()
	}

	values := [][]uint8{}
	for {
		select {
		case err := <-errCh:
			return nil, errors.Wrap(err, 0)
		case value := <-valueCh:
			values = append(values, value)
			if len(values) == len(awaitables) {
				return values, nil
			}
		}
	}
}

// AllUintptrs will wait for every given task to emit a result.
// The results (& errors) will be returned in a slice ordered the
// same as the input.
func AllUintptrs(awaitables ...*task.UintptrTask) ([]uintptr, error) {
	awaited := []uintptr{}
	awaitedErrors := []error{}

	for _, awaitable := range awaitables {
		v, e := awaitable.Result()
		awaited = append(awaited, v)
		awaitedErrors = append(awaitedErrors, e)
	}

	if len(awaitedErrors) > 0 {
		return nil, errors.New(&ErrTaskFailed{
			Errors: awaitedErrors,
		})
	}

	return awaited, nil
}

// AllUintptrSlices will wait for every given task to emit a result.
// The results (& errors) will be returned in a slice ordered the
// same as the input.
func AllUintptrSlices(awaitables ...*task.UintptrSliceTask) ([][]uintptr, error) {
	awaited := [][]uintptr{}
	awaitedErrors := []error{}

	for _, awaitable := range awaitables {
		v, e := awaitable.Result()
		awaited = append(awaited, v)
		awaitedErrors = append(awaitedErrors, e)
	}

	if len(awaitedErrors) > 0 {
		return nil, errors.New(&ErrTaskFailed{
			Errors: awaitedErrors,
		})
	}

	return awaited, nil
}

// AnyUintptr will wait for the first task to emit a result (or an error)
// and return that, canceling all other tasks.
func AnyUintptr(awaitables ...*task.UintptrTask) (value uintptr, err error) {
	v := make([]interface{}, len(awaitables))
	for i := range awaitables {
		v[i] = awaitables[i]
	}
	defer stop.All(stop.ToStopables(v...)...)

	type doneOnce struct {
		o  sync.Once
		ch chan struct{}
	}
	done := doneOnce{
		ch: make(chan struct{}, 1),
	}
	closeDone := func() {
		done.o.Do(func() {
			close(done.ch)
		})
	}

	for _, awaitable := range awaitables {
		go func() {
			defer closeDone()
			value, err = awaitable.Result()
		}()
	}

	<-done.ch
	return value, err
}

// FastAnyUintptr does the same as AnyUintptr but does not wait for all
// other tasks to stop. It does tell them to stop it just doesn't wait for
// them to stop.
func FastAnyUintptr(awaitables ...*task.UintptrTask) (value uintptr, err error) {
	v := make([]interface{}, len(awaitables))
	for i := range awaitables {
		v[i] = awaitables[i]
	}
	defer stop.AllAsync(stop.ToStopables(v...)...)

	type doneOnce struct {
		o  sync.Once
		ch chan struct{}
	}
	done := doneOnce{
		ch: make(chan struct{}, 1),
	}
	closeDone := func() {
		done.o.Do(func() {
			close(done.ch)
		})
	}

	for _, awaitable := range awaitables {
		go func() {
			defer closeDone()
			value, err = awaitable.Result()
		}()
	}

	<-done.ch
	return value, err
}

// AnyUintptrSlice will wait for the first task to emit a result (or an error)
// and return that, canceling all other tasks.
func AnyUintptrSlice(awaitables ...*task.UintptrSliceTask) (value []uintptr, err error) {
	v := make([]interface{}, len(awaitables))
	for i := range awaitables {
		v[i] = awaitables[i]
	}
	defer stop.All(stop.ToStopables(v...)...)

	type doneOnce struct {
		o  sync.Once
		ch chan struct{}
	}
	done := doneOnce{
		ch: make(chan struct{}, 1),
	}
	closeDone := func() {
		done.o.Do(func() {
			close(done.ch)
		})
	}

	for _, awaitable := range awaitables {
		go func() {
			defer closeDone()
			value, err = awaitable.Result()
		}()
	}

	<-done.ch
	return value, err
}

// FastAnyUintptrSlice does the same as AnyUintptrSlice but does not wait
// for all other tasks to stop. It does tell them to stop it just doesn't wait
// for them to stop.
func FastAnyUintptrSlice(awaitables ...*task.UintptrSliceTask) (value []uintptr, err error) {
	v := make([]interface{}, len(awaitables))
	for i := range awaitables {
		v[i] = awaitables[i]
	}
	defer stop.AllAsync(stop.ToStopables(v...)...)

	type doneOnce struct {
		o  sync.Once
		ch chan struct{}
	}
	done := doneOnce{
		ch: make(chan struct{}, 1),
	}
	closeDone := func() {
		done.o.Do(func() {
			close(done.ch)
		})
	}

	for _, awaitable := range awaitables {
		go func() {
			defer closeDone()
			value, err = awaitable.Result()
		}()
	}

	<-done.ch
	return value, err
}

// AllUintptrsOrError will wait for every given task to emit a result or
// return as soon as an error is encountered, canceling all other tasks.
func AllUintptrsOrError(awaitables ...*task.UintptrTask) ([]uintptr, error) {
	v := make([]interface{}, len(awaitables))
	for i := range awaitables {
		v[i] = awaitables[i]
	}
	defer stop.All(stop.ToStopables(v...)...)

	errCh := make(chan error, 1)
	valueCh := make(chan uintptr, 1)

	for _, awaitable := range awaitables {
		go func() {
			v, err := awaitable.Result()
			if err != nil {
				errCh <- errors.Wrap(err, 0)
				return
			}
			valueCh <- v
		}()
	}

	values := []uintptr{}
	for {
		select {
		case err := <-errCh:
			return nil, errors.Wrap(err, 0)
		case value := <-valueCh:
			values = append(values, value)
			if len(values) == len(awaitables) {
				return values, nil
			}
		}
	}
}

// FastAllUintptrsOrError does the same as AllUintptrsOrError but does not
// wait for all other tasks to stop. It does tell them to stop it just doesn't
// wait for them to stop.
func FastAllUintptrsOrError(awaitables ...*task.UintptrTask) ([]uintptr, error) {
	v := make([]interface{}, len(awaitables))
	for i := range awaitables {
		v[i] = awaitables[i]
	}
	defer stop.AllAsync(stop.ToStopables(v...)...)

	errCh := make(chan error, 1)
	valueCh := make(chan uintptr, 1)

	for _, awaitable := range awaitables {
		go func() {
			v, err := awaitable.Result()
			if err != nil {
				errCh <- errors.Wrap(err, 0)
				return
			}
			valueCh <- v
		}()
	}

	values := []uintptr{}
	for {
		select {
		case err := <-errCh:
			return nil, errors.Wrap(err, 0)
		case value := <-valueCh:
			values = append(values, value)
			if len(values) == len(awaitables) {
				return values, nil
			}
		}
	}
}

// AllUintptrSlicesOrError will wait for every given task to emit a result or
// return as soon as an error is encountered, canceling all other tasks.
func AllUintptrSlicesOrError(awaitables ...*task.UintptrSliceTask) ([][]uintptr, error) {
	v := make([]interface{}, len(awaitables))
	for i := range awaitables {
		v[i] = awaitables[i]
	}
	defer stop.All(stop.ToStopables(v...)...)

	errCh := make(chan error, 1)
	valueCh := make(chan []uintptr, 1)

	for _, awaitable := range awaitables {
		go func() {
			v, err := awaitable.Result()
			if err != nil {
				errCh <- errors.Wrap(err, 0)
				return
			}
			valueCh <- v
		}()
	}

	values := [][]uintptr{}
	for {
		select {
		case err := <-errCh:
			return nil, errors.Wrap(err, 0)
		case value := <-valueCh:
			values = append(values, value)
			if len(values) == len(awaitables) {
				return values, nil
			}
		}
	}
}

// FastAllUintptrSlicesOrError does the same as AllUintptrSlicesOrError but
// does not wait for all other tasks to stop. It does tell them to stop it just
// doesn't wait for them to stop.
func FastAllUintptrSlicesOrError(awaitables ...*task.UintptrSliceTask) ([][]uintptr, error) {
	v := make([]interface{}, len(awaitables))
	for i := range awaitables {
		v[i] = awaitables[i]
	}
	defer stop.AllAsync(stop.ToStopables(v...)...)

	errCh := make(chan error, 1)
	valueCh := make(chan []uintptr, 1)

	for _, awaitable := range awaitables {
		go func() {
			v, err := awaitable.Result()
			if err != nil {
				errCh <- errors.Wrap(err, 0)
				return
			}
			valueCh <- v
		}()
	}

	values := [][]uintptr{}
	for {
		select {
		case err := <-errCh:
			return nil, errors.Wrap(err, 0)
		case value := <-valueCh:
			values = append(values, value)
			if len(values) == len(awaitables) {
				return values, nil
			}
		}
	}
}
