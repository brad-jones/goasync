// This file was automatically generated by genny.
// Any changes will be lost if this file is regenerated.
// see https://github.com/cheekybits/genny

package await

// AllBools will wait for every given channel to emit a single result.
// The results will be returned in a slice ordered the same as the input channels.
func AllBools(awaitables ...<-chan bool) []bool {
	awaited := []bool{}
	for _, awaitable := range awaitables {
		awaited = append(awaited, <-awaitable)
	}
	return awaited
}

// AllBoolSlices will wait for every given channel to emit a single result.
// The results will be returned in a slice ordered the same as the input channels.
func AllBoolSlices(awaitables ...<-chan []bool) [][]bool {
	awaited := [][]bool{}
	for _, awaitable := range awaitables {
		awaited = append(awaited, <-awaitable)
	}
	return awaited
}

// AllBoolsAsync is an asynchronous version of AllBools
func AllBoolsAsync(awaitables ...<-chan bool) <-chan []bool {
	resolver := make(chan []bool, 1)
	go func() {
		resolver <- AllBools(awaitables...)
	}()
	return resolver
}

// AllBoolSlicesAsync is an asynchronous version of AllBoolSlices
func AllBoolSlicesAsync(awaitables ...<-chan []bool) <-chan [][]bool {
	resolver := make(chan [][]bool, 1)
	go func() {
		resolver <- AllBoolSlices(awaitables...)
	}()
	return resolver
}

// AnyBool will wait for the first channel to emit a single result
// and return that, ignoring all other channels.
func AnyBool(awaitables ...<-chan bool) bool {
	for {
		for _, awaitable := range awaitables {
			select {
			default:
			case awaited := <-awaitable:
				return awaited
			}
		}
	}
}

// AnyBoolSlice will wait for the first channel to emit a single result
// and return that, ignoring all other channels.
func AnyBoolSlice(awaitables ...<-chan []bool) []bool {
	for {
		for _, awaitable := range awaitables {
			select {
			default:
			case awaited := <-awaitable:
				return awaited
			}
		}
	}
}

// AnyBoolAsync is an asynchronous version of AnyBool.
func AnyBoolAsync(awaitables ...<-chan bool) <-chan bool {
	resolver := make(chan bool, 1)
	go func() {
		resolver <- AnyBool(awaitables...)
	}()
	return resolver
}

// AnyBoolSliceAsync is an asynchronous version of AnyBool.
func AnyBoolSliceAsync(awaitables ...<-chan []bool) <-chan []bool {
	resolver := make(chan []bool, 1)
	go func() {
		resolver <- AnyBoolSlice(awaitables...)
	}()
	return resolver
}

// AllBytes will wait for every given channel to emit a single result.
// The results will be returned in a slice ordered the same as the input channels.
func AllBytes(awaitables ...<-chan byte) []byte {
	awaited := []byte{}
	for _, awaitable := range awaitables {
		awaited = append(awaited, <-awaitable)
	}
	return awaited
}

// AllByteSlices will wait for every given channel to emit a single result.
// The results will be returned in a slice ordered the same as the input channels.
func AllByteSlices(awaitables ...<-chan []byte) [][]byte {
	awaited := [][]byte{}
	for _, awaitable := range awaitables {
		awaited = append(awaited, <-awaitable)
	}
	return awaited
}

// AllBytesAsync is an asynchronous version of AllBytes
func AllBytesAsync(awaitables ...<-chan byte) <-chan []byte {
	resolver := make(chan []byte, 1)
	go func() {
		resolver <- AllBytes(awaitables...)
	}()
	return resolver
}

// AllByteSlicesAsync is an asynchronous version of AllByteSlices
func AllByteSlicesAsync(awaitables ...<-chan []byte) <-chan [][]byte {
	resolver := make(chan [][]byte, 1)
	go func() {
		resolver <- AllByteSlices(awaitables...)
	}()
	return resolver
}

// AnyByte will wait for the first channel to emit a single result
// and return that, ignoring all other channels.
func AnyByte(awaitables ...<-chan byte) byte {
	for {
		for _, awaitable := range awaitables {
			select {
			default:
			case awaited := <-awaitable:
				return awaited
			}
		}
	}
}

// AnyByteSlice will wait for the first channel to emit a single result
// and return that, ignoring all other channels.
func AnyByteSlice(awaitables ...<-chan []byte) []byte {
	for {
		for _, awaitable := range awaitables {
			select {
			default:
			case awaited := <-awaitable:
				return awaited
			}
		}
	}
}

// AnyByteAsync is an asynchronous version of AnyByte.
func AnyByteAsync(awaitables ...<-chan byte) <-chan byte {
	resolver := make(chan byte, 1)
	go func() {
		resolver <- AnyByte(awaitables...)
	}()
	return resolver
}

// AnyByteSliceAsync is an asynchronous version of AnyByte.
func AnyByteSliceAsync(awaitables ...<-chan []byte) <-chan []byte {
	resolver := make(chan []byte, 1)
	go func() {
		resolver <- AnyByteSlice(awaitables...)
	}()
	return resolver
}

// AllComplex128s will wait for every given channel to emit a single result.
// The results will be returned in a slice ordered the same as the input channels.
func AllComplex128s(awaitables ...<-chan complex128) []complex128 {
	awaited := []complex128{}
	for _, awaitable := range awaitables {
		awaited = append(awaited, <-awaitable)
	}
	return awaited
}

// AllComplex128Slices will wait for every given channel to emit a single result.
// The results will be returned in a slice ordered the same as the input channels.
func AllComplex128Slices(awaitables ...<-chan []complex128) [][]complex128 {
	awaited := [][]complex128{}
	for _, awaitable := range awaitables {
		awaited = append(awaited, <-awaitable)
	}
	return awaited
}

// AllComplex128sAsync is an asynchronous version of AllComplex128s
func AllComplex128sAsync(awaitables ...<-chan complex128) <-chan []complex128 {
	resolver := make(chan []complex128, 1)
	go func() {
		resolver <- AllComplex128s(awaitables...)
	}()
	return resolver
}

// AllComplex128SlicesAsync is an asynchronous version of AllComplex128Slices
func AllComplex128SlicesAsync(awaitables ...<-chan []complex128) <-chan [][]complex128 {
	resolver := make(chan [][]complex128, 1)
	go func() {
		resolver <- AllComplex128Slices(awaitables...)
	}()
	return resolver
}

// AnyComplex128 will wait for the first channel to emit a single result
// and return that, ignoring all other channels.
func AnyComplex128(awaitables ...<-chan complex128) complex128 {
	for {
		for _, awaitable := range awaitables {
			select {
			default:
			case awaited := <-awaitable:
				return awaited
			}
		}
	}
}

// AnyComplex128Slice will wait for the first channel to emit a single result
// and return that, ignoring all other channels.
func AnyComplex128Slice(awaitables ...<-chan []complex128) []complex128 {
	for {
		for _, awaitable := range awaitables {
			select {
			default:
			case awaited := <-awaitable:
				return awaited
			}
		}
	}
}

// AnyComplex128Async is an asynchronous version of AnyComplex128.
func AnyComplex128Async(awaitables ...<-chan complex128) <-chan complex128 {
	resolver := make(chan complex128, 1)
	go func() {
		resolver <- AnyComplex128(awaitables...)
	}()
	return resolver
}

// AnyComplex128SliceAsync is an asynchronous version of AnyComplex128.
func AnyComplex128SliceAsync(awaitables ...<-chan []complex128) <-chan []complex128 {
	resolver := make(chan []complex128, 1)
	go func() {
		resolver <- AnyComplex128Slice(awaitables...)
	}()
	return resolver
}

// AllComplex64s will wait for every given channel to emit a single result.
// The results will be returned in a slice ordered the same as the input channels.
func AllComplex64s(awaitables ...<-chan complex64) []complex64 {
	awaited := []complex64{}
	for _, awaitable := range awaitables {
		awaited = append(awaited, <-awaitable)
	}
	return awaited
}

// AllComplex64Slices will wait for every given channel to emit a single result.
// The results will be returned in a slice ordered the same as the input channels.
func AllComplex64Slices(awaitables ...<-chan []complex64) [][]complex64 {
	awaited := [][]complex64{}
	for _, awaitable := range awaitables {
		awaited = append(awaited, <-awaitable)
	}
	return awaited
}

// AllComplex64sAsync is an asynchronous version of AllComplex64s
func AllComplex64sAsync(awaitables ...<-chan complex64) <-chan []complex64 {
	resolver := make(chan []complex64, 1)
	go func() {
		resolver <- AllComplex64s(awaitables...)
	}()
	return resolver
}

// AllComplex64SlicesAsync is an asynchronous version of AllComplex64Slices
func AllComplex64SlicesAsync(awaitables ...<-chan []complex64) <-chan [][]complex64 {
	resolver := make(chan [][]complex64, 1)
	go func() {
		resolver <- AllComplex64Slices(awaitables...)
	}()
	return resolver
}

// AnyComplex64 will wait for the first channel to emit a single result
// and return that, ignoring all other channels.
func AnyComplex64(awaitables ...<-chan complex64) complex64 {
	for {
		for _, awaitable := range awaitables {
			select {
			default:
			case awaited := <-awaitable:
				return awaited
			}
		}
	}
}

// AnyComplex64Slice will wait for the first channel to emit a single result
// and return that, ignoring all other channels.
func AnyComplex64Slice(awaitables ...<-chan []complex64) []complex64 {
	for {
		for _, awaitable := range awaitables {
			select {
			default:
			case awaited := <-awaitable:
				return awaited
			}
		}
	}
}

// AnyComplex64Async is an asynchronous version of AnyComplex64.
func AnyComplex64Async(awaitables ...<-chan complex64) <-chan complex64 {
	resolver := make(chan complex64, 1)
	go func() {
		resolver <- AnyComplex64(awaitables...)
	}()
	return resolver
}

// AnyComplex64SliceAsync is an asynchronous version of AnyComplex64.
func AnyComplex64SliceAsync(awaitables ...<-chan []complex64) <-chan []complex64 {
	resolver := make(chan []complex64, 1)
	go func() {
		resolver <- AnyComplex64Slice(awaitables...)
	}()
	return resolver
}

// AllErrors will wait for every given channel to emit a single result.
// The results will be returned in a slice ordered the same as the input channels.
func AllErrors(awaitables ...<-chan error) []error {
	awaited := []error{}
	for _, awaitable := range awaitables {
		awaited = append(awaited, <-awaitable)
	}
	return awaited
}

// AllErrorSlices will wait for every given channel to emit a single result.
// The results will be returned in a slice ordered the same as the input channels.
func AllErrorSlices(awaitables ...<-chan []error) [][]error {
	awaited := [][]error{}
	for _, awaitable := range awaitables {
		awaited = append(awaited, <-awaitable)
	}
	return awaited
}

// AllErrorsAsync is an asynchronous version of AllErrors
func AllErrorsAsync(awaitables ...<-chan error) <-chan []error {
	resolver := make(chan []error, 1)
	go func() {
		resolver <- AllErrors(awaitables...)
	}()
	return resolver
}

// AllErrorSlicesAsync is an asynchronous version of AllErrorSlices
func AllErrorSlicesAsync(awaitables ...<-chan []error) <-chan [][]error {
	resolver := make(chan [][]error, 1)
	go func() {
		resolver <- AllErrorSlices(awaitables...)
	}()
	return resolver
}

// AnyError will wait for the first channel to emit a single result
// and return that, ignoring all other channels.
func AnyError(awaitables ...<-chan error) error {
	for {
		for _, awaitable := range awaitables {
			select {
			default:
			case awaited := <-awaitable:
				return awaited
			}
		}
	}
}

// AnyErrorSlice will wait for the first channel to emit a single result
// and return that, ignoring all other channels.
func AnyErrorSlice(awaitables ...<-chan []error) []error {
	for {
		for _, awaitable := range awaitables {
			select {
			default:
			case awaited := <-awaitable:
				return awaited
			}
		}
	}
}

// AnyErrorAsync is an asynchronous version of AnyError.
func AnyErrorAsync(awaitables ...<-chan error) <-chan error {
	resolver := make(chan error, 1)
	go func() {
		resolver <- AnyError(awaitables...)
	}()
	return resolver
}

// AnyErrorSliceAsync is an asynchronous version of AnyError.
func AnyErrorSliceAsync(awaitables ...<-chan []error) <-chan []error {
	resolver := make(chan []error, 1)
	go func() {
		resolver <- AnyErrorSlice(awaitables...)
	}()
	return resolver
}

// AllFloat32s will wait for every given channel to emit a single result.
// The results will be returned in a slice ordered the same as the input channels.
func AllFloat32s(awaitables ...<-chan float32) []float32 {
	awaited := []float32{}
	for _, awaitable := range awaitables {
		awaited = append(awaited, <-awaitable)
	}
	return awaited
}

// AllFloat32Slices will wait for every given channel to emit a single result.
// The results will be returned in a slice ordered the same as the input channels.
func AllFloat32Slices(awaitables ...<-chan []float32) [][]float32 {
	awaited := [][]float32{}
	for _, awaitable := range awaitables {
		awaited = append(awaited, <-awaitable)
	}
	return awaited
}

// AllFloat32sAsync is an asynchronous version of AllFloat32s
func AllFloat32sAsync(awaitables ...<-chan float32) <-chan []float32 {
	resolver := make(chan []float32, 1)
	go func() {
		resolver <- AllFloat32s(awaitables...)
	}()
	return resolver
}

// AllFloat32SlicesAsync is an asynchronous version of AllFloat32Slices
func AllFloat32SlicesAsync(awaitables ...<-chan []float32) <-chan [][]float32 {
	resolver := make(chan [][]float32, 1)
	go func() {
		resolver <- AllFloat32Slices(awaitables...)
	}()
	return resolver
}

// AnyFloat32 will wait for the first channel to emit a single result
// and return that, ignoring all other channels.
func AnyFloat32(awaitables ...<-chan float32) float32 {
	for {
		for _, awaitable := range awaitables {
			select {
			default:
			case awaited := <-awaitable:
				return awaited
			}
		}
	}
}

// AnyFloat32Slice will wait for the first channel to emit a single result
// and return that, ignoring all other channels.
func AnyFloat32Slice(awaitables ...<-chan []float32) []float32 {
	for {
		for _, awaitable := range awaitables {
			select {
			default:
			case awaited := <-awaitable:
				return awaited
			}
		}
	}
}

// AnyFloat32Async is an asynchronous version of AnyFloat32.
func AnyFloat32Async(awaitables ...<-chan float32) <-chan float32 {
	resolver := make(chan float32, 1)
	go func() {
		resolver <- AnyFloat32(awaitables...)
	}()
	return resolver
}

// AnyFloat32SliceAsync is an asynchronous version of AnyFloat32.
func AnyFloat32SliceAsync(awaitables ...<-chan []float32) <-chan []float32 {
	resolver := make(chan []float32, 1)
	go func() {
		resolver <- AnyFloat32Slice(awaitables...)
	}()
	return resolver
}

// AllFloat64s will wait for every given channel to emit a single result.
// The results will be returned in a slice ordered the same as the input channels.
func AllFloat64s(awaitables ...<-chan float64) []float64 {
	awaited := []float64{}
	for _, awaitable := range awaitables {
		awaited = append(awaited, <-awaitable)
	}
	return awaited
}

// AllFloat64Slices will wait for every given channel to emit a single result.
// The results will be returned in a slice ordered the same as the input channels.
func AllFloat64Slices(awaitables ...<-chan []float64) [][]float64 {
	awaited := [][]float64{}
	for _, awaitable := range awaitables {
		awaited = append(awaited, <-awaitable)
	}
	return awaited
}

// AllFloat64sAsync is an asynchronous version of AllFloat64s
func AllFloat64sAsync(awaitables ...<-chan float64) <-chan []float64 {
	resolver := make(chan []float64, 1)
	go func() {
		resolver <- AllFloat64s(awaitables...)
	}()
	return resolver
}

// AllFloat64SlicesAsync is an asynchronous version of AllFloat64Slices
func AllFloat64SlicesAsync(awaitables ...<-chan []float64) <-chan [][]float64 {
	resolver := make(chan [][]float64, 1)
	go func() {
		resolver <- AllFloat64Slices(awaitables...)
	}()
	return resolver
}

// AnyFloat64 will wait for the first channel to emit a single result
// and return that, ignoring all other channels.
func AnyFloat64(awaitables ...<-chan float64) float64 {
	for {
		for _, awaitable := range awaitables {
			select {
			default:
			case awaited := <-awaitable:
				return awaited
			}
		}
	}
}

// AnyFloat64Slice will wait for the first channel to emit a single result
// and return that, ignoring all other channels.
func AnyFloat64Slice(awaitables ...<-chan []float64) []float64 {
	for {
		for _, awaitable := range awaitables {
			select {
			default:
			case awaited := <-awaitable:
				return awaited
			}
		}
	}
}

// AnyFloat64Async is an asynchronous version of AnyFloat64.
func AnyFloat64Async(awaitables ...<-chan float64) <-chan float64 {
	resolver := make(chan float64, 1)
	go func() {
		resolver <- AnyFloat64(awaitables...)
	}()
	return resolver
}

// AnyFloat64SliceAsync is an asynchronous version of AnyFloat64.
func AnyFloat64SliceAsync(awaitables ...<-chan []float64) <-chan []float64 {
	resolver := make(chan []float64, 1)
	go func() {
		resolver <- AnyFloat64Slice(awaitables...)
	}()
	return resolver
}

// AllInts will wait for every given channel to emit a single result.
// The results will be returned in a slice ordered the same as the input channels.
func AllInts(awaitables ...<-chan int) []int {
	awaited := []int{}
	for _, awaitable := range awaitables {
		awaited = append(awaited, <-awaitable)
	}
	return awaited
}

// AllIntSlices will wait for every given channel to emit a single result.
// The results will be returned in a slice ordered the same as the input channels.
func AllIntSlices(awaitables ...<-chan []int) [][]int {
	awaited := [][]int{}
	for _, awaitable := range awaitables {
		awaited = append(awaited, <-awaitable)
	}
	return awaited
}

// AllIntsAsync is an asynchronous version of AllInts
func AllIntsAsync(awaitables ...<-chan int) <-chan []int {
	resolver := make(chan []int, 1)
	go func() {
		resolver <- AllInts(awaitables...)
	}()
	return resolver
}

// AllIntSlicesAsync is an asynchronous version of AllIntSlices
func AllIntSlicesAsync(awaitables ...<-chan []int) <-chan [][]int {
	resolver := make(chan [][]int, 1)
	go func() {
		resolver <- AllIntSlices(awaitables...)
	}()
	return resolver
}

// AnyInt will wait for the first channel to emit a single result
// and return that, ignoring all other channels.
func AnyInt(awaitables ...<-chan int) int {
	for {
		for _, awaitable := range awaitables {
			select {
			default:
			case awaited := <-awaitable:
				return awaited
			}
		}
	}
}

// AnyIntSlice will wait for the first channel to emit a single result
// and return that, ignoring all other channels.
func AnyIntSlice(awaitables ...<-chan []int) []int {
	for {
		for _, awaitable := range awaitables {
			select {
			default:
			case awaited := <-awaitable:
				return awaited
			}
		}
	}
}

// AnyIntAsync is an asynchronous version of AnyInt.
func AnyIntAsync(awaitables ...<-chan int) <-chan int {
	resolver := make(chan int, 1)
	go func() {
		resolver <- AnyInt(awaitables...)
	}()
	return resolver
}

// AnyIntSliceAsync is an asynchronous version of AnyInt.
func AnyIntSliceAsync(awaitables ...<-chan []int) <-chan []int {
	resolver := make(chan []int, 1)
	go func() {
		resolver <- AnyIntSlice(awaitables...)
	}()
	return resolver
}

// AllInt16s will wait for every given channel to emit a single result.
// The results will be returned in a slice ordered the same as the input channels.
func AllInt16s(awaitables ...<-chan int16) []int16 {
	awaited := []int16{}
	for _, awaitable := range awaitables {
		awaited = append(awaited, <-awaitable)
	}
	return awaited
}

// AllInt16Slices will wait for every given channel to emit a single result.
// The results will be returned in a slice ordered the same as the input channels.
func AllInt16Slices(awaitables ...<-chan []int16) [][]int16 {
	awaited := [][]int16{}
	for _, awaitable := range awaitables {
		awaited = append(awaited, <-awaitable)
	}
	return awaited
}

// AllInt16sAsync is an asynchronous version of AllInt16s
func AllInt16sAsync(awaitables ...<-chan int16) <-chan []int16 {
	resolver := make(chan []int16, 1)
	go func() {
		resolver <- AllInt16s(awaitables...)
	}()
	return resolver
}

// AllInt16SlicesAsync is an asynchronous version of AllInt16Slices
func AllInt16SlicesAsync(awaitables ...<-chan []int16) <-chan [][]int16 {
	resolver := make(chan [][]int16, 1)
	go func() {
		resolver <- AllInt16Slices(awaitables...)
	}()
	return resolver
}

// AnyInt16 will wait for the first channel to emit a single result
// and return that, ignoring all other channels.
func AnyInt16(awaitables ...<-chan int16) int16 {
	for {
		for _, awaitable := range awaitables {
			select {
			default:
			case awaited := <-awaitable:
				return awaited
			}
		}
	}
}

// AnyInt16Slice will wait for the first channel to emit a single result
// and return that, ignoring all other channels.
func AnyInt16Slice(awaitables ...<-chan []int16) []int16 {
	for {
		for _, awaitable := range awaitables {
			select {
			default:
			case awaited := <-awaitable:
				return awaited
			}
		}
	}
}

// AnyInt16Async is an asynchronous version of AnyInt16.
func AnyInt16Async(awaitables ...<-chan int16) <-chan int16 {
	resolver := make(chan int16, 1)
	go func() {
		resolver <- AnyInt16(awaitables...)
	}()
	return resolver
}

// AnyInt16SliceAsync is an asynchronous version of AnyInt16.
func AnyInt16SliceAsync(awaitables ...<-chan []int16) <-chan []int16 {
	resolver := make(chan []int16, 1)
	go func() {
		resolver <- AnyInt16Slice(awaitables...)
	}()
	return resolver
}

// AllInt32s will wait for every given channel to emit a single result.
// The results will be returned in a slice ordered the same as the input channels.
func AllInt32s(awaitables ...<-chan int32) []int32 {
	awaited := []int32{}
	for _, awaitable := range awaitables {
		awaited = append(awaited, <-awaitable)
	}
	return awaited
}

// AllInt32Slices will wait for every given channel to emit a single result.
// The results will be returned in a slice ordered the same as the input channels.
func AllInt32Slices(awaitables ...<-chan []int32) [][]int32 {
	awaited := [][]int32{}
	for _, awaitable := range awaitables {
		awaited = append(awaited, <-awaitable)
	}
	return awaited
}

// AllInt32sAsync is an asynchronous version of AllInt32s
func AllInt32sAsync(awaitables ...<-chan int32) <-chan []int32 {
	resolver := make(chan []int32, 1)
	go func() {
		resolver <- AllInt32s(awaitables...)
	}()
	return resolver
}

// AllInt32SlicesAsync is an asynchronous version of AllInt32Slices
func AllInt32SlicesAsync(awaitables ...<-chan []int32) <-chan [][]int32 {
	resolver := make(chan [][]int32, 1)
	go func() {
		resolver <- AllInt32Slices(awaitables...)
	}()
	return resolver
}

// AnyInt32 will wait for the first channel to emit a single result
// and return that, ignoring all other channels.
func AnyInt32(awaitables ...<-chan int32) int32 {
	for {
		for _, awaitable := range awaitables {
			select {
			default:
			case awaited := <-awaitable:
				return awaited
			}
		}
	}
}

// AnyInt32Slice will wait for the first channel to emit a single result
// and return that, ignoring all other channels.
func AnyInt32Slice(awaitables ...<-chan []int32) []int32 {
	for {
		for _, awaitable := range awaitables {
			select {
			default:
			case awaited := <-awaitable:
				return awaited
			}
		}
	}
}

// AnyInt32Async is an asynchronous version of AnyInt32.
func AnyInt32Async(awaitables ...<-chan int32) <-chan int32 {
	resolver := make(chan int32, 1)
	go func() {
		resolver <- AnyInt32(awaitables...)
	}()
	return resolver
}

// AnyInt32SliceAsync is an asynchronous version of AnyInt32.
func AnyInt32SliceAsync(awaitables ...<-chan []int32) <-chan []int32 {
	resolver := make(chan []int32, 1)
	go func() {
		resolver <- AnyInt32Slice(awaitables...)
	}()
	return resolver
}

// AllInt64s will wait for every given channel to emit a single result.
// The results will be returned in a slice ordered the same as the input channels.
func AllInt64s(awaitables ...<-chan int64) []int64 {
	awaited := []int64{}
	for _, awaitable := range awaitables {
		awaited = append(awaited, <-awaitable)
	}
	return awaited
}

// AllInt64Slices will wait for every given channel to emit a single result.
// The results will be returned in a slice ordered the same as the input channels.
func AllInt64Slices(awaitables ...<-chan []int64) [][]int64 {
	awaited := [][]int64{}
	for _, awaitable := range awaitables {
		awaited = append(awaited, <-awaitable)
	}
	return awaited
}

// AllInt64sAsync is an asynchronous version of AllInt64s
func AllInt64sAsync(awaitables ...<-chan int64) <-chan []int64 {
	resolver := make(chan []int64, 1)
	go func() {
		resolver <- AllInt64s(awaitables...)
	}()
	return resolver
}

// AllInt64SlicesAsync is an asynchronous version of AllInt64Slices
func AllInt64SlicesAsync(awaitables ...<-chan []int64) <-chan [][]int64 {
	resolver := make(chan [][]int64, 1)
	go func() {
		resolver <- AllInt64Slices(awaitables...)
	}()
	return resolver
}

// AnyInt64 will wait for the first channel to emit a single result
// and return that, ignoring all other channels.
func AnyInt64(awaitables ...<-chan int64) int64 {
	for {
		for _, awaitable := range awaitables {
			select {
			default:
			case awaited := <-awaitable:
				return awaited
			}
		}
	}
}

// AnyInt64Slice will wait for the first channel to emit a single result
// and return that, ignoring all other channels.
func AnyInt64Slice(awaitables ...<-chan []int64) []int64 {
	for {
		for _, awaitable := range awaitables {
			select {
			default:
			case awaited := <-awaitable:
				return awaited
			}
		}
	}
}

// AnyInt64Async is an asynchronous version of AnyInt64.
func AnyInt64Async(awaitables ...<-chan int64) <-chan int64 {
	resolver := make(chan int64, 1)
	go func() {
		resolver <- AnyInt64(awaitables...)
	}()
	return resolver
}

// AnyInt64SliceAsync is an asynchronous version of AnyInt64.
func AnyInt64SliceAsync(awaitables ...<-chan []int64) <-chan []int64 {
	resolver := make(chan []int64, 1)
	go func() {
		resolver <- AnyInt64Slice(awaitables...)
	}()
	return resolver
}

// AllInt8s will wait for every given channel to emit a single result.
// The results will be returned in a slice ordered the same as the input channels.
func AllInt8s(awaitables ...<-chan int8) []int8 {
	awaited := []int8{}
	for _, awaitable := range awaitables {
		awaited = append(awaited, <-awaitable)
	}
	return awaited
}

// AllInt8Slices will wait for every given channel to emit a single result.
// The results will be returned in a slice ordered the same as the input channels.
func AllInt8Slices(awaitables ...<-chan []int8) [][]int8 {
	awaited := [][]int8{}
	for _, awaitable := range awaitables {
		awaited = append(awaited, <-awaitable)
	}
	return awaited
}

// AllInt8sAsync is an asynchronous version of AllInt8s
func AllInt8sAsync(awaitables ...<-chan int8) <-chan []int8 {
	resolver := make(chan []int8, 1)
	go func() {
		resolver <- AllInt8s(awaitables...)
	}()
	return resolver
}

// AllInt8SlicesAsync is an asynchronous version of AllInt8Slices
func AllInt8SlicesAsync(awaitables ...<-chan []int8) <-chan [][]int8 {
	resolver := make(chan [][]int8, 1)
	go func() {
		resolver <- AllInt8Slices(awaitables...)
	}()
	return resolver
}

// AnyInt8 will wait for the first channel to emit a single result
// and return that, ignoring all other channels.
func AnyInt8(awaitables ...<-chan int8) int8 {
	for {
		for _, awaitable := range awaitables {
			select {
			default:
			case awaited := <-awaitable:
				return awaited
			}
		}
	}
}

// AnyInt8Slice will wait for the first channel to emit a single result
// and return that, ignoring all other channels.
func AnyInt8Slice(awaitables ...<-chan []int8) []int8 {
	for {
		for _, awaitable := range awaitables {
			select {
			default:
			case awaited := <-awaitable:
				return awaited
			}
		}
	}
}

// AnyInt8Async is an asynchronous version of AnyInt8.
func AnyInt8Async(awaitables ...<-chan int8) <-chan int8 {
	resolver := make(chan int8, 1)
	go func() {
		resolver <- AnyInt8(awaitables...)
	}()
	return resolver
}

// AnyInt8SliceAsync is an asynchronous version of AnyInt8.
func AnyInt8SliceAsync(awaitables ...<-chan []int8) <-chan []int8 {
	resolver := make(chan []int8, 1)
	go func() {
		resolver <- AnyInt8Slice(awaitables...)
	}()
	return resolver
}

// AllRunes will wait for every given channel to emit a single result.
// The results will be returned in a slice ordered the same as the input channels.
func AllRunes(awaitables ...<-chan rune) []rune {
	awaited := []rune{}
	for _, awaitable := range awaitables {
		awaited = append(awaited, <-awaitable)
	}
	return awaited
}

// AllRuneSlices will wait for every given channel to emit a single result.
// The results will be returned in a slice ordered the same as the input channels.
func AllRuneSlices(awaitables ...<-chan []rune) [][]rune {
	awaited := [][]rune{}
	for _, awaitable := range awaitables {
		awaited = append(awaited, <-awaitable)
	}
	return awaited
}

// AllRunesAsync is an asynchronous version of AllRunes
func AllRunesAsync(awaitables ...<-chan rune) <-chan []rune {
	resolver := make(chan []rune, 1)
	go func() {
		resolver <- AllRunes(awaitables...)
	}()
	return resolver
}

// AllRuneSlicesAsync is an asynchronous version of AllRuneSlices
func AllRuneSlicesAsync(awaitables ...<-chan []rune) <-chan [][]rune {
	resolver := make(chan [][]rune, 1)
	go func() {
		resolver <- AllRuneSlices(awaitables...)
	}()
	return resolver
}

// AnyRune will wait for the first channel to emit a single result
// and return that, ignoring all other channels.
func AnyRune(awaitables ...<-chan rune) rune {
	for {
		for _, awaitable := range awaitables {
			select {
			default:
			case awaited := <-awaitable:
				return awaited
			}
		}
	}
}

// AnyRuneSlice will wait for the first channel to emit a single result
// and return that, ignoring all other channels.
func AnyRuneSlice(awaitables ...<-chan []rune) []rune {
	for {
		for _, awaitable := range awaitables {
			select {
			default:
			case awaited := <-awaitable:
				return awaited
			}
		}
	}
}

// AnyRuneAsync is an asynchronous version of AnyRune.
func AnyRuneAsync(awaitables ...<-chan rune) <-chan rune {
	resolver := make(chan rune, 1)
	go func() {
		resolver <- AnyRune(awaitables...)
	}()
	return resolver
}

// AnyRuneSliceAsync is an asynchronous version of AnyRune.
func AnyRuneSliceAsync(awaitables ...<-chan []rune) <-chan []rune {
	resolver := make(chan []rune, 1)
	go func() {
		resolver <- AnyRuneSlice(awaitables...)
	}()
	return resolver
}

// AllStrings will wait for every given channel to emit a single result.
// The results will be returned in a slice ordered the same as the input channels.
func AllStrings(awaitables ...<-chan string) []string {
	awaited := []string{}
	for _, awaitable := range awaitables {
		awaited = append(awaited, <-awaitable)
	}
	return awaited
}

// AllStringSlices will wait for every given channel to emit a single result.
// The results will be returned in a slice ordered the same as the input channels.
func AllStringSlices(awaitables ...<-chan []string) [][]string {
	awaited := [][]string{}
	for _, awaitable := range awaitables {
		awaited = append(awaited, <-awaitable)
	}
	return awaited
}

// AllStringsAsync is an asynchronous version of AllStrings
func AllStringsAsync(awaitables ...<-chan string) <-chan []string {
	resolver := make(chan []string, 1)
	go func() {
		resolver <- AllStrings(awaitables...)
	}()
	return resolver
}

// AllStringSlicesAsync is an asynchronous version of AllStringSlices
func AllStringSlicesAsync(awaitables ...<-chan []string) <-chan [][]string {
	resolver := make(chan [][]string, 1)
	go func() {
		resolver <- AllStringSlices(awaitables...)
	}()
	return resolver
}

// AnyString will wait for the first channel to emit a single result
// and return that, ignoring all other channels.
func AnyString(awaitables ...<-chan string) string {
	for {
		for _, awaitable := range awaitables {
			select {
			default:
			case awaited := <-awaitable:
				return awaited
			}
		}
	}
}

// AnyStringSlice will wait for the first channel to emit a single result
// and return that, ignoring all other channels.
func AnyStringSlice(awaitables ...<-chan []string) []string {
	for {
		for _, awaitable := range awaitables {
			select {
			default:
			case awaited := <-awaitable:
				return awaited
			}
		}
	}
}

// AnyStringAsync is an asynchronous version of AnyString.
func AnyStringAsync(awaitables ...<-chan string) <-chan string {
	resolver := make(chan string, 1)
	go func() {
		resolver <- AnyString(awaitables...)
	}()
	return resolver
}

// AnyStringSliceAsync is an asynchronous version of AnyString.
func AnyStringSliceAsync(awaitables ...<-chan []string) <-chan []string {
	resolver := make(chan []string, 1)
	go func() {
		resolver <- AnyStringSlice(awaitables...)
	}()
	return resolver
}

// AllUints will wait for every given channel to emit a single result.
// The results will be returned in a slice ordered the same as the input channels.
func AllUints(awaitables ...<-chan uint) []uint {
	awaited := []uint{}
	for _, awaitable := range awaitables {
		awaited = append(awaited, <-awaitable)
	}
	return awaited
}

// AllUintSlices will wait for every given channel to emit a single result.
// The results will be returned in a slice ordered the same as the input channels.
func AllUintSlices(awaitables ...<-chan []uint) [][]uint {
	awaited := [][]uint{}
	for _, awaitable := range awaitables {
		awaited = append(awaited, <-awaitable)
	}
	return awaited
}

// AllUintsAsync is an asynchronous version of AllUints
func AllUintsAsync(awaitables ...<-chan uint) <-chan []uint {
	resolver := make(chan []uint, 1)
	go func() {
		resolver <- AllUints(awaitables...)
	}()
	return resolver
}

// AllUintSlicesAsync is an asynchronous version of AllUintSlices
func AllUintSlicesAsync(awaitables ...<-chan []uint) <-chan [][]uint {
	resolver := make(chan [][]uint, 1)
	go func() {
		resolver <- AllUintSlices(awaitables...)
	}()
	return resolver
}

// AnyUint will wait for the first channel to emit a single result
// and return that, ignoring all other channels.
func AnyUint(awaitables ...<-chan uint) uint {
	for {
		for _, awaitable := range awaitables {
			select {
			default:
			case awaited := <-awaitable:
				return awaited
			}
		}
	}
}

// AnyUintSlice will wait for the first channel to emit a single result
// and return that, ignoring all other channels.
func AnyUintSlice(awaitables ...<-chan []uint) []uint {
	for {
		for _, awaitable := range awaitables {
			select {
			default:
			case awaited := <-awaitable:
				return awaited
			}
		}
	}
}

// AnyUintAsync is an asynchronous version of AnyUint.
func AnyUintAsync(awaitables ...<-chan uint) <-chan uint {
	resolver := make(chan uint, 1)
	go func() {
		resolver <- AnyUint(awaitables...)
	}()
	return resolver
}

// AnyUintSliceAsync is an asynchronous version of AnyUint.
func AnyUintSliceAsync(awaitables ...<-chan []uint) <-chan []uint {
	resolver := make(chan []uint, 1)
	go func() {
		resolver <- AnyUintSlice(awaitables...)
	}()
	return resolver
}

// AllUint16s will wait for every given channel to emit a single result.
// The results will be returned in a slice ordered the same as the input channels.
func AllUint16s(awaitables ...<-chan uint16) []uint16 {
	awaited := []uint16{}
	for _, awaitable := range awaitables {
		awaited = append(awaited, <-awaitable)
	}
	return awaited
}

// AllUint16Slices will wait for every given channel to emit a single result.
// The results will be returned in a slice ordered the same as the input channels.
func AllUint16Slices(awaitables ...<-chan []uint16) [][]uint16 {
	awaited := [][]uint16{}
	for _, awaitable := range awaitables {
		awaited = append(awaited, <-awaitable)
	}
	return awaited
}

// AllUint16sAsync is an asynchronous version of AllUint16s
func AllUint16sAsync(awaitables ...<-chan uint16) <-chan []uint16 {
	resolver := make(chan []uint16, 1)
	go func() {
		resolver <- AllUint16s(awaitables...)
	}()
	return resolver
}

// AllUint16SlicesAsync is an asynchronous version of AllUint16Slices
func AllUint16SlicesAsync(awaitables ...<-chan []uint16) <-chan [][]uint16 {
	resolver := make(chan [][]uint16, 1)
	go func() {
		resolver <- AllUint16Slices(awaitables...)
	}()
	return resolver
}

// AnyUint16 will wait for the first channel to emit a single result
// and return that, ignoring all other channels.
func AnyUint16(awaitables ...<-chan uint16) uint16 {
	for {
		for _, awaitable := range awaitables {
			select {
			default:
			case awaited := <-awaitable:
				return awaited
			}
		}
	}
}

// AnyUint16Slice will wait for the first channel to emit a single result
// and return that, ignoring all other channels.
func AnyUint16Slice(awaitables ...<-chan []uint16) []uint16 {
	for {
		for _, awaitable := range awaitables {
			select {
			default:
			case awaited := <-awaitable:
				return awaited
			}
		}
	}
}

// AnyUint16Async is an asynchronous version of AnyUint16.
func AnyUint16Async(awaitables ...<-chan uint16) <-chan uint16 {
	resolver := make(chan uint16, 1)
	go func() {
		resolver <- AnyUint16(awaitables...)
	}()
	return resolver
}

// AnyUint16SliceAsync is an asynchronous version of AnyUint16.
func AnyUint16SliceAsync(awaitables ...<-chan []uint16) <-chan []uint16 {
	resolver := make(chan []uint16, 1)
	go func() {
		resolver <- AnyUint16Slice(awaitables...)
	}()
	return resolver
}

// AllUint32s will wait for every given channel to emit a single result.
// The results will be returned in a slice ordered the same as the input channels.
func AllUint32s(awaitables ...<-chan uint32) []uint32 {
	awaited := []uint32{}
	for _, awaitable := range awaitables {
		awaited = append(awaited, <-awaitable)
	}
	return awaited
}

// AllUint32Slices will wait for every given channel to emit a single result.
// The results will be returned in a slice ordered the same as the input channels.
func AllUint32Slices(awaitables ...<-chan []uint32) [][]uint32 {
	awaited := [][]uint32{}
	for _, awaitable := range awaitables {
		awaited = append(awaited, <-awaitable)
	}
	return awaited
}

// AllUint32sAsync is an asynchronous version of AllUint32s
func AllUint32sAsync(awaitables ...<-chan uint32) <-chan []uint32 {
	resolver := make(chan []uint32, 1)
	go func() {
		resolver <- AllUint32s(awaitables...)
	}()
	return resolver
}

// AllUint32SlicesAsync is an asynchronous version of AllUint32Slices
func AllUint32SlicesAsync(awaitables ...<-chan []uint32) <-chan [][]uint32 {
	resolver := make(chan [][]uint32, 1)
	go func() {
		resolver <- AllUint32Slices(awaitables...)
	}()
	return resolver
}

// AnyUint32 will wait for the first channel to emit a single result
// and return that, ignoring all other channels.
func AnyUint32(awaitables ...<-chan uint32) uint32 {
	for {
		for _, awaitable := range awaitables {
			select {
			default:
			case awaited := <-awaitable:
				return awaited
			}
		}
	}
}

// AnyUint32Slice will wait for the first channel to emit a single result
// and return that, ignoring all other channels.
func AnyUint32Slice(awaitables ...<-chan []uint32) []uint32 {
	for {
		for _, awaitable := range awaitables {
			select {
			default:
			case awaited := <-awaitable:
				return awaited
			}
		}
	}
}

// AnyUint32Async is an asynchronous version of AnyUint32.
func AnyUint32Async(awaitables ...<-chan uint32) <-chan uint32 {
	resolver := make(chan uint32, 1)
	go func() {
		resolver <- AnyUint32(awaitables...)
	}()
	return resolver
}

// AnyUint32SliceAsync is an asynchronous version of AnyUint32.
func AnyUint32SliceAsync(awaitables ...<-chan []uint32) <-chan []uint32 {
	resolver := make(chan []uint32, 1)
	go func() {
		resolver <- AnyUint32Slice(awaitables...)
	}()
	return resolver
}

// AllUint64s will wait for every given channel to emit a single result.
// The results will be returned in a slice ordered the same as the input channels.
func AllUint64s(awaitables ...<-chan uint64) []uint64 {
	awaited := []uint64{}
	for _, awaitable := range awaitables {
		awaited = append(awaited, <-awaitable)
	}
	return awaited
}

// AllUint64Slices will wait for every given channel to emit a single result.
// The results will be returned in a slice ordered the same as the input channels.
func AllUint64Slices(awaitables ...<-chan []uint64) [][]uint64 {
	awaited := [][]uint64{}
	for _, awaitable := range awaitables {
		awaited = append(awaited, <-awaitable)
	}
	return awaited
}

// AllUint64sAsync is an asynchronous version of AllUint64s
func AllUint64sAsync(awaitables ...<-chan uint64) <-chan []uint64 {
	resolver := make(chan []uint64, 1)
	go func() {
		resolver <- AllUint64s(awaitables...)
	}()
	return resolver
}

// AllUint64SlicesAsync is an asynchronous version of AllUint64Slices
func AllUint64SlicesAsync(awaitables ...<-chan []uint64) <-chan [][]uint64 {
	resolver := make(chan [][]uint64, 1)
	go func() {
		resolver <- AllUint64Slices(awaitables...)
	}()
	return resolver
}

// AnyUint64 will wait for the first channel to emit a single result
// and return that, ignoring all other channels.
func AnyUint64(awaitables ...<-chan uint64) uint64 {
	for {
		for _, awaitable := range awaitables {
			select {
			default:
			case awaited := <-awaitable:
				return awaited
			}
		}
	}
}

// AnyUint64Slice will wait for the first channel to emit a single result
// and return that, ignoring all other channels.
func AnyUint64Slice(awaitables ...<-chan []uint64) []uint64 {
	for {
		for _, awaitable := range awaitables {
			select {
			default:
			case awaited := <-awaitable:
				return awaited
			}
		}
	}
}

// AnyUint64Async is an asynchronous version of AnyUint64.
func AnyUint64Async(awaitables ...<-chan uint64) <-chan uint64 {
	resolver := make(chan uint64, 1)
	go func() {
		resolver <- AnyUint64(awaitables...)
	}()
	return resolver
}

// AnyUint64SliceAsync is an asynchronous version of AnyUint64.
func AnyUint64SliceAsync(awaitables ...<-chan []uint64) <-chan []uint64 {
	resolver := make(chan []uint64, 1)
	go func() {
		resolver <- AnyUint64Slice(awaitables...)
	}()
	return resolver
}

// AllUint8s will wait for every given channel to emit a single result.
// The results will be returned in a slice ordered the same as the input channels.
func AllUint8s(awaitables ...<-chan uint8) []uint8 {
	awaited := []uint8{}
	for _, awaitable := range awaitables {
		awaited = append(awaited, <-awaitable)
	}
	return awaited
}

// AllUint8Slices will wait for every given channel to emit a single result.
// The results will be returned in a slice ordered the same as the input channels.
func AllUint8Slices(awaitables ...<-chan []uint8) [][]uint8 {
	awaited := [][]uint8{}
	for _, awaitable := range awaitables {
		awaited = append(awaited, <-awaitable)
	}
	return awaited
}

// AllUint8sAsync is an asynchronous version of AllUint8s
func AllUint8sAsync(awaitables ...<-chan uint8) <-chan []uint8 {
	resolver := make(chan []uint8, 1)
	go func() {
		resolver <- AllUint8s(awaitables...)
	}()
	return resolver
}

// AllUint8SlicesAsync is an asynchronous version of AllUint8Slices
func AllUint8SlicesAsync(awaitables ...<-chan []uint8) <-chan [][]uint8 {
	resolver := make(chan [][]uint8, 1)
	go func() {
		resolver <- AllUint8Slices(awaitables...)
	}()
	return resolver
}

// AnyUint8 will wait for the first channel to emit a single result
// and return that, ignoring all other channels.
func AnyUint8(awaitables ...<-chan uint8) uint8 {
	for {
		for _, awaitable := range awaitables {
			select {
			default:
			case awaited := <-awaitable:
				return awaited
			}
		}
	}
}

// AnyUint8Slice will wait for the first channel to emit a single result
// and return that, ignoring all other channels.
func AnyUint8Slice(awaitables ...<-chan []uint8) []uint8 {
	for {
		for _, awaitable := range awaitables {
			select {
			default:
			case awaited := <-awaitable:
				return awaited
			}
		}
	}
}

// AnyUint8Async is an asynchronous version of AnyUint8.
func AnyUint8Async(awaitables ...<-chan uint8) <-chan uint8 {
	resolver := make(chan uint8, 1)
	go func() {
		resolver <- AnyUint8(awaitables...)
	}()
	return resolver
}

// AnyUint8SliceAsync is an asynchronous version of AnyUint8.
func AnyUint8SliceAsync(awaitables ...<-chan []uint8) <-chan []uint8 {
	resolver := make(chan []uint8, 1)
	go func() {
		resolver <- AnyUint8Slice(awaitables...)
	}()
	return resolver
}

// AllUintptrs will wait for every given channel to emit a single result.
// The results will be returned in a slice ordered the same as the input channels.
func AllUintptrs(awaitables ...<-chan uintptr) []uintptr {
	awaited := []uintptr{}
	for _, awaitable := range awaitables {
		awaited = append(awaited, <-awaitable)
	}
	return awaited
}

// AllUintptrSlices will wait for every given channel to emit a single result.
// The results will be returned in a slice ordered the same as the input channels.
func AllUintptrSlices(awaitables ...<-chan []uintptr) [][]uintptr {
	awaited := [][]uintptr{}
	for _, awaitable := range awaitables {
		awaited = append(awaited, <-awaitable)
	}
	return awaited
}

// AllUintptrsAsync is an asynchronous version of AllUintptrs
func AllUintptrsAsync(awaitables ...<-chan uintptr) <-chan []uintptr {
	resolver := make(chan []uintptr, 1)
	go func() {
		resolver <- AllUintptrs(awaitables...)
	}()
	return resolver
}

// AllUintptrSlicesAsync is an asynchronous version of AllUintptrSlices
func AllUintptrSlicesAsync(awaitables ...<-chan []uintptr) <-chan [][]uintptr {
	resolver := make(chan [][]uintptr, 1)
	go func() {
		resolver <- AllUintptrSlices(awaitables...)
	}()
	return resolver
}

// AnyUintptr will wait for the first channel to emit a single result
// and return that, ignoring all other channels.
func AnyUintptr(awaitables ...<-chan uintptr) uintptr {
	for {
		for _, awaitable := range awaitables {
			select {
			default:
			case awaited := <-awaitable:
				return awaited
			}
		}
	}
}

// AnyUintptrSlice will wait for the first channel to emit a single result
// and return that, ignoring all other channels.
func AnyUintptrSlice(awaitables ...<-chan []uintptr) []uintptr {
	for {
		for _, awaitable := range awaitables {
			select {
			default:
			case awaited := <-awaitable:
				return awaited
			}
		}
	}
}

// AnyUintptrAsync is an asynchronous version of AnyUintptr.
func AnyUintptrAsync(awaitables ...<-chan uintptr) <-chan uintptr {
	resolver := make(chan uintptr, 1)
	go func() {
		resolver <- AnyUintptr(awaitables...)
	}()
	return resolver
}

// AnyUintptrSliceAsync is an asynchronous version of AnyUintptr.
func AnyUintptrSliceAsync(awaitables ...<-chan []uintptr) <-chan []uintptr {
	resolver := make(chan []uintptr, 1)
	go func() {
		resolver <- AnyUintptrSlice(awaitables...)
	}()
	return resolver
}
