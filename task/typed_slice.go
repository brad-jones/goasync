// This file was automatically generated by genny.
// Any changes will be lost if this file is regenerated.
// see https://github.com/cheekybits/genny

package task

import "github.com/brad-jones/goerr"

// BoolSliceTask represents an asynchronous operation, create new instances with NewBoolSlice.
type BoolSliceTask struct {
	Task
	Resolver <-chan []bool
	value    []bool
}

func (t *BoolSliceTask) Result() ([]bool, error) {
	<-t.done
	return t.value, t.err
}

func (t *BoolSliceTask) MustResult() []bool {
	v, e := t.Result()
	goerr.Check(e)
	return v
}

// BoolSliceTaskInternal is passed into a new task function.
type BoolSliceTaskInternal struct {
	TaskInternal
	Resolver chan<- []bool
}

func (ti *BoolSliceTaskInternal) Resolve(v []bool) {
	ti.Resolver <- v
}

// NewBoolSlice creates new instances of BoolSliceTask.
func NewBoolSlice(fn func(t *BoolSliceTaskInternal)) *BoolSliceTask {
	// Spin up some channels
	done := make(chan struct{}, 1)
	stopper := make(chan struct{}, 1)
	tResolver := make(chan []bool, 1)
	tRejector := make(chan error, 1)
	tiResolver := make(chan []bool, 1)
	tiRejector := make(chan error, 1)

	// Pass those channels into our tasks
	t := &BoolSliceTask{}
	t.Resolver = tResolver
	t.Rejector = tRejector
	t.Stopper = &stopper
	t.done = done
	ti := &BoolSliceTaskInternal{}
	ti.Resolver = tiResolver
	ti.Rejector = tiRejector
	ti.Stopper = &stopper

	// Execute the task asynchronously
	go func() {
		// Regardless of what the function does we know that it is done
		defer close(done)

		// Catch any panics and reject them
		defer goerr.Handle(func(e error) {
			t.err = e
			tRejector <- t.err
		})

		// Execute the task
		fn(ti)

		// Read the result in a non blocking manner
		select {
		case v := <-tiResolver:
			t.value = v
			tResolver <- t.value
		case e := <-tiRejector:
			t.err = e
			tRejector <- t.err
		default:
		}
	}()

	// Return the task object
	return t
}

// ResolvedBoolSlice returns a pre-resolved task
//
// Not type safe, use with care.
func ResolvedBoolSlice(v []bool) *BoolSliceTask {
	done := make(chan struct{}, 1)
	close(done)
	resolver := make(chan []bool, 1)
	resolver <- v
	rejector := make(chan error, 1)
	t := &BoolSliceTask{}
	t.Resolver = resolver
	t.Rejector = rejector
	t.Stopper = &done
	t.done = done
	t.closed = true
	return t
}

// RejectedBoolSlice returns a pre-rejected task
//
// Not type safe, use with care.
func RejectedBoolSlice(e error) *BoolSliceTask {
	done := make(chan struct{}, 1)
	close(done)
	resolver := make(chan []bool, 1)
	rejector := make(chan error, 1)
	rejector <- e
	t := &BoolSliceTask{}
	t.Resolver = resolver
	t.Rejector = rejector
	t.Stopper = &done
	t.done = done
	t.closed = true
	return t
}

// ByteSliceTask represents an asynchronous operation, create new instances with NewByteSlice.
type ByteSliceTask struct {
	Task
	Resolver <-chan []byte
	value    []byte
}

func (t *ByteSliceTask) Result() ([]byte, error) {
	<-t.done
	return t.value, t.err
}

func (t *ByteSliceTask) MustResult() []byte {
	v, e := t.Result()
	goerr.Check(e)
	return v
}

// ByteSliceTaskInternal is passed into a new task function.
type ByteSliceTaskInternal struct {
	TaskInternal
	Resolver chan<- []byte
}

func (ti *ByteSliceTaskInternal) Resolve(v []byte) {
	ti.Resolver <- v
}

// NewByteSlice creates new instances of ByteSliceTask.
func NewByteSlice(fn func(t *ByteSliceTaskInternal)) *ByteSliceTask {
	// Spin up some channels
	done := make(chan struct{}, 1)
	stopper := make(chan struct{}, 1)
	tResolver := make(chan []byte, 1)
	tRejector := make(chan error, 1)
	tiResolver := make(chan []byte, 1)
	tiRejector := make(chan error, 1)

	// Pass those channels into our tasks
	t := &ByteSliceTask{}
	t.Resolver = tResolver
	t.Rejector = tRejector
	t.Stopper = &stopper
	t.done = done
	ti := &ByteSliceTaskInternal{}
	ti.Resolver = tiResolver
	ti.Rejector = tiRejector
	ti.Stopper = &stopper

	// Execute the task asynchronously
	go func() {
		// Regardless of what the function does we know that it is done
		defer close(done)

		// Catch any panics and reject them
		defer goerr.Handle(func(e error) {
			t.err = e
			tRejector <- t.err
		})

		// Execute the task
		fn(ti)

		// Read the result in a non blocking manner
		select {
		case v := <-tiResolver:
			t.value = v
			tResolver <- t.value
		case e := <-tiRejector:
			t.err = e
			tRejector <- t.err
		default:
		}
	}()

	// Return the task object
	return t
}

// ResolvedByteSlice returns a pre-resolved task
//
// Not type safe, use with care.
func ResolvedByteSlice(v []byte) *ByteSliceTask {
	done := make(chan struct{}, 1)
	close(done)
	resolver := make(chan []byte, 1)
	resolver <- v
	rejector := make(chan error, 1)
	t := &ByteSliceTask{}
	t.Resolver = resolver
	t.Rejector = rejector
	t.Stopper = &done
	t.done = done
	t.closed = true
	return t
}

// RejectedByteSlice returns a pre-rejected task
//
// Not type safe, use with care.
func RejectedByteSlice(e error) *ByteSliceTask {
	done := make(chan struct{}, 1)
	close(done)
	resolver := make(chan []byte, 1)
	rejector := make(chan error, 1)
	rejector <- e
	t := &ByteSliceTask{}
	t.Resolver = resolver
	t.Rejector = rejector
	t.Stopper = &done
	t.done = done
	t.closed = true
	return t
}

// Complex128SliceTask represents an asynchronous operation, create new instances with NewComplex128Slice.
type Complex128SliceTask struct {
	Task
	Resolver <-chan []complex128
	value    []complex128
}

func (t *Complex128SliceTask) Result() ([]complex128, error) {
	<-t.done
	return t.value, t.err
}

func (t *Complex128SliceTask) MustResult() []complex128 {
	v, e := t.Result()
	goerr.Check(e)
	return v
}

// Complex128SliceTaskInternal is passed into a new task function.
type Complex128SliceTaskInternal struct {
	TaskInternal
	Resolver chan<- []complex128
}

func (ti *Complex128SliceTaskInternal) Resolve(v []complex128) {
	ti.Resolver <- v
}

// NewComplex128Slice creates new instances of Complex128SliceTask.
func NewComplex128Slice(fn func(t *Complex128SliceTaskInternal)) *Complex128SliceTask {
	// Spin up some channels
	done := make(chan struct{}, 1)
	stopper := make(chan struct{}, 1)
	tResolver := make(chan []complex128, 1)
	tRejector := make(chan error, 1)
	tiResolver := make(chan []complex128, 1)
	tiRejector := make(chan error, 1)

	// Pass those channels into our tasks
	t := &Complex128SliceTask{}
	t.Resolver = tResolver
	t.Rejector = tRejector
	t.Stopper = &stopper
	t.done = done
	ti := &Complex128SliceTaskInternal{}
	ti.Resolver = tiResolver
	ti.Rejector = tiRejector
	ti.Stopper = &stopper

	// Execute the task asynchronously
	go func() {
		// Regardless of what the function does we know that it is done
		defer close(done)

		// Catch any panics and reject them
		defer goerr.Handle(func(e error) {
			t.err = e
			tRejector <- t.err
		})

		// Execute the task
		fn(ti)

		// Read the result in a non blocking manner
		select {
		case v := <-tiResolver:
			t.value = v
			tResolver <- t.value
		case e := <-tiRejector:
			t.err = e
			tRejector <- t.err
		default:
		}
	}()

	// Return the task object
	return t
}

// ResolvedComplex128Slice returns a pre-resolved task
//
// Not type safe, use with care.
func ResolvedComplex128Slice(v []complex128) *Complex128SliceTask {
	done := make(chan struct{}, 1)
	close(done)
	resolver := make(chan []complex128, 1)
	resolver <- v
	rejector := make(chan error, 1)
	t := &Complex128SliceTask{}
	t.Resolver = resolver
	t.Rejector = rejector
	t.Stopper = &done
	t.done = done
	t.closed = true
	return t
}

// RejectedComplex128Slice returns a pre-rejected task
//
// Not type safe, use with care.
func RejectedComplex128Slice(e error) *Complex128SliceTask {
	done := make(chan struct{}, 1)
	close(done)
	resolver := make(chan []complex128, 1)
	rejector := make(chan error, 1)
	rejector <- e
	t := &Complex128SliceTask{}
	t.Resolver = resolver
	t.Rejector = rejector
	t.Stopper = &done
	t.done = done
	t.closed = true
	return t
}

// Complex64SliceTask represents an asynchronous operation, create new instances with NewComplex64Slice.
type Complex64SliceTask struct {
	Task
	Resolver <-chan []complex64
	value    []complex64
}

func (t *Complex64SliceTask) Result() ([]complex64, error) {
	<-t.done
	return t.value, t.err
}

func (t *Complex64SliceTask) MustResult() []complex64 {
	v, e := t.Result()
	goerr.Check(e)
	return v
}

// Complex64SliceTaskInternal is passed into a new task function.
type Complex64SliceTaskInternal struct {
	TaskInternal
	Resolver chan<- []complex64
}

func (ti *Complex64SliceTaskInternal) Resolve(v []complex64) {
	ti.Resolver <- v
}

// NewComplex64Slice creates new instances of Complex64SliceTask.
func NewComplex64Slice(fn func(t *Complex64SliceTaskInternal)) *Complex64SliceTask {
	// Spin up some channels
	done := make(chan struct{}, 1)
	stopper := make(chan struct{}, 1)
	tResolver := make(chan []complex64, 1)
	tRejector := make(chan error, 1)
	tiResolver := make(chan []complex64, 1)
	tiRejector := make(chan error, 1)

	// Pass those channels into our tasks
	t := &Complex64SliceTask{}
	t.Resolver = tResolver
	t.Rejector = tRejector
	t.Stopper = &stopper
	t.done = done
	ti := &Complex64SliceTaskInternal{}
	ti.Resolver = tiResolver
	ti.Rejector = tiRejector
	ti.Stopper = &stopper

	// Execute the task asynchronously
	go func() {
		// Regardless of what the function does we know that it is done
		defer close(done)

		// Catch any panics and reject them
		defer goerr.Handle(func(e error) {
			t.err = e
			tRejector <- t.err
		})

		// Execute the task
		fn(ti)

		// Read the result in a non blocking manner
		select {
		case v := <-tiResolver:
			t.value = v
			tResolver <- t.value
		case e := <-tiRejector:
			t.err = e
			tRejector <- t.err
		default:
		}
	}()

	// Return the task object
	return t
}

// ResolvedComplex64Slice returns a pre-resolved task
//
// Not type safe, use with care.
func ResolvedComplex64Slice(v []complex64) *Complex64SliceTask {
	done := make(chan struct{}, 1)
	close(done)
	resolver := make(chan []complex64, 1)
	resolver <- v
	rejector := make(chan error, 1)
	t := &Complex64SliceTask{}
	t.Resolver = resolver
	t.Rejector = rejector
	t.Stopper = &done
	t.done = done
	t.closed = true
	return t
}

// RejectedComplex64Slice returns a pre-rejected task
//
// Not type safe, use with care.
func RejectedComplex64Slice(e error) *Complex64SliceTask {
	done := make(chan struct{}, 1)
	close(done)
	resolver := make(chan []complex64, 1)
	rejector := make(chan error, 1)
	rejector <- e
	t := &Complex64SliceTask{}
	t.Resolver = resolver
	t.Rejector = rejector
	t.Stopper = &done
	t.done = done
	t.closed = true
	return t
}

// ErrorSliceTask represents an asynchronous operation, create new instances with NewErrorSlice.
type ErrorSliceTask struct {
	Task
	Resolver <-chan []error
	value    []error
}

func (t *ErrorSliceTask) Result() ([]error, error) {
	<-t.done
	return t.value, t.err
}

func (t *ErrorSliceTask) MustResult() []error {
	v, e := t.Result()
	goerr.Check(e)
	return v
}

// ErrorSliceTaskInternal is passed into a new task function.
type ErrorSliceTaskInternal struct {
	TaskInternal
	Resolver chan<- []error
}

func (ti *ErrorSliceTaskInternal) Resolve(v []error) {
	ti.Resolver <- v
}

// NewErrorSlice creates new instances of ErrorSliceTask.
func NewErrorSlice(fn func(t *ErrorSliceTaskInternal)) *ErrorSliceTask {
	// Spin up some channels
	done := make(chan struct{}, 1)
	stopper := make(chan struct{}, 1)
	tResolver := make(chan []error, 1)
	tRejector := make(chan error, 1)
	tiResolver := make(chan []error, 1)
	tiRejector := make(chan error, 1)

	// Pass those channels into our tasks
	t := &ErrorSliceTask{}
	t.Resolver = tResolver
	t.Rejector = tRejector
	t.Stopper = &stopper
	t.done = done
	ti := &ErrorSliceTaskInternal{}
	ti.Resolver = tiResolver
	ti.Rejector = tiRejector
	ti.Stopper = &stopper

	// Execute the task asynchronously
	go func() {
		// Regardless of what the function does we know that it is done
		defer close(done)

		// Catch any panics and reject them
		defer goerr.Handle(func(e error) {
			t.err = e
			tRejector <- t.err
		})

		// Execute the task
		fn(ti)

		// Read the result in a non blocking manner
		select {
		case v := <-tiResolver:
			t.value = v
			tResolver <- t.value
		case e := <-tiRejector:
			t.err = e
			tRejector <- t.err
		default:
		}
	}()

	// Return the task object
	return t
}

// ResolvedErrorSlice returns a pre-resolved task
//
// Not type safe, use with care.
func ResolvedErrorSlice(v []error) *ErrorSliceTask {
	done := make(chan struct{}, 1)
	close(done)
	resolver := make(chan []error, 1)
	resolver <- v
	rejector := make(chan error, 1)
	t := &ErrorSliceTask{}
	t.Resolver = resolver
	t.Rejector = rejector
	t.Stopper = &done
	t.done = done
	t.closed = true
	return t
}

// RejectedErrorSlice returns a pre-rejected task
//
// Not type safe, use with care.
func RejectedErrorSlice(e error) *ErrorSliceTask {
	done := make(chan struct{}, 1)
	close(done)
	resolver := make(chan []error, 1)
	rejector := make(chan error, 1)
	rejector <- e
	t := &ErrorSliceTask{}
	t.Resolver = resolver
	t.Rejector = rejector
	t.Stopper = &done
	t.done = done
	t.closed = true
	return t
}

// Float32SliceTask represents an asynchronous operation, create new instances with NewFloat32Slice.
type Float32SliceTask struct {
	Task
	Resolver <-chan []float32
	value    []float32
}

func (t *Float32SliceTask) Result() ([]float32, error) {
	<-t.done
	return t.value, t.err
}

func (t *Float32SliceTask) MustResult() []float32 {
	v, e := t.Result()
	goerr.Check(e)
	return v
}

// Float32SliceTaskInternal is passed into a new task function.
type Float32SliceTaskInternal struct {
	TaskInternal
	Resolver chan<- []float32
}

func (ti *Float32SliceTaskInternal) Resolve(v []float32) {
	ti.Resolver <- v
}

// NewFloat32Slice creates new instances of Float32SliceTask.
func NewFloat32Slice(fn func(t *Float32SliceTaskInternal)) *Float32SliceTask {
	// Spin up some channels
	done := make(chan struct{}, 1)
	stopper := make(chan struct{}, 1)
	tResolver := make(chan []float32, 1)
	tRejector := make(chan error, 1)
	tiResolver := make(chan []float32, 1)
	tiRejector := make(chan error, 1)

	// Pass those channels into our tasks
	t := &Float32SliceTask{}
	t.Resolver = tResolver
	t.Rejector = tRejector
	t.Stopper = &stopper
	t.done = done
	ti := &Float32SliceTaskInternal{}
	ti.Resolver = tiResolver
	ti.Rejector = tiRejector
	ti.Stopper = &stopper

	// Execute the task asynchronously
	go func() {
		// Regardless of what the function does we know that it is done
		defer close(done)

		// Catch any panics and reject them
		defer goerr.Handle(func(e error) {
			t.err = e
			tRejector <- t.err
		})

		// Execute the task
		fn(ti)

		// Read the result in a non blocking manner
		select {
		case v := <-tiResolver:
			t.value = v
			tResolver <- t.value
		case e := <-tiRejector:
			t.err = e
			tRejector <- t.err
		default:
		}
	}()

	// Return the task object
	return t
}

// ResolvedFloat32Slice returns a pre-resolved task
//
// Not type safe, use with care.
func ResolvedFloat32Slice(v []float32) *Float32SliceTask {
	done := make(chan struct{}, 1)
	close(done)
	resolver := make(chan []float32, 1)
	resolver <- v
	rejector := make(chan error, 1)
	t := &Float32SliceTask{}
	t.Resolver = resolver
	t.Rejector = rejector
	t.Stopper = &done
	t.done = done
	t.closed = true
	return t
}

// RejectedFloat32Slice returns a pre-rejected task
//
// Not type safe, use with care.
func RejectedFloat32Slice(e error) *Float32SliceTask {
	done := make(chan struct{}, 1)
	close(done)
	resolver := make(chan []float32, 1)
	rejector := make(chan error, 1)
	rejector <- e
	t := &Float32SliceTask{}
	t.Resolver = resolver
	t.Rejector = rejector
	t.Stopper = &done
	t.done = done
	t.closed = true
	return t
}

// Float64SliceTask represents an asynchronous operation, create new instances with NewFloat64Slice.
type Float64SliceTask struct {
	Task
	Resolver <-chan []float64
	value    []float64
}

func (t *Float64SliceTask) Result() ([]float64, error) {
	<-t.done
	return t.value, t.err
}

func (t *Float64SliceTask) MustResult() []float64 {
	v, e := t.Result()
	goerr.Check(e)
	return v
}

// Float64SliceTaskInternal is passed into a new task function.
type Float64SliceTaskInternal struct {
	TaskInternal
	Resolver chan<- []float64
}

func (ti *Float64SliceTaskInternal) Resolve(v []float64) {
	ti.Resolver <- v
}

// NewFloat64Slice creates new instances of Float64SliceTask.
func NewFloat64Slice(fn func(t *Float64SliceTaskInternal)) *Float64SliceTask {
	// Spin up some channels
	done := make(chan struct{}, 1)
	stopper := make(chan struct{}, 1)
	tResolver := make(chan []float64, 1)
	tRejector := make(chan error, 1)
	tiResolver := make(chan []float64, 1)
	tiRejector := make(chan error, 1)

	// Pass those channels into our tasks
	t := &Float64SliceTask{}
	t.Resolver = tResolver
	t.Rejector = tRejector
	t.Stopper = &stopper
	t.done = done
	ti := &Float64SliceTaskInternal{}
	ti.Resolver = tiResolver
	ti.Rejector = tiRejector
	ti.Stopper = &stopper

	// Execute the task asynchronously
	go func() {
		// Regardless of what the function does we know that it is done
		defer close(done)

		// Catch any panics and reject them
		defer goerr.Handle(func(e error) {
			t.err = e
			tRejector <- t.err
		})

		// Execute the task
		fn(ti)

		// Read the result in a non blocking manner
		select {
		case v := <-tiResolver:
			t.value = v
			tResolver <- t.value
		case e := <-tiRejector:
			t.err = e
			tRejector <- t.err
		default:
		}
	}()

	// Return the task object
	return t
}

// ResolvedFloat64Slice returns a pre-resolved task
//
// Not type safe, use with care.
func ResolvedFloat64Slice(v []float64) *Float64SliceTask {
	done := make(chan struct{}, 1)
	close(done)
	resolver := make(chan []float64, 1)
	resolver <- v
	rejector := make(chan error, 1)
	t := &Float64SliceTask{}
	t.Resolver = resolver
	t.Rejector = rejector
	t.Stopper = &done
	t.done = done
	t.closed = true
	return t
}

// RejectedFloat64Slice returns a pre-rejected task
//
// Not type safe, use with care.
func RejectedFloat64Slice(e error) *Float64SliceTask {
	done := make(chan struct{}, 1)
	close(done)
	resolver := make(chan []float64, 1)
	rejector := make(chan error, 1)
	rejector <- e
	t := &Float64SliceTask{}
	t.Resolver = resolver
	t.Rejector = rejector
	t.Stopper = &done
	t.done = done
	t.closed = true
	return t
}

// IntSliceTask represents an asynchronous operation, create new instances with NewIntSlice.
type IntSliceTask struct {
	Task
	Resolver <-chan []int
	value    []int
}

func (t *IntSliceTask) Result() ([]int, error) {
	<-t.done
	return t.value, t.err
}

func (t *IntSliceTask) MustResult() []int {
	v, e := t.Result()
	goerr.Check(e)
	return v
}

// IntSliceTaskInternal is passed into a new task function.
type IntSliceTaskInternal struct {
	TaskInternal
	Resolver chan<- []int
}

func (ti *IntSliceTaskInternal) Resolve(v []int) {
	ti.Resolver <- v
}

// NewIntSlice creates new instances of IntSliceTask.
func NewIntSlice(fn func(t *IntSliceTaskInternal)) *IntSliceTask {
	// Spin up some channels
	done := make(chan struct{}, 1)
	stopper := make(chan struct{}, 1)
	tResolver := make(chan []int, 1)
	tRejector := make(chan error, 1)
	tiResolver := make(chan []int, 1)
	tiRejector := make(chan error, 1)

	// Pass those channels into our tasks
	t := &IntSliceTask{}
	t.Resolver = tResolver
	t.Rejector = tRejector
	t.Stopper = &stopper
	t.done = done
	ti := &IntSliceTaskInternal{}
	ti.Resolver = tiResolver
	ti.Rejector = tiRejector
	ti.Stopper = &stopper

	// Execute the task asynchronously
	go func() {
		// Regardless of what the function does we know that it is done
		defer close(done)

		// Catch any panics and reject them
		defer goerr.Handle(func(e error) {
			t.err = e
			tRejector <- t.err
		})

		// Execute the task
		fn(ti)

		// Read the result in a non blocking manner
		select {
		case v := <-tiResolver:
			t.value = v
			tResolver <- t.value
		case e := <-tiRejector:
			t.err = e
			tRejector <- t.err
		default:
		}
	}()

	// Return the task object
	return t
}

// ResolvedIntSlice returns a pre-resolved task
//
// Not type safe, use with care.
func ResolvedIntSlice(v []int) *IntSliceTask {
	done := make(chan struct{}, 1)
	close(done)
	resolver := make(chan []int, 1)
	resolver <- v
	rejector := make(chan error, 1)
	t := &IntSliceTask{}
	t.Resolver = resolver
	t.Rejector = rejector
	t.Stopper = &done
	t.done = done
	t.closed = true
	return t
}

// RejectedIntSlice returns a pre-rejected task
//
// Not type safe, use with care.
func RejectedIntSlice(e error) *IntSliceTask {
	done := make(chan struct{}, 1)
	close(done)
	resolver := make(chan []int, 1)
	rejector := make(chan error, 1)
	rejector <- e
	t := &IntSliceTask{}
	t.Resolver = resolver
	t.Rejector = rejector
	t.Stopper = &done
	t.done = done
	t.closed = true
	return t
}

// Int16SliceTask represents an asynchronous operation, create new instances with NewInt16Slice.
type Int16SliceTask struct {
	Task
	Resolver <-chan []int16
	value    []int16
}

func (t *Int16SliceTask) Result() ([]int16, error) {
	<-t.done
	return t.value, t.err
}

func (t *Int16SliceTask) MustResult() []int16 {
	v, e := t.Result()
	goerr.Check(e)
	return v
}

// Int16SliceTaskInternal is passed into a new task function.
type Int16SliceTaskInternal struct {
	TaskInternal
	Resolver chan<- []int16
}

func (ti *Int16SliceTaskInternal) Resolve(v []int16) {
	ti.Resolver <- v
}

// NewInt16Slice creates new instances of Int16SliceTask.
func NewInt16Slice(fn func(t *Int16SliceTaskInternal)) *Int16SliceTask {
	// Spin up some channels
	done := make(chan struct{}, 1)
	stopper := make(chan struct{}, 1)
	tResolver := make(chan []int16, 1)
	tRejector := make(chan error, 1)
	tiResolver := make(chan []int16, 1)
	tiRejector := make(chan error, 1)

	// Pass those channels into our tasks
	t := &Int16SliceTask{}
	t.Resolver = tResolver
	t.Rejector = tRejector
	t.Stopper = &stopper
	t.done = done
	ti := &Int16SliceTaskInternal{}
	ti.Resolver = tiResolver
	ti.Rejector = tiRejector
	ti.Stopper = &stopper

	// Execute the task asynchronously
	go func() {
		// Regardless of what the function does we know that it is done
		defer close(done)

		// Catch any panics and reject them
		defer goerr.Handle(func(e error) {
			t.err = e
			tRejector <- t.err
		})

		// Execute the task
		fn(ti)

		// Read the result in a non blocking manner
		select {
		case v := <-tiResolver:
			t.value = v
			tResolver <- t.value
		case e := <-tiRejector:
			t.err = e
			tRejector <- t.err
		default:
		}
	}()

	// Return the task object
	return t
}

// ResolvedInt16Slice returns a pre-resolved task
//
// Not type safe, use with care.
func ResolvedInt16Slice(v []int16) *Int16SliceTask {
	done := make(chan struct{}, 1)
	close(done)
	resolver := make(chan []int16, 1)
	resolver <- v
	rejector := make(chan error, 1)
	t := &Int16SliceTask{}
	t.Resolver = resolver
	t.Rejector = rejector
	t.Stopper = &done
	t.done = done
	t.closed = true
	return t
}

// RejectedInt16Slice returns a pre-rejected task
//
// Not type safe, use with care.
func RejectedInt16Slice(e error) *Int16SliceTask {
	done := make(chan struct{}, 1)
	close(done)
	resolver := make(chan []int16, 1)
	rejector := make(chan error, 1)
	rejector <- e
	t := &Int16SliceTask{}
	t.Resolver = resolver
	t.Rejector = rejector
	t.Stopper = &done
	t.done = done
	t.closed = true
	return t
}

// Int32SliceTask represents an asynchronous operation, create new instances with NewInt32Slice.
type Int32SliceTask struct {
	Task
	Resolver <-chan []int32
	value    []int32
}

func (t *Int32SliceTask) Result() ([]int32, error) {
	<-t.done
	return t.value, t.err
}

func (t *Int32SliceTask) MustResult() []int32 {
	v, e := t.Result()
	goerr.Check(e)
	return v
}

// Int32SliceTaskInternal is passed into a new task function.
type Int32SliceTaskInternal struct {
	TaskInternal
	Resolver chan<- []int32
}

func (ti *Int32SliceTaskInternal) Resolve(v []int32) {
	ti.Resolver <- v
}

// NewInt32Slice creates new instances of Int32SliceTask.
func NewInt32Slice(fn func(t *Int32SliceTaskInternal)) *Int32SliceTask {
	// Spin up some channels
	done := make(chan struct{}, 1)
	stopper := make(chan struct{}, 1)
	tResolver := make(chan []int32, 1)
	tRejector := make(chan error, 1)
	tiResolver := make(chan []int32, 1)
	tiRejector := make(chan error, 1)

	// Pass those channels into our tasks
	t := &Int32SliceTask{}
	t.Resolver = tResolver
	t.Rejector = tRejector
	t.Stopper = &stopper
	t.done = done
	ti := &Int32SliceTaskInternal{}
	ti.Resolver = tiResolver
	ti.Rejector = tiRejector
	ti.Stopper = &stopper

	// Execute the task asynchronously
	go func() {
		// Regardless of what the function does we know that it is done
		defer close(done)

		// Catch any panics and reject them
		defer goerr.Handle(func(e error) {
			t.err = e
			tRejector <- t.err
		})

		// Execute the task
		fn(ti)

		// Read the result in a non blocking manner
		select {
		case v := <-tiResolver:
			t.value = v
			tResolver <- t.value
		case e := <-tiRejector:
			t.err = e
			tRejector <- t.err
		default:
		}
	}()

	// Return the task object
	return t
}

// ResolvedInt32Slice returns a pre-resolved task
//
// Not type safe, use with care.
func ResolvedInt32Slice(v []int32) *Int32SliceTask {
	done := make(chan struct{}, 1)
	close(done)
	resolver := make(chan []int32, 1)
	resolver <- v
	rejector := make(chan error, 1)
	t := &Int32SliceTask{}
	t.Resolver = resolver
	t.Rejector = rejector
	t.Stopper = &done
	t.done = done
	t.closed = true
	return t
}

// RejectedInt32Slice returns a pre-rejected task
//
// Not type safe, use with care.
func RejectedInt32Slice(e error) *Int32SliceTask {
	done := make(chan struct{}, 1)
	close(done)
	resolver := make(chan []int32, 1)
	rejector := make(chan error, 1)
	rejector <- e
	t := &Int32SliceTask{}
	t.Resolver = resolver
	t.Rejector = rejector
	t.Stopper = &done
	t.done = done
	t.closed = true
	return t
}

// Int64SliceTask represents an asynchronous operation, create new instances with NewInt64Slice.
type Int64SliceTask struct {
	Task
	Resolver <-chan []int64
	value    []int64
}

func (t *Int64SliceTask) Result() ([]int64, error) {
	<-t.done
	return t.value, t.err
}

func (t *Int64SliceTask) MustResult() []int64 {
	v, e := t.Result()
	goerr.Check(e)
	return v
}

// Int64SliceTaskInternal is passed into a new task function.
type Int64SliceTaskInternal struct {
	TaskInternal
	Resolver chan<- []int64
}

func (ti *Int64SliceTaskInternal) Resolve(v []int64) {
	ti.Resolver <- v
}

// NewInt64Slice creates new instances of Int64SliceTask.
func NewInt64Slice(fn func(t *Int64SliceTaskInternal)) *Int64SliceTask {
	// Spin up some channels
	done := make(chan struct{}, 1)
	stopper := make(chan struct{}, 1)
	tResolver := make(chan []int64, 1)
	tRejector := make(chan error, 1)
	tiResolver := make(chan []int64, 1)
	tiRejector := make(chan error, 1)

	// Pass those channels into our tasks
	t := &Int64SliceTask{}
	t.Resolver = tResolver
	t.Rejector = tRejector
	t.Stopper = &stopper
	t.done = done
	ti := &Int64SliceTaskInternal{}
	ti.Resolver = tiResolver
	ti.Rejector = tiRejector
	ti.Stopper = &stopper

	// Execute the task asynchronously
	go func() {
		// Regardless of what the function does we know that it is done
		defer close(done)

		// Catch any panics and reject them
		defer goerr.Handle(func(e error) {
			t.err = e
			tRejector <- t.err
		})

		// Execute the task
		fn(ti)

		// Read the result in a non blocking manner
		select {
		case v := <-tiResolver:
			t.value = v
			tResolver <- t.value
		case e := <-tiRejector:
			t.err = e
			tRejector <- t.err
		default:
		}
	}()

	// Return the task object
	return t
}

// ResolvedInt64Slice returns a pre-resolved task
//
// Not type safe, use with care.
func ResolvedInt64Slice(v []int64) *Int64SliceTask {
	done := make(chan struct{}, 1)
	close(done)
	resolver := make(chan []int64, 1)
	resolver <- v
	rejector := make(chan error, 1)
	t := &Int64SliceTask{}
	t.Resolver = resolver
	t.Rejector = rejector
	t.Stopper = &done
	t.done = done
	t.closed = true
	return t
}

// RejectedInt64Slice returns a pre-rejected task
//
// Not type safe, use with care.
func RejectedInt64Slice(e error) *Int64SliceTask {
	done := make(chan struct{}, 1)
	close(done)
	resolver := make(chan []int64, 1)
	rejector := make(chan error, 1)
	rejector <- e
	t := &Int64SliceTask{}
	t.Resolver = resolver
	t.Rejector = rejector
	t.Stopper = &done
	t.done = done
	t.closed = true
	return t
}

// Int8SliceTask represents an asynchronous operation, create new instances with NewInt8Slice.
type Int8SliceTask struct {
	Task
	Resolver <-chan []int8
	value    []int8
}

func (t *Int8SliceTask) Result() ([]int8, error) {
	<-t.done
	return t.value, t.err
}

func (t *Int8SliceTask) MustResult() []int8 {
	v, e := t.Result()
	goerr.Check(e)
	return v
}

// Int8SliceTaskInternal is passed into a new task function.
type Int8SliceTaskInternal struct {
	TaskInternal
	Resolver chan<- []int8
}

func (ti *Int8SliceTaskInternal) Resolve(v []int8) {
	ti.Resolver <- v
}

// NewInt8Slice creates new instances of Int8SliceTask.
func NewInt8Slice(fn func(t *Int8SliceTaskInternal)) *Int8SliceTask {
	// Spin up some channels
	done := make(chan struct{}, 1)
	stopper := make(chan struct{}, 1)
	tResolver := make(chan []int8, 1)
	tRejector := make(chan error, 1)
	tiResolver := make(chan []int8, 1)
	tiRejector := make(chan error, 1)

	// Pass those channels into our tasks
	t := &Int8SliceTask{}
	t.Resolver = tResolver
	t.Rejector = tRejector
	t.Stopper = &stopper
	t.done = done
	ti := &Int8SliceTaskInternal{}
	ti.Resolver = tiResolver
	ti.Rejector = tiRejector
	ti.Stopper = &stopper

	// Execute the task asynchronously
	go func() {
		// Regardless of what the function does we know that it is done
		defer close(done)

		// Catch any panics and reject them
		defer goerr.Handle(func(e error) {
			t.err = e
			tRejector <- t.err
		})

		// Execute the task
		fn(ti)

		// Read the result in a non blocking manner
		select {
		case v := <-tiResolver:
			t.value = v
			tResolver <- t.value
		case e := <-tiRejector:
			t.err = e
			tRejector <- t.err
		default:
		}
	}()

	// Return the task object
	return t
}

// ResolvedInt8Slice returns a pre-resolved task
//
// Not type safe, use with care.
func ResolvedInt8Slice(v []int8) *Int8SliceTask {
	done := make(chan struct{}, 1)
	close(done)
	resolver := make(chan []int8, 1)
	resolver <- v
	rejector := make(chan error, 1)
	t := &Int8SliceTask{}
	t.Resolver = resolver
	t.Rejector = rejector
	t.Stopper = &done
	t.done = done
	t.closed = true
	return t
}

// RejectedInt8Slice returns a pre-rejected task
//
// Not type safe, use with care.
func RejectedInt8Slice(e error) *Int8SliceTask {
	done := make(chan struct{}, 1)
	close(done)
	resolver := make(chan []int8, 1)
	rejector := make(chan error, 1)
	rejector <- e
	t := &Int8SliceTask{}
	t.Resolver = resolver
	t.Rejector = rejector
	t.Stopper = &done
	t.done = done
	t.closed = true
	return t
}

// RuneSliceTask represents an asynchronous operation, create new instances with NewRuneSlice.
type RuneSliceTask struct {
	Task
	Resolver <-chan []rune
	value    []rune
}

func (t *RuneSliceTask) Result() ([]rune, error) {
	<-t.done
	return t.value, t.err
}

func (t *RuneSliceTask) MustResult() []rune {
	v, e := t.Result()
	goerr.Check(e)
	return v
}

// RuneSliceTaskInternal is passed into a new task function.
type RuneSliceTaskInternal struct {
	TaskInternal
	Resolver chan<- []rune
}

func (ti *RuneSliceTaskInternal) Resolve(v []rune) {
	ti.Resolver <- v
}

// NewRuneSlice creates new instances of RuneSliceTask.
func NewRuneSlice(fn func(t *RuneSliceTaskInternal)) *RuneSliceTask {
	// Spin up some channels
	done := make(chan struct{}, 1)
	stopper := make(chan struct{}, 1)
	tResolver := make(chan []rune, 1)
	tRejector := make(chan error, 1)
	tiResolver := make(chan []rune, 1)
	tiRejector := make(chan error, 1)

	// Pass those channels into our tasks
	t := &RuneSliceTask{}
	t.Resolver = tResolver
	t.Rejector = tRejector
	t.Stopper = &stopper
	t.done = done
	ti := &RuneSliceTaskInternal{}
	ti.Resolver = tiResolver
	ti.Rejector = tiRejector
	ti.Stopper = &stopper

	// Execute the task asynchronously
	go func() {
		// Regardless of what the function does we know that it is done
		defer close(done)

		// Catch any panics and reject them
		defer goerr.Handle(func(e error) {
			t.err = e
			tRejector <- t.err
		})

		// Execute the task
		fn(ti)

		// Read the result in a non blocking manner
		select {
		case v := <-tiResolver:
			t.value = v
			tResolver <- t.value
		case e := <-tiRejector:
			t.err = e
			tRejector <- t.err
		default:
		}
	}()

	// Return the task object
	return t
}

// ResolvedRuneSlice returns a pre-resolved task
//
// Not type safe, use with care.
func ResolvedRuneSlice(v []rune) *RuneSliceTask {
	done := make(chan struct{}, 1)
	close(done)
	resolver := make(chan []rune, 1)
	resolver <- v
	rejector := make(chan error, 1)
	t := &RuneSliceTask{}
	t.Resolver = resolver
	t.Rejector = rejector
	t.Stopper = &done
	t.done = done
	t.closed = true
	return t
}

// RejectedRuneSlice returns a pre-rejected task
//
// Not type safe, use with care.
func RejectedRuneSlice(e error) *RuneSliceTask {
	done := make(chan struct{}, 1)
	close(done)
	resolver := make(chan []rune, 1)
	rejector := make(chan error, 1)
	rejector <- e
	t := &RuneSliceTask{}
	t.Resolver = resolver
	t.Rejector = rejector
	t.Stopper = &done
	t.done = done
	t.closed = true
	return t
}

// StringSliceTask represents an asynchronous operation, create new instances with NewStringSlice.
type StringSliceTask struct {
	Task
	Resolver <-chan []string
	value    []string
}

func (t *StringSliceTask) Result() ([]string, error) {
	<-t.done
	return t.value, t.err
}

func (t *StringSliceTask) MustResult() []string {
	v, e := t.Result()
	goerr.Check(e)
	return v
}

// StringSliceTaskInternal is passed into a new task function.
type StringSliceTaskInternal struct {
	TaskInternal
	Resolver chan<- []string
}

func (ti *StringSliceTaskInternal) Resolve(v []string) {
	ti.Resolver <- v
}

// NewStringSlice creates new instances of StringSliceTask.
func NewStringSlice(fn func(t *StringSliceTaskInternal)) *StringSliceTask {
	// Spin up some channels
	done := make(chan struct{}, 1)
	stopper := make(chan struct{}, 1)
	tResolver := make(chan []string, 1)
	tRejector := make(chan error, 1)
	tiResolver := make(chan []string, 1)
	tiRejector := make(chan error, 1)

	// Pass those channels into our tasks
	t := &StringSliceTask{}
	t.Resolver = tResolver
	t.Rejector = tRejector
	t.Stopper = &stopper
	t.done = done
	ti := &StringSliceTaskInternal{}
	ti.Resolver = tiResolver
	ti.Rejector = tiRejector
	ti.Stopper = &stopper

	// Execute the task asynchronously
	go func() {
		// Regardless of what the function does we know that it is done
		defer close(done)

		// Catch any panics and reject them
		defer goerr.Handle(func(e error) {
			t.err = e
			tRejector <- t.err
		})

		// Execute the task
		fn(ti)

		// Read the result in a non blocking manner
		select {
		case v := <-tiResolver:
			t.value = v
			tResolver <- t.value
		case e := <-tiRejector:
			t.err = e
			tRejector <- t.err
		default:
		}
	}()

	// Return the task object
	return t
}

// ResolvedStringSlice returns a pre-resolved task
//
// Not type safe, use with care.
func ResolvedStringSlice(v []string) *StringSliceTask {
	done := make(chan struct{}, 1)
	close(done)
	resolver := make(chan []string, 1)
	resolver <- v
	rejector := make(chan error, 1)
	t := &StringSliceTask{}
	t.Resolver = resolver
	t.Rejector = rejector
	t.Stopper = &done
	t.done = done
	t.closed = true
	return t
}

// RejectedStringSlice returns a pre-rejected task
//
// Not type safe, use with care.
func RejectedStringSlice(e error) *StringSliceTask {
	done := make(chan struct{}, 1)
	close(done)
	resolver := make(chan []string, 1)
	rejector := make(chan error, 1)
	rejector <- e
	t := &StringSliceTask{}
	t.Resolver = resolver
	t.Rejector = rejector
	t.Stopper = &done
	t.done = done
	t.closed = true
	return t
}

// UintSliceTask represents an asynchronous operation, create new instances with NewUintSlice.
type UintSliceTask struct {
	Task
	Resolver <-chan []uint
	value    []uint
}

func (t *UintSliceTask) Result() ([]uint, error) {
	<-t.done
	return t.value, t.err
}

func (t *UintSliceTask) MustResult() []uint {
	v, e := t.Result()
	goerr.Check(e)
	return v
}

// UintSliceTaskInternal is passed into a new task function.
type UintSliceTaskInternal struct {
	TaskInternal
	Resolver chan<- []uint
}

func (ti *UintSliceTaskInternal) Resolve(v []uint) {
	ti.Resolver <- v
}

// NewUintSlice creates new instances of UintSliceTask.
func NewUintSlice(fn func(t *UintSliceTaskInternal)) *UintSliceTask {
	// Spin up some channels
	done := make(chan struct{}, 1)
	stopper := make(chan struct{}, 1)
	tResolver := make(chan []uint, 1)
	tRejector := make(chan error, 1)
	tiResolver := make(chan []uint, 1)
	tiRejector := make(chan error, 1)

	// Pass those channels into our tasks
	t := &UintSliceTask{}
	t.Resolver = tResolver
	t.Rejector = tRejector
	t.Stopper = &stopper
	t.done = done
	ti := &UintSliceTaskInternal{}
	ti.Resolver = tiResolver
	ti.Rejector = tiRejector
	ti.Stopper = &stopper

	// Execute the task asynchronously
	go func() {
		// Regardless of what the function does we know that it is done
		defer close(done)

		// Catch any panics and reject them
		defer goerr.Handle(func(e error) {
			t.err = e
			tRejector <- t.err
		})

		// Execute the task
		fn(ti)

		// Read the result in a non blocking manner
		select {
		case v := <-tiResolver:
			t.value = v
			tResolver <- t.value
		case e := <-tiRejector:
			t.err = e
			tRejector <- t.err
		default:
		}
	}()

	// Return the task object
	return t
}

// ResolvedUintSlice returns a pre-resolved task
//
// Not type safe, use with care.
func ResolvedUintSlice(v []uint) *UintSliceTask {
	done := make(chan struct{}, 1)
	close(done)
	resolver := make(chan []uint, 1)
	resolver <- v
	rejector := make(chan error, 1)
	t := &UintSliceTask{}
	t.Resolver = resolver
	t.Rejector = rejector
	t.Stopper = &done
	t.done = done
	t.closed = true
	return t
}

// RejectedUintSlice returns a pre-rejected task
//
// Not type safe, use with care.
func RejectedUintSlice(e error) *UintSliceTask {
	done := make(chan struct{}, 1)
	close(done)
	resolver := make(chan []uint, 1)
	rejector := make(chan error, 1)
	rejector <- e
	t := &UintSliceTask{}
	t.Resolver = resolver
	t.Rejector = rejector
	t.Stopper = &done
	t.done = done
	t.closed = true
	return t
}

// Uint16SliceTask represents an asynchronous operation, create new instances with NewUint16Slice.
type Uint16SliceTask struct {
	Task
	Resolver <-chan []uint16
	value    []uint16
}

func (t *Uint16SliceTask) Result() ([]uint16, error) {
	<-t.done
	return t.value, t.err
}

func (t *Uint16SliceTask) MustResult() []uint16 {
	v, e := t.Result()
	goerr.Check(e)
	return v
}

// Uint16SliceTaskInternal is passed into a new task function.
type Uint16SliceTaskInternal struct {
	TaskInternal
	Resolver chan<- []uint16
}

func (ti *Uint16SliceTaskInternal) Resolve(v []uint16) {
	ti.Resolver <- v
}

// NewUint16Slice creates new instances of Uint16SliceTask.
func NewUint16Slice(fn func(t *Uint16SliceTaskInternal)) *Uint16SliceTask {
	// Spin up some channels
	done := make(chan struct{}, 1)
	stopper := make(chan struct{}, 1)
	tResolver := make(chan []uint16, 1)
	tRejector := make(chan error, 1)
	tiResolver := make(chan []uint16, 1)
	tiRejector := make(chan error, 1)

	// Pass those channels into our tasks
	t := &Uint16SliceTask{}
	t.Resolver = tResolver
	t.Rejector = tRejector
	t.Stopper = &stopper
	t.done = done
	ti := &Uint16SliceTaskInternal{}
	ti.Resolver = tiResolver
	ti.Rejector = tiRejector
	ti.Stopper = &stopper

	// Execute the task asynchronously
	go func() {
		// Regardless of what the function does we know that it is done
		defer close(done)

		// Catch any panics and reject them
		defer goerr.Handle(func(e error) {
			t.err = e
			tRejector <- t.err
		})

		// Execute the task
		fn(ti)

		// Read the result in a non blocking manner
		select {
		case v := <-tiResolver:
			t.value = v
			tResolver <- t.value
		case e := <-tiRejector:
			t.err = e
			tRejector <- t.err
		default:
		}
	}()

	// Return the task object
	return t
}

// ResolvedUint16Slice returns a pre-resolved task
//
// Not type safe, use with care.
func ResolvedUint16Slice(v []uint16) *Uint16SliceTask {
	done := make(chan struct{}, 1)
	close(done)
	resolver := make(chan []uint16, 1)
	resolver <- v
	rejector := make(chan error, 1)
	t := &Uint16SliceTask{}
	t.Resolver = resolver
	t.Rejector = rejector
	t.Stopper = &done
	t.done = done
	t.closed = true
	return t
}

// RejectedUint16Slice returns a pre-rejected task
//
// Not type safe, use with care.
func RejectedUint16Slice(e error) *Uint16SliceTask {
	done := make(chan struct{}, 1)
	close(done)
	resolver := make(chan []uint16, 1)
	rejector := make(chan error, 1)
	rejector <- e
	t := &Uint16SliceTask{}
	t.Resolver = resolver
	t.Rejector = rejector
	t.Stopper = &done
	t.done = done
	t.closed = true
	return t
}

// Uint32SliceTask represents an asynchronous operation, create new instances with NewUint32Slice.
type Uint32SliceTask struct {
	Task
	Resolver <-chan []uint32
	value    []uint32
}

func (t *Uint32SliceTask) Result() ([]uint32, error) {
	<-t.done
	return t.value, t.err
}

func (t *Uint32SliceTask) MustResult() []uint32 {
	v, e := t.Result()
	goerr.Check(e)
	return v
}

// Uint32SliceTaskInternal is passed into a new task function.
type Uint32SliceTaskInternal struct {
	TaskInternal
	Resolver chan<- []uint32
}

func (ti *Uint32SliceTaskInternal) Resolve(v []uint32) {
	ti.Resolver <- v
}

// NewUint32Slice creates new instances of Uint32SliceTask.
func NewUint32Slice(fn func(t *Uint32SliceTaskInternal)) *Uint32SliceTask {
	// Spin up some channels
	done := make(chan struct{}, 1)
	stopper := make(chan struct{}, 1)
	tResolver := make(chan []uint32, 1)
	tRejector := make(chan error, 1)
	tiResolver := make(chan []uint32, 1)
	tiRejector := make(chan error, 1)

	// Pass those channels into our tasks
	t := &Uint32SliceTask{}
	t.Resolver = tResolver
	t.Rejector = tRejector
	t.Stopper = &stopper
	t.done = done
	ti := &Uint32SliceTaskInternal{}
	ti.Resolver = tiResolver
	ti.Rejector = tiRejector
	ti.Stopper = &stopper

	// Execute the task asynchronously
	go func() {
		// Regardless of what the function does we know that it is done
		defer close(done)

		// Catch any panics and reject them
		defer goerr.Handle(func(e error) {
			t.err = e
			tRejector <- t.err
		})

		// Execute the task
		fn(ti)

		// Read the result in a non blocking manner
		select {
		case v := <-tiResolver:
			t.value = v
			tResolver <- t.value
		case e := <-tiRejector:
			t.err = e
			tRejector <- t.err
		default:
		}
	}()

	// Return the task object
	return t
}

// ResolvedUint32Slice returns a pre-resolved task
//
// Not type safe, use with care.
func ResolvedUint32Slice(v []uint32) *Uint32SliceTask {
	done := make(chan struct{}, 1)
	close(done)
	resolver := make(chan []uint32, 1)
	resolver <- v
	rejector := make(chan error, 1)
	t := &Uint32SliceTask{}
	t.Resolver = resolver
	t.Rejector = rejector
	t.Stopper = &done
	t.done = done
	t.closed = true
	return t
}

// RejectedUint32Slice returns a pre-rejected task
//
// Not type safe, use with care.
func RejectedUint32Slice(e error) *Uint32SliceTask {
	done := make(chan struct{}, 1)
	close(done)
	resolver := make(chan []uint32, 1)
	rejector := make(chan error, 1)
	rejector <- e
	t := &Uint32SliceTask{}
	t.Resolver = resolver
	t.Rejector = rejector
	t.Stopper = &done
	t.done = done
	t.closed = true
	return t
}

// Uint64SliceTask represents an asynchronous operation, create new instances with NewUint64Slice.
type Uint64SliceTask struct {
	Task
	Resolver <-chan []uint64
	value    []uint64
}

func (t *Uint64SliceTask) Result() ([]uint64, error) {
	<-t.done
	return t.value, t.err
}

func (t *Uint64SliceTask) MustResult() []uint64 {
	v, e := t.Result()
	goerr.Check(e)
	return v
}

// Uint64SliceTaskInternal is passed into a new task function.
type Uint64SliceTaskInternal struct {
	TaskInternal
	Resolver chan<- []uint64
}

func (ti *Uint64SliceTaskInternal) Resolve(v []uint64) {
	ti.Resolver <- v
}

// NewUint64Slice creates new instances of Uint64SliceTask.
func NewUint64Slice(fn func(t *Uint64SliceTaskInternal)) *Uint64SliceTask {
	// Spin up some channels
	done := make(chan struct{}, 1)
	stopper := make(chan struct{}, 1)
	tResolver := make(chan []uint64, 1)
	tRejector := make(chan error, 1)
	tiResolver := make(chan []uint64, 1)
	tiRejector := make(chan error, 1)

	// Pass those channels into our tasks
	t := &Uint64SliceTask{}
	t.Resolver = tResolver
	t.Rejector = tRejector
	t.Stopper = &stopper
	t.done = done
	ti := &Uint64SliceTaskInternal{}
	ti.Resolver = tiResolver
	ti.Rejector = tiRejector
	ti.Stopper = &stopper

	// Execute the task asynchronously
	go func() {
		// Regardless of what the function does we know that it is done
		defer close(done)

		// Catch any panics and reject them
		defer goerr.Handle(func(e error) {
			t.err = e
			tRejector <- t.err
		})

		// Execute the task
		fn(ti)

		// Read the result in a non blocking manner
		select {
		case v := <-tiResolver:
			t.value = v
			tResolver <- t.value
		case e := <-tiRejector:
			t.err = e
			tRejector <- t.err
		default:
		}
	}()

	// Return the task object
	return t
}

// ResolvedUint64Slice returns a pre-resolved task
//
// Not type safe, use with care.
func ResolvedUint64Slice(v []uint64) *Uint64SliceTask {
	done := make(chan struct{}, 1)
	close(done)
	resolver := make(chan []uint64, 1)
	resolver <- v
	rejector := make(chan error, 1)
	t := &Uint64SliceTask{}
	t.Resolver = resolver
	t.Rejector = rejector
	t.Stopper = &done
	t.done = done
	t.closed = true
	return t
}

// RejectedUint64Slice returns a pre-rejected task
//
// Not type safe, use with care.
func RejectedUint64Slice(e error) *Uint64SliceTask {
	done := make(chan struct{}, 1)
	close(done)
	resolver := make(chan []uint64, 1)
	rejector := make(chan error, 1)
	rejector <- e
	t := &Uint64SliceTask{}
	t.Resolver = resolver
	t.Rejector = rejector
	t.Stopper = &done
	t.done = done
	t.closed = true
	return t
}

// Uint8SliceTask represents an asynchronous operation, create new instances with NewUint8Slice.
type Uint8SliceTask struct {
	Task
	Resolver <-chan []uint8
	value    []uint8
}

func (t *Uint8SliceTask) Result() ([]uint8, error) {
	<-t.done
	return t.value, t.err
}

func (t *Uint8SliceTask) MustResult() []uint8 {
	v, e := t.Result()
	goerr.Check(e)
	return v
}

// Uint8SliceTaskInternal is passed into a new task function.
type Uint8SliceTaskInternal struct {
	TaskInternal
	Resolver chan<- []uint8
}

func (ti *Uint8SliceTaskInternal) Resolve(v []uint8) {
	ti.Resolver <- v
}

// NewUint8Slice creates new instances of Uint8SliceTask.
func NewUint8Slice(fn func(t *Uint8SliceTaskInternal)) *Uint8SliceTask {
	// Spin up some channels
	done := make(chan struct{}, 1)
	stopper := make(chan struct{}, 1)
	tResolver := make(chan []uint8, 1)
	tRejector := make(chan error, 1)
	tiResolver := make(chan []uint8, 1)
	tiRejector := make(chan error, 1)

	// Pass those channels into our tasks
	t := &Uint8SliceTask{}
	t.Resolver = tResolver
	t.Rejector = tRejector
	t.Stopper = &stopper
	t.done = done
	ti := &Uint8SliceTaskInternal{}
	ti.Resolver = tiResolver
	ti.Rejector = tiRejector
	ti.Stopper = &stopper

	// Execute the task asynchronously
	go func() {
		// Regardless of what the function does we know that it is done
		defer close(done)

		// Catch any panics and reject them
		defer goerr.Handle(func(e error) {
			t.err = e
			tRejector <- t.err
		})

		// Execute the task
		fn(ti)

		// Read the result in a non blocking manner
		select {
		case v := <-tiResolver:
			t.value = v
			tResolver <- t.value
		case e := <-tiRejector:
			t.err = e
			tRejector <- t.err
		default:
		}
	}()

	// Return the task object
	return t
}

// ResolvedUint8Slice returns a pre-resolved task
//
// Not type safe, use with care.
func ResolvedUint8Slice(v []uint8) *Uint8SliceTask {
	done := make(chan struct{}, 1)
	close(done)
	resolver := make(chan []uint8, 1)
	resolver <- v
	rejector := make(chan error, 1)
	t := &Uint8SliceTask{}
	t.Resolver = resolver
	t.Rejector = rejector
	t.Stopper = &done
	t.done = done
	t.closed = true
	return t
}

// RejectedUint8Slice returns a pre-rejected task
//
// Not type safe, use with care.
func RejectedUint8Slice(e error) *Uint8SliceTask {
	done := make(chan struct{}, 1)
	close(done)
	resolver := make(chan []uint8, 1)
	rejector := make(chan error, 1)
	rejector <- e
	t := &Uint8SliceTask{}
	t.Resolver = resolver
	t.Rejector = rejector
	t.Stopper = &done
	t.done = done
	t.closed = true
	return t
}

// UintptrSliceTask represents an asynchronous operation, create new instances with NewUintptrSlice.
type UintptrSliceTask struct {
	Task
	Resolver <-chan []uintptr
	value    []uintptr
}

func (t *UintptrSliceTask) Result() ([]uintptr, error) {
	<-t.done
	return t.value, t.err
}

func (t *UintptrSliceTask) MustResult() []uintptr {
	v, e := t.Result()
	goerr.Check(e)
	return v
}

// UintptrSliceTaskInternal is passed into a new task function.
type UintptrSliceTaskInternal struct {
	TaskInternal
	Resolver chan<- []uintptr
}

func (ti *UintptrSliceTaskInternal) Resolve(v []uintptr) {
	ti.Resolver <- v
}

// NewUintptrSlice creates new instances of UintptrSliceTask.
func NewUintptrSlice(fn func(t *UintptrSliceTaskInternal)) *UintptrSliceTask {
	// Spin up some channels
	done := make(chan struct{}, 1)
	stopper := make(chan struct{}, 1)
	tResolver := make(chan []uintptr, 1)
	tRejector := make(chan error, 1)
	tiResolver := make(chan []uintptr, 1)
	tiRejector := make(chan error, 1)

	// Pass those channels into our tasks
	t := &UintptrSliceTask{}
	t.Resolver = tResolver
	t.Rejector = tRejector
	t.Stopper = &stopper
	t.done = done
	ti := &UintptrSliceTaskInternal{}
	ti.Resolver = tiResolver
	ti.Rejector = tiRejector
	ti.Stopper = &stopper

	// Execute the task asynchronously
	go func() {
		// Regardless of what the function does we know that it is done
		defer close(done)

		// Catch any panics and reject them
		defer goerr.Handle(func(e error) {
			t.err = e
			tRejector <- t.err
		})

		// Execute the task
		fn(ti)

		// Read the result in a non blocking manner
		select {
		case v := <-tiResolver:
			t.value = v
			tResolver <- t.value
		case e := <-tiRejector:
			t.err = e
			tRejector <- t.err
		default:
		}
	}()

	// Return the task object
	return t
}

// ResolvedUintptrSlice returns a pre-resolved task
//
// Not type safe, use with care.
func ResolvedUintptrSlice(v []uintptr) *UintptrSliceTask {
	done := make(chan struct{}, 1)
	close(done)
	resolver := make(chan []uintptr, 1)
	resolver <- v
	rejector := make(chan error, 1)
	t := &UintptrSliceTask{}
	t.Resolver = resolver
	t.Rejector = rejector
	t.Stopper = &done
	t.done = done
	t.closed = true
	return t
}

// RejectedUintptrSlice returns a pre-rejected task
//
// Not type safe, use with care.
func RejectedUintptrSlice(e error) *UintptrSliceTask {
	done := make(chan struct{}, 1)
	close(done)
	resolver := make(chan []uintptr, 1)
	rejector := make(chan error, 1)
	rejector <- e
	t := &UintptrSliceTask{}
	t.Resolver = resolver
	t.Rejector = rejector
	t.Stopper = &done
	t.done = done
	t.closed = true
	return t
}
