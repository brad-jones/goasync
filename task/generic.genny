package task

import (
	"github.com/brad-jones/goerr"
	"github.com/cheekybits/genny/generic"
)

// Awaitable is a generic type parameter for use with https://github.com/cheekybits/genny
type Awaitable generic.Type

// AwaitableTask represents an asynchronous operation, create new instances with NewAwaitable.
type AwaitableTask struct {
	Task
	Resolver <-chan Awaitable
	value    Awaitable
}

func (t *AwaitableTask) Result() (Awaitable, error) {
	<-t.done
	return t.value, t.err
}

func (t *AwaitableTask) MustResult() Awaitable {
	v, e := t.Result()
	goerr.Check(e)
	return v
}

// AwaitableTaskInternal is passed into a new task function.
type AwaitableTaskInternal struct {
	TaskInternal
	Resolver chan<- Awaitable
}

func (ti *AwaitableTaskInternal) Resolve(v Awaitable) {
	ti.Resolver <- v
}

// NewAwaitable creates new instances of AwaitableTask.
func NewAwaitable(fn func(t *AwaitableTaskInternal)) *AwaitableTask {
	// Spin up some channels
	done := make(chan struct{}, 1)
	stopper := make(chan struct{}, 1)
	tResolver := make(chan Awaitable, 1)
	tRejector := make(chan error, 1)
	tiResolver := make(chan Awaitable, 1)
	tiRejector := make(chan error, 1)

	// Pass those channels into our tasks
	t := &AwaitableTask{}
	t.Resolver = tResolver
	t.Rejector = tRejector
	t.Stopper = &stopper
	t.done = done
	ti := &AwaitableTaskInternal{}
	ti.Resolver = tiResolver
	ti.Rejector = tiRejector
	ti.Stopper = &stopper

	// Execute the task asynchronously
	go func() {
		// Regardless of what the function does we know that it is done
		defer close(done)

		// Catch any panics and reject them
		defer goerr.Handle(func(e error) {
			t.err = e
			tRejector <- t.err
		})

		// Execute the task
		fn(ti)

		// Read the result in a non blocking manner
		select {
		case v := <-tiResolver:
			t.value = v
			tResolver <- t.value
		case e := <-tiRejector:
			t.err = e
			tRejector <- t.err
		default:
		}
	}()

	// Return the task object
	return t
}

// ResolvedAwaitable returns a pre-resolved task
//
// Not type safe, use with care.
func ResolvedAwaitable(v Awaitable) *AwaitableTask {
	done := make(chan struct{}, 1)
	close(done)
	resolver := make(chan Awaitable, 1)
	resolver <- v
	rejector := make(chan error, 1)
	t := &AwaitableTask{}
	t.Resolver = resolver
	t.Rejector = rejector
	t.Stopper = &done
	t.done = done
	t.closed = true
	return t
}

// RejectedAwaitable returns a pre-rejected task
//
// Not type safe, use with care.
func RejectedAwaitable(e error) *AwaitableTask {
	done := make(chan struct{}, 1)
	close(done)
	resolver := make(chan Awaitable, 1)
	rejector := make(chan error, 1)
	rejector <- e
	t := &AwaitableTask{}
	t.Resolver = resolver
	t.Rejector = rejector
	t.Stopper = &done
	t.done = done
	t.closed = true
	return t
}
