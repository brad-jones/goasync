package task

import (
	"github.com/brad-jones/goerr"
	"github.com/cheekybits/genny/generic"
)

// Awaitable is a generic type parameter for use with https://github.com/cheekybits/genny
type Awaitable generic.Type

// AwaitableSliceTask represents an asynchronous operation, create new instances with NewAwaitableSlice.
type AwaitableSliceTask struct {
	Task
	Resolver <-chan []Awaitable
	value    []Awaitable
}

func (t *AwaitableSliceTask) Result() ([]Awaitable, error) {
	<-t.done
	return t.value, t.err
}

func (t *AwaitableSliceTask) MustResult() []Awaitable {
	v, e := t.Result()
	goerr.Check(e)
	return v
}

// AwaitableSliceTaskInternal is passed into a new task function.
type AwaitableSliceTaskInternal struct {
	TaskInternal
	Resolver chan<- []Awaitable
}

func (ti *AwaitableSliceTaskInternal) Resolve(v []Awaitable) {
	ti.Resolver <- v
}

// NewAwaitableSlice creates new instances of AwaitableSliceTask.
func NewAwaitableSlice(fn func(t *AwaitableSliceTaskInternal)) *AwaitableSliceTask {
	// Spin up some channels
	done := make(chan struct{}, 1)
	stopper := make(chan struct{}, 1)
	tResolver := make(chan []Awaitable, 1)
	tRejector := make(chan error, 1)
	tiResolver := make(chan []Awaitable, 1)
	tiRejector := make(chan error, 1)

	// Pass those channels into our tasks
	t := &AwaitableSliceTask{}
	t.Resolver = tResolver
	t.Rejector = tRejector
	t.Stopper = &stopper
	t.done = done
	ti := &AwaitableSliceTaskInternal{}
	ti.Resolver = tiResolver
	ti.Rejector = tiRejector
	ti.Stopper = &stopper

	// Execute the task asynchronously
	go func() {
		// Regardless of what the function does we know that it is done
		defer close(done)

		// Catch any panics and reject them
		defer goerr.Handle(func(e error) {
			t.err = e
			tRejector <- t.err
		})

		// Execute the task
		fn(ti)

		// Read the result in a non blocking manner
		select {
		case v := <-tiResolver:
			t.value = v
			tResolver <- t.value
		case e := <-tiRejector:
			t.err = e
			tRejector <- t.err
		default:
		}
	}()

	// Return the task object
	return t
}

// ResolvedAwaitableSlice returns a pre-resolved task
//
// Not type safe, use with care.
func ResolvedAwaitableSlice(v []Awaitable) *AwaitableSliceTask {
	done := make(chan struct{}, 1)
	close(done)
	resolver := make(chan []Awaitable, 1)
	resolver <- v
	rejector := make(chan error, 1)
	t := &AwaitableSliceTask{}
	t.Resolver = resolver
	t.Rejector = rejector
	t.Stopper = &done
	t.done = done
	t.closed = true
	return t
}

// RejectedAwaitableSlice returns a pre-rejected task
//
// Not type safe, use with care.
func RejectedAwaitableSlice(e error) *AwaitableSliceTask {
	done := make(chan struct{}, 1)
	close(done)
	resolver := make(chan []Awaitable, 1)
	rejector := make(chan error, 1)
	rejector <- e
	t := &AwaitableSliceTask{}
	t.Resolver = resolver
	t.Rejector = rejector
	t.Stopper = &done
	t.done = done
	t.closed = true
	return t
}
