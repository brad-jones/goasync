// This file was automatically generated by genny.
// Any changes will be lost if this file is regenerated.
// see https://github.com/cheekybits/genny

package task

import "github.com/brad-jones/goerr"

// BoolTask represents an asynchronous operation, create new instances with NewBool.
type BoolTask struct {
	Task
	Resolver <-chan bool
	value    bool
}

func (t *BoolTask) Result() (bool, error) {
	<-t.done
	return t.value, t.err
}

func (t *BoolTask) MustResult() bool {
	v, e := t.Result()
	goerr.Check(e)
	return v
}

// BoolTaskInternal is passed into a new task function.
type BoolTaskInternal struct {
	TaskInternal
	Resolver chan<- bool
}

func (ti *BoolTaskInternal) Resolve(v bool) {
	ti.Resolver <- v
}

// NewBool creates new instances of BoolTask.
func NewBool(fn func(t *BoolTaskInternal)) *BoolTask {
	// Spin up some channels
	done := make(chan struct{}, 1)
	stopper := make(chan struct{}, 1)
	tResolver := make(chan bool, 1)
	tRejector := make(chan error, 1)
	tiResolver := make(chan bool, 1)
	tiRejector := make(chan error, 1)

	// Pass those channels into our tasks
	t := &BoolTask{}
	t.Resolver = tResolver
	t.Rejector = tRejector
	t.Stopper = &stopper
	t.done = done
	ti := &BoolTaskInternal{}
	ti.Resolver = tiResolver
	ti.Rejector = tiRejector
	ti.Stopper = &stopper

	// Execute the task asynchronously
	go func() {
		// Regardless of what the function does we know that it is done
		defer close(done)

		// Catch any panics and reject them
		defer goerr.Handle(func(e error) {
			t.err = e
			tRejector <- t.err
		})

		// Execute the task
		fn(ti)

		// Read the result in a non blocking manner
		select {
		case v := <-tiResolver:
			t.value = v
			tResolver <- t.value
		case e := <-tiRejector:
			t.err = e
			tRejector <- t.err
		default:
		}
	}()

	// Return the task object
	return t
}

// ResolvedBool returns a pre-resolved task
//
// Not type safe, use with care.
func ResolvedBool(v bool) *BoolTask {
	done := make(chan struct{}, 1)
	close(done)
	resolver := make(chan bool, 1)
	resolver <- v
	rejector := make(chan error, 1)
	t := &BoolTask{}
	t.Resolver = resolver
	t.Rejector = rejector
	t.Stopper = &done
	t.done = done
	t.closed = true
	return t
}

// RejectedBool returns a pre-rejected task
//
// Not type safe, use with care.
func RejectedBool(e error) *BoolTask {
	done := make(chan struct{}, 1)
	close(done)
	resolver := make(chan bool, 1)
	rejector := make(chan error, 1)
	rejector <- e
	t := &BoolTask{}
	t.Resolver = resolver
	t.Rejector = rejector
	t.Stopper = &done
	t.done = done
	t.closed = true
	return t
}

// ByteTask represents an asynchronous operation, create new instances with NewByte.
type ByteTask struct {
	Task
	Resolver <-chan byte
	value    byte
}

func (t *ByteTask) Result() (byte, error) {
	<-t.done
	return t.value, t.err
}

func (t *ByteTask) MustResult() byte {
	v, e := t.Result()
	goerr.Check(e)
	return v
}

// ByteTaskInternal is passed into a new task function.
type ByteTaskInternal struct {
	TaskInternal
	Resolver chan<- byte
}

func (ti *ByteTaskInternal) Resolve(v byte) {
	ti.Resolver <- v
}

// NewByte creates new instances of ByteTask.
func NewByte(fn func(t *ByteTaskInternal)) *ByteTask {
	// Spin up some channels
	done := make(chan struct{}, 1)
	stopper := make(chan struct{}, 1)
	tResolver := make(chan byte, 1)
	tRejector := make(chan error, 1)
	tiResolver := make(chan byte, 1)
	tiRejector := make(chan error, 1)

	// Pass those channels into our tasks
	t := &ByteTask{}
	t.Resolver = tResolver
	t.Rejector = tRejector
	t.Stopper = &stopper
	t.done = done
	ti := &ByteTaskInternal{}
	ti.Resolver = tiResolver
	ti.Rejector = tiRejector
	ti.Stopper = &stopper

	// Execute the task asynchronously
	go func() {
		// Regardless of what the function does we know that it is done
		defer close(done)

		// Catch any panics and reject them
		defer goerr.Handle(func(e error) {
			t.err = e
			tRejector <- t.err
		})

		// Execute the task
		fn(ti)

		// Read the result in a non blocking manner
		select {
		case v := <-tiResolver:
			t.value = v
			tResolver <- t.value
		case e := <-tiRejector:
			t.err = e
			tRejector <- t.err
		default:
		}
	}()

	// Return the task object
	return t
}

// ResolvedByte returns a pre-resolved task
//
// Not type safe, use with care.
func ResolvedByte(v byte) *ByteTask {
	done := make(chan struct{}, 1)
	close(done)
	resolver := make(chan byte, 1)
	resolver <- v
	rejector := make(chan error, 1)
	t := &ByteTask{}
	t.Resolver = resolver
	t.Rejector = rejector
	t.Stopper = &done
	t.done = done
	t.closed = true
	return t
}

// RejectedByte returns a pre-rejected task
//
// Not type safe, use with care.
func RejectedByte(e error) *ByteTask {
	done := make(chan struct{}, 1)
	close(done)
	resolver := make(chan byte, 1)
	rejector := make(chan error, 1)
	rejector <- e
	t := &ByteTask{}
	t.Resolver = resolver
	t.Rejector = rejector
	t.Stopper = &done
	t.done = done
	t.closed = true
	return t
}

// Complex128Task represents an asynchronous operation, create new instances with NewComplex128.
type Complex128Task struct {
	Task
	Resolver <-chan complex128
	value    complex128
}

func (t *Complex128Task) Result() (complex128, error) {
	<-t.done
	return t.value, t.err
}

func (t *Complex128Task) MustResult() complex128 {
	v, e := t.Result()
	goerr.Check(e)
	return v
}

// Complex128TaskInternal is passed into a new task function.
type Complex128TaskInternal struct {
	TaskInternal
	Resolver chan<- complex128
}

func (ti *Complex128TaskInternal) Resolve(v complex128) {
	ti.Resolver <- v
}

// NewComplex128 creates new instances of Complex128Task.
func NewComplex128(fn func(t *Complex128TaskInternal)) *Complex128Task {
	// Spin up some channels
	done := make(chan struct{}, 1)
	stopper := make(chan struct{}, 1)
	tResolver := make(chan complex128, 1)
	tRejector := make(chan error, 1)
	tiResolver := make(chan complex128, 1)
	tiRejector := make(chan error, 1)

	// Pass those channels into our tasks
	t := &Complex128Task{}
	t.Resolver = tResolver
	t.Rejector = tRejector
	t.Stopper = &stopper
	t.done = done
	ti := &Complex128TaskInternal{}
	ti.Resolver = tiResolver
	ti.Rejector = tiRejector
	ti.Stopper = &stopper

	// Execute the task asynchronously
	go func() {
		// Regardless of what the function does we know that it is done
		defer close(done)

		// Catch any panics and reject them
		defer goerr.Handle(func(e error) {
			t.err = e
			tRejector <- t.err
		})

		// Execute the task
		fn(ti)

		// Read the result in a non blocking manner
		select {
		case v := <-tiResolver:
			t.value = v
			tResolver <- t.value
		case e := <-tiRejector:
			t.err = e
			tRejector <- t.err
		default:
		}
	}()

	// Return the task object
	return t
}

// ResolvedComplex128 returns a pre-resolved task
//
// Not type safe, use with care.
func ResolvedComplex128(v complex128) *Complex128Task {
	done := make(chan struct{}, 1)
	close(done)
	resolver := make(chan complex128, 1)
	resolver <- v
	rejector := make(chan error, 1)
	t := &Complex128Task{}
	t.Resolver = resolver
	t.Rejector = rejector
	t.Stopper = &done
	t.done = done
	t.closed = true
	return t
}

// RejectedComplex128 returns a pre-rejected task
//
// Not type safe, use with care.
func RejectedComplex128(e error) *Complex128Task {
	done := make(chan struct{}, 1)
	close(done)
	resolver := make(chan complex128, 1)
	rejector := make(chan error, 1)
	rejector <- e
	t := &Complex128Task{}
	t.Resolver = resolver
	t.Rejector = rejector
	t.Stopper = &done
	t.done = done
	t.closed = true
	return t
}

// Complex64Task represents an asynchronous operation, create new instances with NewComplex64.
type Complex64Task struct {
	Task
	Resolver <-chan complex64
	value    complex64
}

func (t *Complex64Task) Result() (complex64, error) {
	<-t.done
	return t.value, t.err
}

func (t *Complex64Task) MustResult() complex64 {
	v, e := t.Result()
	goerr.Check(e)
	return v
}

// Complex64TaskInternal is passed into a new task function.
type Complex64TaskInternal struct {
	TaskInternal
	Resolver chan<- complex64
}

func (ti *Complex64TaskInternal) Resolve(v complex64) {
	ti.Resolver <- v
}

// NewComplex64 creates new instances of Complex64Task.
func NewComplex64(fn func(t *Complex64TaskInternal)) *Complex64Task {
	// Spin up some channels
	done := make(chan struct{}, 1)
	stopper := make(chan struct{}, 1)
	tResolver := make(chan complex64, 1)
	tRejector := make(chan error, 1)
	tiResolver := make(chan complex64, 1)
	tiRejector := make(chan error, 1)

	// Pass those channels into our tasks
	t := &Complex64Task{}
	t.Resolver = tResolver
	t.Rejector = tRejector
	t.Stopper = &stopper
	t.done = done
	ti := &Complex64TaskInternal{}
	ti.Resolver = tiResolver
	ti.Rejector = tiRejector
	ti.Stopper = &stopper

	// Execute the task asynchronously
	go func() {
		// Regardless of what the function does we know that it is done
		defer close(done)

		// Catch any panics and reject them
		defer goerr.Handle(func(e error) {
			t.err = e
			tRejector <- t.err
		})

		// Execute the task
		fn(ti)

		// Read the result in a non blocking manner
		select {
		case v := <-tiResolver:
			t.value = v
			tResolver <- t.value
		case e := <-tiRejector:
			t.err = e
			tRejector <- t.err
		default:
		}
	}()

	// Return the task object
	return t
}

// ResolvedComplex64 returns a pre-resolved task
//
// Not type safe, use with care.
func ResolvedComplex64(v complex64) *Complex64Task {
	done := make(chan struct{}, 1)
	close(done)
	resolver := make(chan complex64, 1)
	resolver <- v
	rejector := make(chan error, 1)
	t := &Complex64Task{}
	t.Resolver = resolver
	t.Rejector = rejector
	t.Stopper = &done
	t.done = done
	t.closed = true
	return t
}

// RejectedComplex64 returns a pre-rejected task
//
// Not type safe, use with care.
func RejectedComplex64(e error) *Complex64Task {
	done := make(chan struct{}, 1)
	close(done)
	resolver := make(chan complex64, 1)
	rejector := make(chan error, 1)
	rejector <- e
	t := &Complex64Task{}
	t.Resolver = resolver
	t.Rejector = rejector
	t.Stopper = &done
	t.done = done
	t.closed = true
	return t
}

// ErrorTask represents an asynchronous operation, create new instances with NewError.
type ErrorTask struct {
	Task
	Resolver <-chan error
	value    error
}

func (t *ErrorTask) Result() (error, error) {
	<-t.done
	return t.value, t.err
}

func (t *ErrorTask) MustResult() error {
	v, e := t.Result()
	goerr.Check(e)
	return v
}

// ErrorTaskInternal is passed into a new task function.
type ErrorTaskInternal struct {
	TaskInternal
	Resolver chan<- error
}

func (ti *ErrorTaskInternal) Resolve(v error) {
	ti.Resolver <- v
}

// NewError creates new instances of ErrorTask.
func NewError(fn func(t *ErrorTaskInternal)) *ErrorTask {
	// Spin up some channels
	done := make(chan struct{}, 1)
	stopper := make(chan struct{}, 1)
	tResolver := make(chan error, 1)
	tRejector := make(chan error, 1)
	tiResolver := make(chan error, 1)
	tiRejector := make(chan error, 1)

	// Pass those channels into our tasks
	t := &ErrorTask{}
	t.Resolver = tResolver
	t.Rejector = tRejector
	t.Stopper = &stopper
	t.done = done
	ti := &ErrorTaskInternal{}
	ti.Resolver = tiResolver
	ti.Rejector = tiRejector
	ti.Stopper = &stopper

	// Execute the task asynchronously
	go func() {
		// Regardless of what the function does we know that it is done
		defer close(done)

		// Catch any panics and reject them
		defer goerr.Handle(func(e error) {
			t.err = e
			tRejector <- t.err
		})

		// Execute the task
		fn(ti)

		// Read the result in a non blocking manner
		select {
		case v := <-tiResolver:
			t.value = v
			tResolver <- t.value
		case e := <-tiRejector:
			t.err = e
			tRejector <- t.err
		default:
		}
	}()

	// Return the task object
	return t
}

// ResolvedError returns a pre-resolved task
//
// Not type safe, use with care.
func ResolvedError(v error) *ErrorTask {
	done := make(chan struct{}, 1)
	close(done)
	resolver := make(chan error, 1)
	resolver <- v
	rejector := make(chan error, 1)
	t := &ErrorTask{}
	t.Resolver = resolver
	t.Rejector = rejector
	t.Stopper = &done
	t.done = done
	t.closed = true
	return t
}

// RejectedError returns a pre-rejected task
//
// Not type safe, use with care.
func RejectedError(e error) *ErrorTask {
	done := make(chan struct{}, 1)
	close(done)
	resolver := make(chan error, 1)
	rejector := make(chan error, 1)
	rejector <- e
	t := &ErrorTask{}
	t.Resolver = resolver
	t.Rejector = rejector
	t.Stopper = &done
	t.done = done
	t.closed = true
	return t
}

// Float32Task represents an asynchronous operation, create new instances with NewFloat32.
type Float32Task struct {
	Task
	Resolver <-chan float32
	value    float32
}

func (t *Float32Task) Result() (float32, error) {
	<-t.done
	return t.value, t.err
}

func (t *Float32Task) MustResult() float32 {
	v, e := t.Result()
	goerr.Check(e)
	return v
}

// Float32TaskInternal is passed into a new task function.
type Float32TaskInternal struct {
	TaskInternal
	Resolver chan<- float32
}

func (ti *Float32TaskInternal) Resolve(v float32) {
	ti.Resolver <- v
}

// NewFloat32 creates new instances of Float32Task.
func NewFloat32(fn func(t *Float32TaskInternal)) *Float32Task {
	// Spin up some channels
	done := make(chan struct{}, 1)
	stopper := make(chan struct{}, 1)
	tResolver := make(chan float32, 1)
	tRejector := make(chan error, 1)
	tiResolver := make(chan float32, 1)
	tiRejector := make(chan error, 1)

	// Pass those channels into our tasks
	t := &Float32Task{}
	t.Resolver = tResolver
	t.Rejector = tRejector
	t.Stopper = &stopper
	t.done = done
	ti := &Float32TaskInternal{}
	ti.Resolver = tiResolver
	ti.Rejector = tiRejector
	ti.Stopper = &stopper

	// Execute the task asynchronously
	go func() {
		// Regardless of what the function does we know that it is done
		defer close(done)

		// Catch any panics and reject them
		defer goerr.Handle(func(e error) {
			t.err = e
			tRejector <- t.err
		})

		// Execute the task
		fn(ti)

		// Read the result in a non blocking manner
		select {
		case v := <-tiResolver:
			t.value = v
			tResolver <- t.value
		case e := <-tiRejector:
			t.err = e
			tRejector <- t.err
		default:
		}
	}()

	// Return the task object
	return t
}

// ResolvedFloat32 returns a pre-resolved task
//
// Not type safe, use with care.
func ResolvedFloat32(v float32) *Float32Task {
	done := make(chan struct{}, 1)
	close(done)
	resolver := make(chan float32, 1)
	resolver <- v
	rejector := make(chan error, 1)
	t := &Float32Task{}
	t.Resolver = resolver
	t.Rejector = rejector
	t.Stopper = &done
	t.done = done
	t.closed = true
	return t
}

// RejectedFloat32 returns a pre-rejected task
//
// Not type safe, use with care.
func RejectedFloat32(e error) *Float32Task {
	done := make(chan struct{}, 1)
	close(done)
	resolver := make(chan float32, 1)
	rejector := make(chan error, 1)
	rejector <- e
	t := &Float32Task{}
	t.Resolver = resolver
	t.Rejector = rejector
	t.Stopper = &done
	t.done = done
	t.closed = true
	return t
}

// Float64Task represents an asynchronous operation, create new instances with NewFloat64.
type Float64Task struct {
	Task
	Resolver <-chan float64
	value    float64
}

func (t *Float64Task) Result() (float64, error) {
	<-t.done
	return t.value, t.err
}

func (t *Float64Task) MustResult() float64 {
	v, e := t.Result()
	goerr.Check(e)
	return v
}

// Float64TaskInternal is passed into a new task function.
type Float64TaskInternal struct {
	TaskInternal
	Resolver chan<- float64
}

func (ti *Float64TaskInternal) Resolve(v float64) {
	ti.Resolver <- v
}

// NewFloat64 creates new instances of Float64Task.
func NewFloat64(fn func(t *Float64TaskInternal)) *Float64Task {
	// Spin up some channels
	done := make(chan struct{}, 1)
	stopper := make(chan struct{}, 1)
	tResolver := make(chan float64, 1)
	tRejector := make(chan error, 1)
	tiResolver := make(chan float64, 1)
	tiRejector := make(chan error, 1)

	// Pass those channels into our tasks
	t := &Float64Task{}
	t.Resolver = tResolver
	t.Rejector = tRejector
	t.Stopper = &stopper
	t.done = done
	ti := &Float64TaskInternal{}
	ti.Resolver = tiResolver
	ti.Rejector = tiRejector
	ti.Stopper = &stopper

	// Execute the task asynchronously
	go func() {
		// Regardless of what the function does we know that it is done
		defer close(done)

		// Catch any panics and reject them
		defer goerr.Handle(func(e error) {
			t.err = e
			tRejector <- t.err
		})

		// Execute the task
		fn(ti)

		// Read the result in a non blocking manner
		select {
		case v := <-tiResolver:
			t.value = v
			tResolver <- t.value
		case e := <-tiRejector:
			t.err = e
			tRejector <- t.err
		default:
		}
	}()

	// Return the task object
	return t
}

// ResolvedFloat64 returns a pre-resolved task
//
// Not type safe, use with care.
func ResolvedFloat64(v float64) *Float64Task {
	done := make(chan struct{}, 1)
	close(done)
	resolver := make(chan float64, 1)
	resolver <- v
	rejector := make(chan error, 1)
	t := &Float64Task{}
	t.Resolver = resolver
	t.Rejector = rejector
	t.Stopper = &done
	t.done = done
	t.closed = true
	return t
}

// RejectedFloat64 returns a pre-rejected task
//
// Not type safe, use with care.
func RejectedFloat64(e error) *Float64Task {
	done := make(chan struct{}, 1)
	close(done)
	resolver := make(chan float64, 1)
	rejector := make(chan error, 1)
	rejector <- e
	t := &Float64Task{}
	t.Resolver = resolver
	t.Rejector = rejector
	t.Stopper = &done
	t.done = done
	t.closed = true
	return t
}

// IntTask represents an asynchronous operation, create new instances with NewInt.
type IntTask struct {
	Task
	Resolver <-chan int
	value    int
}

func (t *IntTask) Result() (int, error) {
	<-t.done
	return t.value, t.err
}

func (t *IntTask) MustResult() int {
	v, e := t.Result()
	goerr.Check(e)
	return v
}

// IntTaskInternal is passed into a new task function.
type IntTaskInternal struct {
	TaskInternal
	Resolver chan<- int
}

func (ti *IntTaskInternal) Resolve(v int) {
	ti.Resolver <- v
}

// NewInt creates new instances of IntTask.
func NewInt(fn func(t *IntTaskInternal)) *IntTask {
	// Spin up some channels
	done := make(chan struct{}, 1)
	stopper := make(chan struct{}, 1)
	tResolver := make(chan int, 1)
	tRejector := make(chan error, 1)
	tiResolver := make(chan int, 1)
	tiRejector := make(chan error, 1)

	// Pass those channels into our tasks
	t := &IntTask{}
	t.Resolver = tResolver
	t.Rejector = tRejector
	t.Stopper = &stopper
	t.done = done
	ti := &IntTaskInternal{}
	ti.Resolver = tiResolver
	ti.Rejector = tiRejector
	ti.Stopper = &stopper

	// Execute the task asynchronously
	go func() {
		// Regardless of what the function does we know that it is done
		defer close(done)

		// Catch any panics and reject them
		defer goerr.Handle(func(e error) {
			t.err = e
			tRejector <- t.err
		})

		// Execute the task
		fn(ti)

		// Read the result in a non blocking manner
		select {
		case v := <-tiResolver:
			t.value = v
			tResolver <- t.value
		case e := <-tiRejector:
			t.err = e
			tRejector <- t.err
		default:
		}
	}()

	// Return the task object
	return t
}

// ResolvedInt returns a pre-resolved task
//
// Not type safe, use with care.
func ResolvedInt(v int) *IntTask {
	done := make(chan struct{}, 1)
	close(done)
	resolver := make(chan int, 1)
	resolver <- v
	rejector := make(chan error, 1)
	t := &IntTask{}
	t.Resolver = resolver
	t.Rejector = rejector
	t.Stopper = &done
	t.done = done
	t.closed = true
	return t
}

// RejectedInt returns a pre-rejected task
//
// Not type safe, use with care.
func RejectedInt(e error) *IntTask {
	done := make(chan struct{}, 1)
	close(done)
	resolver := make(chan int, 1)
	rejector := make(chan error, 1)
	rejector <- e
	t := &IntTask{}
	t.Resolver = resolver
	t.Rejector = rejector
	t.Stopper = &done
	t.done = done
	t.closed = true
	return t
}

// Int16Task represents an asynchronous operation, create new instances with NewInt16.
type Int16Task struct {
	Task
	Resolver <-chan int16
	value    int16
}

func (t *Int16Task) Result() (int16, error) {
	<-t.done
	return t.value, t.err
}

func (t *Int16Task) MustResult() int16 {
	v, e := t.Result()
	goerr.Check(e)
	return v
}

// Int16TaskInternal is passed into a new task function.
type Int16TaskInternal struct {
	TaskInternal
	Resolver chan<- int16
}

func (ti *Int16TaskInternal) Resolve(v int16) {
	ti.Resolver <- v
}

// NewInt16 creates new instances of Int16Task.
func NewInt16(fn func(t *Int16TaskInternal)) *Int16Task {
	// Spin up some channels
	done := make(chan struct{}, 1)
	stopper := make(chan struct{}, 1)
	tResolver := make(chan int16, 1)
	tRejector := make(chan error, 1)
	tiResolver := make(chan int16, 1)
	tiRejector := make(chan error, 1)

	// Pass those channels into our tasks
	t := &Int16Task{}
	t.Resolver = tResolver
	t.Rejector = tRejector
	t.Stopper = &stopper
	t.done = done
	ti := &Int16TaskInternal{}
	ti.Resolver = tiResolver
	ti.Rejector = tiRejector
	ti.Stopper = &stopper

	// Execute the task asynchronously
	go func() {
		// Regardless of what the function does we know that it is done
		defer close(done)

		// Catch any panics and reject them
		defer goerr.Handle(func(e error) {
			t.err = e
			tRejector <- t.err
		})

		// Execute the task
		fn(ti)

		// Read the result in a non blocking manner
		select {
		case v := <-tiResolver:
			t.value = v
			tResolver <- t.value
		case e := <-tiRejector:
			t.err = e
			tRejector <- t.err
		default:
		}
	}()

	// Return the task object
	return t
}

// ResolvedInt16 returns a pre-resolved task
//
// Not type safe, use with care.
func ResolvedInt16(v int16) *Int16Task {
	done := make(chan struct{}, 1)
	close(done)
	resolver := make(chan int16, 1)
	resolver <- v
	rejector := make(chan error, 1)
	t := &Int16Task{}
	t.Resolver = resolver
	t.Rejector = rejector
	t.Stopper = &done
	t.done = done
	t.closed = true
	return t
}

// RejectedInt16 returns a pre-rejected task
//
// Not type safe, use with care.
func RejectedInt16(e error) *Int16Task {
	done := make(chan struct{}, 1)
	close(done)
	resolver := make(chan int16, 1)
	rejector := make(chan error, 1)
	rejector <- e
	t := &Int16Task{}
	t.Resolver = resolver
	t.Rejector = rejector
	t.Stopper = &done
	t.done = done
	t.closed = true
	return t
}

// Int32Task represents an asynchronous operation, create new instances with NewInt32.
type Int32Task struct {
	Task
	Resolver <-chan int32
	value    int32
}

func (t *Int32Task) Result() (int32, error) {
	<-t.done
	return t.value, t.err
}

func (t *Int32Task) MustResult() int32 {
	v, e := t.Result()
	goerr.Check(e)
	return v
}

// Int32TaskInternal is passed into a new task function.
type Int32TaskInternal struct {
	TaskInternal
	Resolver chan<- int32
}

func (ti *Int32TaskInternal) Resolve(v int32) {
	ti.Resolver <- v
}

// NewInt32 creates new instances of Int32Task.
func NewInt32(fn func(t *Int32TaskInternal)) *Int32Task {
	// Spin up some channels
	done := make(chan struct{}, 1)
	stopper := make(chan struct{}, 1)
	tResolver := make(chan int32, 1)
	tRejector := make(chan error, 1)
	tiResolver := make(chan int32, 1)
	tiRejector := make(chan error, 1)

	// Pass those channels into our tasks
	t := &Int32Task{}
	t.Resolver = tResolver
	t.Rejector = tRejector
	t.Stopper = &stopper
	t.done = done
	ti := &Int32TaskInternal{}
	ti.Resolver = tiResolver
	ti.Rejector = tiRejector
	ti.Stopper = &stopper

	// Execute the task asynchronously
	go func() {
		// Regardless of what the function does we know that it is done
		defer close(done)

		// Catch any panics and reject them
		defer goerr.Handle(func(e error) {
			t.err = e
			tRejector <- t.err
		})

		// Execute the task
		fn(ti)

		// Read the result in a non blocking manner
		select {
		case v := <-tiResolver:
			t.value = v
			tResolver <- t.value
		case e := <-tiRejector:
			t.err = e
			tRejector <- t.err
		default:
		}
	}()

	// Return the task object
	return t
}

// ResolvedInt32 returns a pre-resolved task
//
// Not type safe, use with care.
func ResolvedInt32(v int32) *Int32Task {
	done := make(chan struct{}, 1)
	close(done)
	resolver := make(chan int32, 1)
	resolver <- v
	rejector := make(chan error, 1)
	t := &Int32Task{}
	t.Resolver = resolver
	t.Rejector = rejector
	t.Stopper = &done
	t.done = done
	t.closed = true
	return t
}

// RejectedInt32 returns a pre-rejected task
//
// Not type safe, use with care.
func RejectedInt32(e error) *Int32Task {
	done := make(chan struct{}, 1)
	close(done)
	resolver := make(chan int32, 1)
	rejector := make(chan error, 1)
	rejector <- e
	t := &Int32Task{}
	t.Resolver = resolver
	t.Rejector = rejector
	t.Stopper = &done
	t.done = done
	t.closed = true
	return t
}

// Int64Task represents an asynchronous operation, create new instances with NewInt64.
type Int64Task struct {
	Task
	Resolver <-chan int64
	value    int64
}

func (t *Int64Task) Result() (int64, error) {
	<-t.done
	return t.value, t.err
}

func (t *Int64Task) MustResult() int64 {
	v, e := t.Result()
	goerr.Check(e)
	return v
}

// Int64TaskInternal is passed into a new task function.
type Int64TaskInternal struct {
	TaskInternal
	Resolver chan<- int64
}

func (ti *Int64TaskInternal) Resolve(v int64) {
	ti.Resolver <- v
}

// NewInt64 creates new instances of Int64Task.
func NewInt64(fn func(t *Int64TaskInternal)) *Int64Task {
	// Spin up some channels
	done := make(chan struct{}, 1)
	stopper := make(chan struct{}, 1)
	tResolver := make(chan int64, 1)
	tRejector := make(chan error, 1)
	tiResolver := make(chan int64, 1)
	tiRejector := make(chan error, 1)

	// Pass those channels into our tasks
	t := &Int64Task{}
	t.Resolver = tResolver
	t.Rejector = tRejector
	t.Stopper = &stopper
	t.done = done
	ti := &Int64TaskInternal{}
	ti.Resolver = tiResolver
	ti.Rejector = tiRejector
	ti.Stopper = &stopper

	// Execute the task asynchronously
	go func() {
		// Regardless of what the function does we know that it is done
		defer close(done)

		// Catch any panics and reject them
		defer goerr.Handle(func(e error) {
			t.err = e
			tRejector <- t.err
		})

		// Execute the task
		fn(ti)

		// Read the result in a non blocking manner
		select {
		case v := <-tiResolver:
			t.value = v
			tResolver <- t.value
		case e := <-tiRejector:
			t.err = e
			tRejector <- t.err
		default:
		}
	}()

	// Return the task object
	return t
}

// ResolvedInt64 returns a pre-resolved task
//
// Not type safe, use with care.
func ResolvedInt64(v int64) *Int64Task {
	done := make(chan struct{}, 1)
	close(done)
	resolver := make(chan int64, 1)
	resolver <- v
	rejector := make(chan error, 1)
	t := &Int64Task{}
	t.Resolver = resolver
	t.Rejector = rejector
	t.Stopper = &done
	t.done = done
	t.closed = true
	return t
}

// RejectedInt64 returns a pre-rejected task
//
// Not type safe, use with care.
func RejectedInt64(e error) *Int64Task {
	done := make(chan struct{}, 1)
	close(done)
	resolver := make(chan int64, 1)
	rejector := make(chan error, 1)
	rejector <- e
	t := &Int64Task{}
	t.Resolver = resolver
	t.Rejector = rejector
	t.Stopper = &done
	t.done = done
	t.closed = true
	return t
}

// Int8Task represents an asynchronous operation, create new instances with NewInt8.
type Int8Task struct {
	Task
	Resolver <-chan int8
	value    int8
}

func (t *Int8Task) Result() (int8, error) {
	<-t.done
	return t.value, t.err
}

func (t *Int8Task) MustResult() int8 {
	v, e := t.Result()
	goerr.Check(e)
	return v
}

// Int8TaskInternal is passed into a new task function.
type Int8TaskInternal struct {
	TaskInternal
	Resolver chan<- int8
}

func (ti *Int8TaskInternal) Resolve(v int8) {
	ti.Resolver <- v
}

// NewInt8 creates new instances of Int8Task.
func NewInt8(fn func(t *Int8TaskInternal)) *Int8Task {
	// Spin up some channels
	done := make(chan struct{}, 1)
	stopper := make(chan struct{}, 1)
	tResolver := make(chan int8, 1)
	tRejector := make(chan error, 1)
	tiResolver := make(chan int8, 1)
	tiRejector := make(chan error, 1)

	// Pass those channels into our tasks
	t := &Int8Task{}
	t.Resolver = tResolver
	t.Rejector = tRejector
	t.Stopper = &stopper
	t.done = done
	ti := &Int8TaskInternal{}
	ti.Resolver = tiResolver
	ti.Rejector = tiRejector
	ti.Stopper = &stopper

	// Execute the task asynchronously
	go func() {
		// Regardless of what the function does we know that it is done
		defer close(done)

		// Catch any panics and reject them
		defer goerr.Handle(func(e error) {
			t.err = e
			tRejector <- t.err
		})

		// Execute the task
		fn(ti)

		// Read the result in a non blocking manner
		select {
		case v := <-tiResolver:
			t.value = v
			tResolver <- t.value
		case e := <-tiRejector:
			t.err = e
			tRejector <- t.err
		default:
		}
	}()

	// Return the task object
	return t
}

// ResolvedInt8 returns a pre-resolved task
//
// Not type safe, use with care.
func ResolvedInt8(v int8) *Int8Task {
	done := make(chan struct{}, 1)
	close(done)
	resolver := make(chan int8, 1)
	resolver <- v
	rejector := make(chan error, 1)
	t := &Int8Task{}
	t.Resolver = resolver
	t.Rejector = rejector
	t.Stopper = &done
	t.done = done
	t.closed = true
	return t
}

// RejectedInt8 returns a pre-rejected task
//
// Not type safe, use with care.
func RejectedInt8(e error) *Int8Task {
	done := make(chan struct{}, 1)
	close(done)
	resolver := make(chan int8, 1)
	rejector := make(chan error, 1)
	rejector <- e
	t := &Int8Task{}
	t.Resolver = resolver
	t.Rejector = rejector
	t.Stopper = &done
	t.done = done
	t.closed = true
	return t
}

// RuneTask represents an asynchronous operation, create new instances with NewRune.
type RuneTask struct {
	Task
	Resolver <-chan rune
	value    rune
}

func (t *RuneTask) Result() (rune, error) {
	<-t.done
	return t.value, t.err
}

func (t *RuneTask) MustResult() rune {
	v, e := t.Result()
	goerr.Check(e)
	return v
}

// RuneTaskInternal is passed into a new task function.
type RuneTaskInternal struct {
	TaskInternal
	Resolver chan<- rune
}

func (ti *RuneTaskInternal) Resolve(v rune) {
	ti.Resolver <- v
}

// NewRune creates new instances of RuneTask.
func NewRune(fn func(t *RuneTaskInternal)) *RuneTask {
	// Spin up some channels
	done := make(chan struct{}, 1)
	stopper := make(chan struct{}, 1)
	tResolver := make(chan rune, 1)
	tRejector := make(chan error, 1)
	tiResolver := make(chan rune, 1)
	tiRejector := make(chan error, 1)

	// Pass those channels into our tasks
	t := &RuneTask{}
	t.Resolver = tResolver
	t.Rejector = tRejector
	t.Stopper = &stopper
	t.done = done
	ti := &RuneTaskInternal{}
	ti.Resolver = tiResolver
	ti.Rejector = tiRejector
	ti.Stopper = &stopper

	// Execute the task asynchronously
	go func() {
		// Regardless of what the function does we know that it is done
		defer close(done)

		// Catch any panics and reject them
		defer goerr.Handle(func(e error) {
			t.err = e
			tRejector <- t.err
		})

		// Execute the task
		fn(ti)

		// Read the result in a non blocking manner
		select {
		case v := <-tiResolver:
			t.value = v
			tResolver <- t.value
		case e := <-tiRejector:
			t.err = e
			tRejector <- t.err
		default:
		}
	}()

	// Return the task object
	return t
}

// ResolvedRune returns a pre-resolved task
//
// Not type safe, use with care.
func ResolvedRune(v rune) *RuneTask {
	done := make(chan struct{}, 1)
	close(done)
	resolver := make(chan rune, 1)
	resolver <- v
	rejector := make(chan error, 1)
	t := &RuneTask{}
	t.Resolver = resolver
	t.Rejector = rejector
	t.Stopper = &done
	t.done = done
	t.closed = true
	return t
}

// RejectedRune returns a pre-rejected task
//
// Not type safe, use with care.
func RejectedRune(e error) *RuneTask {
	done := make(chan struct{}, 1)
	close(done)
	resolver := make(chan rune, 1)
	rejector := make(chan error, 1)
	rejector <- e
	t := &RuneTask{}
	t.Resolver = resolver
	t.Rejector = rejector
	t.Stopper = &done
	t.done = done
	t.closed = true
	return t
}

// StringTask represents an asynchronous operation, create new instances with NewString.
type StringTask struct {
	Task
	Resolver <-chan string
	value    string
}

func (t *StringTask) Result() (string, error) {
	<-t.done
	return t.value, t.err
}

func (t *StringTask) MustResult() string {
	v, e := t.Result()
	goerr.Check(e)
	return v
}

// StringTaskInternal is passed into a new task function.
type StringTaskInternal struct {
	TaskInternal
	Resolver chan<- string
}

func (ti *StringTaskInternal) Resolve(v string) {
	ti.Resolver <- v
}

// NewString creates new instances of StringTask.
func NewString(fn func(t *StringTaskInternal)) *StringTask {
	// Spin up some channels
	done := make(chan struct{}, 1)
	stopper := make(chan struct{}, 1)
	tResolver := make(chan string, 1)
	tRejector := make(chan error, 1)
	tiResolver := make(chan string, 1)
	tiRejector := make(chan error, 1)

	// Pass those channels into our tasks
	t := &StringTask{}
	t.Resolver = tResolver
	t.Rejector = tRejector
	t.Stopper = &stopper
	t.done = done
	ti := &StringTaskInternal{}
	ti.Resolver = tiResolver
	ti.Rejector = tiRejector
	ti.Stopper = &stopper

	// Execute the task asynchronously
	go func() {
		// Regardless of what the function does we know that it is done
		defer close(done)

		// Catch any panics and reject them
		defer goerr.Handle(func(e error) {
			t.err = e
			tRejector <- t.err
		})

		// Execute the task
		fn(ti)

		// Read the result in a non blocking manner
		select {
		case v := <-tiResolver:
			t.value = v
			tResolver <- t.value
		case e := <-tiRejector:
			t.err = e
			tRejector <- t.err
		default:
		}
	}()

	// Return the task object
	return t
}

// ResolvedString returns a pre-resolved task
//
// Not type safe, use with care.
func ResolvedString(v string) *StringTask {
	done := make(chan struct{}, 1)
	close(done)
	resolver := make(chan string, 1)
	resolver <- v
	rejector := make(chan error, 1)
	t := &StringTask{}
	t.Resolver = resolver
	t.Rejector = rejector
	t.Stopper = &done
	t.done = done
	t.closed = true
	return t
}

// RejectedString returns a pre-rejected task
//
// Not type safe, use with care.
func RejectedString(e error) *StringTask {
	done := make(chan struct{}, 1)
	close(done)
	resolver := make(chan string, 1)
	rejector := make(chan error, 1)
	rejector <- e
	t := &StringTask{}
	t.Resolver = resolver
	t.Rejector = rejector
	t.Stopper = &done
	t.done = done
	t.closed = true
	return t
}

// UintTask represents an asynchronous operation, create new instances with NewUint.
type UintTask struct {
	Task
	Resolver <-chan uint
	value    uint
}

func (t *UintTask) Result() (uint, error) {
	<-t.done
	return t.value, t.err
}

func (t *UintTask) MustResult() uint {
	v, e := t.Result()
	goerr.Check(e)
	return v
}

// UintTaskInternal is passed into a new task function.
type UintTaskInternal struct {
	TaskInternal
	Resolver chan<- uint
}

func (ti *UintTaskInternal) Resolve(v uint) {
	ti.Resolver <- v
}

// NewUint creates new instances of UintTask.
func NewUint(fn func(t *UintTaskInternal)) *UintTask {
	// Spin up some channels
	done := make(chan struct{}, 1)
	stopper := make(chan struct{}, 1)
	tResolver := make(chan uint, 1)
	tRejector := make(chan error, 1)
	tiResolver := make(chan uint, 1)
	tiRejector := make(chan error, 1)

	// Pass those channels into our tasks
	t := &UintTask{}
	t.Resolver = tResolver
	t.Rejector = tRejector
	t.Stopper = &stopper
	t.done = done
	ti := &UintTaskInternal{}
	ti.Resolver = tiResolver
	ti.Rejector = tiRejector
	ti.Stopper = &stopper

	// Execute the task asynchronously
	go func() {
		// Regardless of what the function does we know that it is done
		defer close(done)

		// Catch any panics and reject them
		defer goerr.Handle(func(e error) {
			t.err = e
			tRejector <- t.err
		})

		// Execute the task
		fn(ti)

		// Read the result in a non blocking manner
		select {
		case v := <-tiResolver:
			t.value = v
			tResolver <- t.value
		case e := <-tiRejector:
			t.err = e
			tRejector <- t.err
		default:
		}
	}()

	// Return the task object
	return t
}

// ResolvedUint returns a pre-resolved task
//
// Not type safe, use with care.
func ResolvedUint(v uint) *UintTask {
	done := make(chan struct{}, 1)
	close(done)
	resolver := make(chan uint, 1)
	resolver <- v
	rejector := make(chan error, 1)
	t := &UintTask{}
	t.Resolver = resolver
	t.Rejector = rejector
	t.Stopper = &done
	t.done = done
	t.closed = true
	return t
}

// RejectedUint returns a pre-rejected task
//
// Not type safe, use with care.
func RejectedUint(e error) *UintTask {
	done := make(chan struct{}, 1)
	close(done)
	resolver := make(chan uint, 1)
	rejector := make(chan error, 1)
	rejector <- e
	t := &UintTask{}
	t.Resolver = resolver
	t.Rejector = rejector
	t.Stopper = &done
	t.done = done
	t.closed = true
	return t
}

// Uint16Task represents an asynchronous operation, create new instances with NewUint16.
type Uint16Task struct {
	Task
	Resolver <-chan uint16
	value    uint16
}

func (t *Uint16Task) Result() (uint16, error) {
	<-t.done
	return t.value, t.err
}

func (t *Uint16Task) MustResult() uint16 {
	v, e := t.Result()
	goerr.Check(e)
	return v
}

// Uint16TaskInternal is passed into a new task function.
type Uint16TaskInternal struct {
	TaskInternal
	Resolver chan<- uint16
}

func (ti *Uint16TaskInternal) Resolve(v uint16) {
	ti.Resolver <- v
}

// NewUint16 creates new instances of Uint16Task.
func NewUint16(fn func(t *Uint16TaskInternal)) *Uint16Task {
	// Spin up some channels
	done := make(chan struct{}, 1)
	stopper := make(chan struct{}, 1)
	tResolver := make(chan uint16, 1)
	tRejector := make(chan error, 1)
	tiResolver := make(chan uint16, 1)
	tiRejector := make(chan error, 1)

	// Pass those channels into our tasks
	t := &Uint16Task{}
	t.Resolver = tResolver
	t.Rejector = tRejector
	t.Stopper = &stopper
	t.done = done
	ti := &Uint16TaskInternal{}
	ti.Resolver = tiResolver
	ti.Rejector = tiRejector
	ti.Stopper = &stopper

	// Execute the task asynchronously
	go func() {
		// Regardless of what the function does we know that it is done
		defer close(done)

		// Catch any panics and reject them
		defer goerr.Handle(func(e error) {
			t.err = e
			tRejector <- t.err
		})

		// Execute the task
		fn(ti)

		// Read the result in a non blocking manner
		select {
		case v := <-tiResolver:
			t.value = v
			tResolver <- t.value
		case e := <-tiRejector:
			t.err = e
			tRejector <- t.err
		default:
		}
	}()

	// Return the task object
	return t
}

// ResolvedUint16 returns a pre-resolved task
//
// Not type safe, use with care.
func ResolvedUint16(v uint16) *Uint16Task {
	done := make(chan struct{}, 1)
	close(done)
	resolver := make(chan uint16, 1)
	resolver <- v
	rejector := make(chan error, 1)
	t := &Uint16Task{}
	t.Resolver = resolver
	t.Rejector = rejector
	t.Stopper = &done
	t.done = done
	t.closed = true
	return t
}

// RejectedUint16 returns a pre-rejected task
//
// Not type safe, use with care.
func RejectedUint16(e error) *Uint16Task {
	done := make(chan struct{}, 1)
	close(done)
	resolver := make(chan uint16, 1)
	rejector := make(chan error, 1)
	rejector <- e
	t := &Uint16Task{}
	t.Resolver = resolver
	t.Rejector = rejector
	t.Stopper = &done
	t.done = done
	t.closed = true
	return t
}

// Uint32Task represents an asynchronous operation, create new instances with NewUint32.
type Uint32Task struct {
	Task
	Resolver <-chan uint32
	value    uint32
}

func (t *Uint32Task) Result() (uint32, error) {
	<-t.done
	return t.value, t.err
}

func (t *Uint32Task) MustResult() uint32 {
	v, e := t.Result()
	goerr.Check(e)
	return v
}

// Uint32TaskInternal is passed into a new task function.
type Uint32TaskInternal struct {
	TaskInternal
	Resolver chan<- uint32
}

func (ti *Uint32TaskInternal) Resolve(v uint32) {
	ti.Resolver <- v
}

// NewUint32 creates new instances of Uint32Task.
func NewUint32(fn func(t *Uint32TaskInternal)) *Uint32Task {
	// Spin up some channels
	done := make(chan struct{}, 1)
	stopper := make(chan struct{}, 1)
	tResolver := make(chan uint32, 1)
	tRejector := make(chan error, 1)
	tiResolver := make(chan uint32, 1)
	tiRejector := make(chan error, 1)

	// Pass those channels into our tasks
	t := &Uint32Task{}
	t.Resolver = tResolver
	t.Rejector = tRejector
	t.Stopper = &stopper
	t.done = done
	ti := &Uint32TaskInternal{}
	ti.Resolver = tiResolver
	ti.Rejector = tiRejector
	ti.Stopper = &stopper

	// Execute the task asynchronously
	go func() {
		// Regardless of what the function does we know that it is done
		defer close(done)

		// Catch any panics and reject them
		defer goerr.Handle(func(e error) {
			t.err = e
			tRejector <- t.err
		})

		// Execute the task
		fn(ti)

		// Read the result in a non blocking manner
		select {
		case v := <-tiResolver:
			t.value = v
			tResolver <- t.value
		case e := <-tiRejector:
			t.err = e
			tRejector <- t.err
		default:
		}
	}()

	// Return the task object
	return t
}

// ResolvedUint32 returns a pre-resolved task
//
// Not type safe, use with care.
func ResolvedUint32(v uint32) *Uint32Task {
	done := make(chan struct{}, 1)
	close(done)
	resolver := make(chan uint32, 1)
	resolver <- v
	rejector := make(chan error, 1)
	t := &Uint32Task{}
	t.Resolver = resolver
	t.Rejector = rejector
	t.Stopper = &done
	t.done = done
	t.closed = true
	return t
}

// RejectedUint32 returns a pre-rejected task
//
// Not type safe, use with care.
func RejectedUint32(e error) *Uint32Task {
	done := make(chan struct{}, 1)
	close(done)
	resolver := make(chan uint32, 1)
	rejector := make(chan error, 1)
	rejector <- e
	t := &Uint32Task{}
	t.Resolver = resolver
	t.Rejector = rejector
	t.Stopper = &done
	t.done = done
	t.closed = true
	return t
}

// Uint64Task represents an asynchronous operation, create new instances with NewUint64.
type Uint64Task struct {
	Task
	Resolver <-chan uint64
	value    uint64
}

func (t *Uint64Task) Result() (uint64, error) {
	<-t.done
	return t.value, t.err
}

func (t *Uint64Task) MustResult() uint64 {
	v, e := t.Result()
	goerr.Check(e)
	return v
}

// Uint64TaskInternal is passed into a new task function.
type Uint64TaskInternal struct {
	TaskInternal
	Resolver chan<- uint64
}

func (ti *Uint64TaskInternal) Resolve(v uint64) {
	ti.Resolver <- v
}

// NewUint64 creates new instances of Uint64Task.
func NewUint64(fn func(t *Uint64TaskInternal)) *Uint64Task {
	// Spin up some channels
	done := make(chan struct{}, 1)
	stopper := make(chan struct{}, 1)
	tResolver := make(chan uint64, 1)
	tRejector := make(chan error, 1)
	tiResolver := make(chan uint64, 1)
	tiRejector := make(chan error, 1)

	// Pass those channels into our tasks
	t := &Uint64Task{}
	t.Resolver = tResolver
	t.Rejector = tRejector
	t.Stopper = &stopper
	t.done = done
	ti := &Uint64TaskInternal{}
	ti.Resolver = tiResolver
	ti.Rejector = tiRejector
	ti.Stopper = &stopper

	// Execute the task asynchronously
	go func() {
		// Regardless of what the function does we know that it is done
		defer close(done)

		// Catch any panics and reject them
		defer goerr.Handle(func(e error) {
			t.err = e
			tRejector <- t.err
		})

		// Execute the task
		fn(ti)

		// Read the result in a non blocking manner
		select {
		case v := <-tiResolver:
			t.value = v
			tResolver <- t.value
		case e := <-tiRejector:
			t.err = e
			tRejector <- t.err
		default:
		}
	}()

	// Return the task object
	return t
}

// ResolvedUint64 returns a pre-resolved task
//
// Not type safe, use with care.
func ResolvedUint64(v uint64) *Uint64Task {
	done := make(chan struct{}, 1)
	close(done)
	resolver := make(chan uint64, 1)
	resolver <- v
	rejector := make(chan error, 1)
	t := &Uint64Task{}
	t.Resolver = resolver
	t.Rejector = rejector
	t.Stopper = &done
	t.done = done
	t.closed = true
	return t
}

// RejectedUint64 returns a pre-rejected task
//
// Not type safe, use with care.
func RejectedUint64(e error) *Uint64Task {
	done := make(chan struct{}, 1)
	close(done)
	resolver := make(chan uint64, 1)
	rejector := make(chan error, 1)
	rejector <- e
	t := &Uint64Task{}
	t.Resolver = resolver
	t.Rejector = rejector
	t.Stopper = &done
	t.done = done
	t.closed = true
	return t
}

// Uint8Task represents an asynchronous operation, create new instances with NewUint8.
type Uint8Task struct {
	Task
	Resolver <-chan uint8
	value    uint8
}

func (t *Uint8Task) Result() (uint8, error) {
	<-t.done
	return t.value, t.err
}

func (t *Uint8Task) MustResult() uint8 {
	v, e := t.Result()
	goerr.Check(e)
	return v
}

// Uint8TaskInternal is passed into a new task function.
type Uint8TaskInternal struct {
	TaskInternal
	Resolver chan<- uint8
}

func (ti *Uint8TaskInternal) Resolve(v uint8) {
	ti.Resolver <- v
}

// NewUint8 creates new instances of Uint8Task.
func NewUint8(fn func(t *Uint8TaskInternal)) *Uint8Task {
	// Spin up some channels
	done := make(chan struct{}, 1)
	stopper := make(chan struct{}, 1)
	tResolver := make(chan uint8, 1)
	tRejector := make(chan error, 1)
	tiResolver := make(chan uint8, 1)
	tiRejector := make(chan error, 1)

	// Pass those channels into our tasks
	t := &Uint8Task{}
	t.Resolver = tResolver
	t.Rejector = tRejector
	t.Stopper = &stopper
	t.done = done
	ti := &Uint8TaskInternal{}
	ti.Resolver = tiResolver
	ti.Rejector = tiRejector
	ti.Stopper = &stopper

	// Execute the task asynchronously
	go func() {
		// Regardless of what the function does we know that it is done
		defer close(done)

		// Catch any panics and reject them
		defer goerr.Handle(func(e error) {
			t.err = e
			tRejector <- t.err
		})

		// Execute the task
		fn(ti)

		// Read the result in a non blocking manner
		select {
		case v := <-tiResolver:
			t.value = v
			tResolver <- t.value
		case e := <-tiRejector:
			t.err = e
			tRejector <- t.err
		default:
		}
	}()

	// Return the task object
	return t
}

// ResolvedUint8 returns a pre-resolved task
//
// Not type safe, use with care.
func ResolvedUint8(v uint8) *Uint8Task {
	done := make(chan struct{}, 1)
	close(done)
	resolver := make(chan uint8, 1)
	resolver <- v
	rejector := make(chan error, 1)
	t := &Uint8Task{}
	t.Resolver = resolver
	t.Rejector = rejector
	t.Stopper = &done
	t.done = done
	t.closed = true
	return t
}

// RejectedUint8 returns a pre-rejected task
//
// Not type safe, use with care.
func RejectedUint8(e error) *Uint8Task {
	done := make(chan struct{}, 1)
	close(done)
	resolver := make(chan uint8, 1)
	rejector := make(chan error, 1)
	rejector <- e
	t := &Uint8Task{}
	t.Resolver = resolver
	t.Rejector = rejector
	t.Stopper = &done
	t.done = done
	t.closed = true
	return t
}

// UintptrTask represents an asynchronous operation, create new instances with NewUintptr.
type UintptrTask struct {
	Task
	Resolver <-chan uintptr
	value    uintptr
}

func (t *UintptrTask) Result() (uintptr, error) {
	<-t.done
	return t.value, t.err
}

func (t *UintptrTask) MustResult() uintptr {
	v, e := t.Result()
	goerr.Check(e)
	return v
}

// UintptrTaskInternal is passed into a new task function.
type UintptrTaskInternal struct {
	TaskInternal
	Resolver chan<- uintptr
}

func (ti *UintptrTaskInternal) Resolve(v uintptr) {
	ti.Resolver <- v
}

// NewUintptr creates new instances of UintptrTask.
func NewUintptr(fn func(t *UintptrTaskInternal)) *UintptrTask {
	// Spin up some channels
	done := make(chan struct{}, 1)
	stopper := make(chan struct{}, 1)
	tResolver := make(chan uintptr, 1)
	tRejector := make(chan error, 1)
	tiResolver := make(chan uintptr, 1)
	tiRejector := make(chan error, 1)

	// Pass those channels into our tasks
	t := &UintptrTask{}
	t.Resolver = tResolver
	t.Rejector = tRejector
	t.Stopper = &stopper
	t.done = done
	ti := &UintptrTaskInternal{}
	ti.Resolver = tiResolver
	ti.Rejector = tiRejector
	ti.Stopper = &stopper

	// Execute the task asynchronously
	go func() {
		// Regardless of what the function does we know that it is done
		defer close(done)

		// Catch any panics and reject them
		defer goerr.Handle(func(e error) {
			t.err = e
			tRejector <- t.err
		})

		// Execute the task
		fn(ti)

		// Read the result in a non blocking manner
		select {
		case v := <-tiResolver:
			t.value = v
			tResolver <- t.value
		case e := <-tiRejector:
			t.err = e
			tRejector <- t.err
		default:
		}
	}()

	// Return the task object
	return t
}

// ResolvedUintptr returns a pre-resolved task
//
// Not type safe, use with care.
func ResolvedUintptr(v uintptr) *UintptrTask {
	done := make(chan struct{}, 1)
	close(done)
	resolver := make(chan uintptr, 1)
	resolver <- v
	rejector := make(chan error, 1)
	t := &UintptrTask{}
	t.Resolver = resolver
	t.Rejector = rejector
	t.Stopper = &done
	t.done = done
	t.closed = true
	return t
}

// RejectedUintptr returns a pre-rejected task
//
// Not type safe, use with care.
func RejectedUintptr(e error) *UintptrTask {
	done := make(chan struct{}, 1)
	close(done)
	resolver := make(chan uintptr, 1)
	rejector := make(chan error, 1)
	rejector <- e
	t := &UintptrTask{}
	t.Resolver = resolver
	t.Rejector = rejector
	t.Stopper = &done
	t.done = done
	t.closed = true
	return t
}
